(window.webpackJsonp=window.webpackJsonp||[]).push([[878],{1226:function(n,e){n.exports=function(n){function e(n){"undefined"!==typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!==typeof execScript&&"undefined"!==typeof attachEvent&&"undefined"===typeof addEventListener?execScript(n):"undefined"!==typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(t){e(t)}}},2302:function(n,e,t){"use strict";t.r(e);t(2303),t(2305),t(2307),t(2309),t(2311),t(2313),t(2315),t(2317)},2303:function(n,e,t){t(1226)(t(2304))},2304:function(n,e){n.exports='function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && "object" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error("jQuery requires a window with a document");\n    return b(a);\n  } : b(a);\n}("undefined" != typeof window ? window : this, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = "2.2.4",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };\n\n  n.fn = n.prototype = {\n    jquery: m,\n    constructor: n,\n    selector: "",\n    length: 0,\n    toArray: function toArray() {\n      return e.call(this);\n    },\n    get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    },\n    pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);\n      return b.prevObject = this, b.context = this.context, b;\n    },\n    each: function each(a) {\n      return n.each(this, a);\n    },\n    map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);\n      return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    push: g,\n    sort: c.sort,\n    splice: c.splice\n  }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;\n\n    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == _typeof(g) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }\n\n    return g;\n  }, n.extend({\n    expando: "jQuery" + (m + Math.random()).replace(/\\D/g, ""),\n    isReady: !0,\n    error: function error(a) {\n      throw new Error(a);\n    },\n    noop: function noop() {},\n    isFunction: function isFunction(a) {\n      return "function" === n.type(a);\n    },\n    isArray: Array.isArray,\n    isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    },\n    isNumeric: function isNumeric(a) {\n      var b = a && a.toString();\n      return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    },\n    isPlainObject: function isPlainObject(a) {\n      var b;\n      if ("object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;\n      if (a.constructor && !k.call(a, "constructor") && !k.call(a.constructor.prototype || {}, "isPrototypeOf")) return !1;\n\n      for (b in a) {\n        ;\n      }\n\n      return void 0 === b || k.call(a, b);\n    },\n    isEmptyObject: function isEmptyObject(a) {\n      var b;\n\n      for (b in a) {\n        return !1;\n      }\n\n      return !0;\n    },\n    type: function type(a) {\n      return null == a ? a + "" : "object" == _typeof(a) || "function" == typeof a ? i[j.call(a)] || "object" : _typeof(a);\n    },\n    globalEval: function globalEval(a) {\n      var b,\n          c = eval;\n      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = d.createElement("script"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    },\n    camelCase: function camelCase(a) {\n      return a.replace(p, "ms-").replace(q, r);\n    },\n    nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    },\n    each: function each(a, b) {\n      var c,\n          d = 0;\n\n      if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }\n\n      return a;\n    },\n    trim: function trim(a) {\n      return null == a ? "" : (a + "").replace(o, "");\n    },\n    makeArray: function makeArray(a, b) {\n      var c = b || [];\n      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : g.call(c, a)), c;\n    },\n    inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    },\n    merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }\n\n      return a.length = e, a;\n    },\n    grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }\n\n      return e;\n    },\n    map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];\n      if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }\n      return f.apply([], h);\n    },\n    guid: 1,\n    proxy: function proxy(a, b) {\n      var c, d, f;\n      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    },\n    now: Date.now,\n    support: l\n  }), "function" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (a, b) {\n    i["[object " + b + "]"] = b.toLowerCase();\n  });\n\n  function s(a) {\n    var b = !!a && "length" in a && a.length,\n        c = n.type(a);\n    return "function" === c || n.isWindow(a) ? !1 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;\n  }\n\n  var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = "sizzle" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }\n\n      return -1;\n    },\n        K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n        L = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n        M = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n        N = "\\\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + M + "))|)" + L + "*\\\\]",\n        O = ":(" + M + ")(?:\\\\(((\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + N + ")*)|.*)\\\\)|)",\n        P = new RegExp(L + "+", "g"),\n        Q = new RegExp("^" + L + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + L + "+$", "g"),\n        R = new RegExp("^" + L + "*," + L + "*"),\n        S = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),\n        T = new RegExp("=" + L + "*([^\\\\]\'\\"]*?)" + L + "*\\\\]", "g"),\n        U = new RegExp(O),\n        V = new RegExp("^" + M + "$"),\n        W = {\n      ID: new RegExp("^#(" + M + ")"),\n      CLASS: new RegExp("^\\\\.(" + M + ")"),\n      TAG: new RegExp("^(" + M + "|[*])"),\n      ATTR: new RegExp("^" + N),\n      PSEUDO: new RegExp("^" + O),\n      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + L + "*(even|odd|(([+-]|)(\\\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\\\d+)|))" + L + "*\\\\)|)", "i"),\n      bool: new RegExp("^(?:" + K + ")$", "i"),\n      needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" + L + "*((?:-\\\\d)?\\\\d*)" + L + "*\\\\)|)(?=[^-]|$)", "i")\n    },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /\'|\\\\/g,\n        ba = new RegExp("\\\\\\\\([\\\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),\n        ca = function ca(a, b, c) {\n      var d = "0x" + b - 65536;\n      return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };\n\n    try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = {\n        apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;\n\n          while (a[c++] = b[d++]) {\n            ;\n          }\n\n          a.length = c - 1;\n        }\n      };\n    }\n\n    function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;\n      if (d = d || [], "string" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;\n\n      if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;\n            if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;\n          if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }\n\n        if (c.qsa && !A[a + " "] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if ("object" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute("id")) ? k = k.replace(aa, "\\\\$&") : b.setAttribute("id", k = u), r = g(a), h = r.length, l = V.test(k) ? "#" + k : "[id=\'" + k + "\']";\n\n            while (h--) {\n              r[h] = l + " " + qa(r[h]);\n            }\n\n            s = r.join(","), w = _.test(a) && oa(b.parentNode) || b;\n          }\n          if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute("id");\n          }\n        }\n      }\n\n      return i(a.replace(Q, "$1"), b, d, e);\n    }\n\n    function ga() {\n      var a = [];\n\n      function b(c, e) {\n        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;\n      }\n\n      return b;\n    }\n\n    function ha(a) {\n      return a[u] = !0, a;\n    }\n\n    function ia(a) {\n      var b = n.createElement("div");\n\n      try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }\n\n    function ja(a, b) {\n      var c = a.split("|"),\n          e = c.length;\n\n      while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }\n\n    function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);\n      if (d) return d;\n      if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }\n      return a ? 1 : -1;\n    }\n\n    function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();\n        return "input" === c && b.type === a;\n      };\n    }\n\n    function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();\n        return ("input" === c || "button" === c) && b.type === a;\n      };\n    }\n\n    function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;\n\n          while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }\n\n    function oa(a) {\n      return a && "undefined" != typeof a.getElementsByTagName && a;\n    }\n\n    c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;\n      return b ? "HTML" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;\n      return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ia(function (a) {\n        return a.className = "i", !a.getAttribute("className");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if ("undefined" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);\n          return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);\n        return function (a) {\n          return a.getAttribute("id") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);\n        return function (a) {\n          var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");\n          return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);\n\n        if ("*" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }\n\n          return d;\n        }\n\n        return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return "undefined" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = "<a id=\'" + u + "\'></a><select id=\'" + u + "-\\r\\\\\' msallowcapture=\'\'><option selected=\'\'></option></select>", a.querySelectorAll("[msallowcapture^=\'\']").length && q.push("[*^$]=" + L + "*(?:\'\'|\\"\\")"), a.querySelectorAll("[selected]").length || q.push("\\\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");\n      }), ia(function (a) {\n        var b = n.createElement("input");\n        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!=\'\']:x"), r.push("!=", O);\n      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;\n        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }\n        return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;\n        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;\n        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;\n        var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];\n        if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;\n        if (e === f) return ka(a, b);\n        c = a;\n\n        while (c = c.parentNode) {\n          g.unshift(c);\n        }\n\n        c = b;\n\n        while (c = c.parentNode) {\n          h.unshift(c);\n        }\n\n        while (g[d] === h[d]) {\n          d++;\n        }\n\n        return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, "=\'$1\']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);\n        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}\n      return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);\n      var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;\n      return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error("Syntax error, unrecognized expression: " + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;\n\n      if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }\n\n        while (e--) {\n          a.splice(d[e], 1);\n        }\n      }\n\n      return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = "",\n          d = 0,\n          f = a.nodeType;\n\n      if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if ("string" == typeof a.textContent) return a.textContent;\n\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }\n\n      return c;\n    }, d = fa.selectors = {\n      cacheLength: 50,\n      createPseudo: ha,\n      match: W,\n      attrHandle: {},\n      find: {},\n      relative: {\n        ">": {\n          dir: "parentNode",\n          first: !0\n        },\n        " ": {\n          dir: "parentNode"\n        },\n        "+": {\n          dir: "previousSibling",\n          first: !0\n        },\n        "~": {\n          dir: "previousSibling"\n        }\n      },\n      preFilter: {\n        ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || "").replace(ba, ca), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);\n        },\n        CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fa.error(a[0]), a;\n        },\n        PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];\n          return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        }\n      },\n      filter: {\n        TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();\n          return "*" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        },\n        CLASS: function CLASS(a) {\n          var b = y[a + " "];\n          return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) {\n            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "");\n          });\n        },\n        ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);\n            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(P, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0;\n          };\n        },\n        CHILD: function CHILD(a, b, c, d, e) {\n          var f = "nth" !== a.slice(0, 3),\n              g = "last" !== a.slice(-4),\n              h = "of-type" === b;\n          return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? "nextSibling" : "previousSibling",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;\n\n            if (q) {\n              if (f) {\n                while (p) {\n                  m = b;\n\n                  while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }\n\n                  o = p = "only" === a && !o && "nextSibling";\n                }\n\n                return !0;\n              }\n\n              if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];\n\n                while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];\n                    break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }\n\n              return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        },\n        PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error("unsupported pseudo: " + a);\n          return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;\n\n            while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        }\n      },\n      pseudos: {\n        not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, "$1"));\n          return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;\n\n            while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }),\n        has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }),\n        contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }),\n        lang: ha(function (a) {\n          return V.test(a || "") || fa.error("unsupported lang: " + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;\n\n            do {\n              if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-");\n            } while ((b = b.parentNode) && 1 === b.nodeType);\n\n            return !1;\n          };\n        }),\n        target: function target(b) {\n          var c = a.location && a.location.hash;\n          return c && c.slice(1) === b.id;\n        },\n        root: function root(a) {\n          return a === o;\n        },\n        focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        },\n        enabled: function enabled(a) {\n          return a.disabled === !1;\n        },\n        disabled: function disabled(a) {\n          return a.disabled === !0;\n        },\n        checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();\n          return "input" === b && !!a.checked || "option" === b && !!a.selected;\n        },\n        selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        },\n        empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }\n\n          return !0;\n        },\n        parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        },\n        header: function header(a) {\n          return Y.test(a.nodeName);\n        },\n        input: function input(a) {\n          return X.test(a.nodeName);\n        },\n        button: function button(a) {\n          var b = a.nodeName.toLowerCase();\n          return "input" === b && "button" === a.type || "button" === b;\n        },\n        text: function text(a) {\n          var b;\n          return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());\n        },\n        first: na(function () {\n          return [0];\n        }),\n        last: na(function (a, b) {\n          return [b - 1];\n        }),\n        eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }),\n        even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }\n\n          return a;\n        }),\n        odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }\n\n          return a;\n        }),\n        lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }\n\n          return a;\n        }),\n        gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }\n\n          return a;\n        })\n      }\n    }, d.pseudos.nth = d.pseudos.eq;\n\n    for (b in {\n      radio: !0,\n      checkbox: !0,\n      file: !0,\n      password: !0,\n      image: !0\n    }) {\n      d.pseudos[b] = la(b);\n    }\n\n    for (b in {\n      submit: !0,\n      reset: !0\n    }) {\n      d.pseudos[b] = ma(b);\n    }\n\n    function pa() {}\n\n    pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + " "];\n      if (k) return b ? 0 : k.slice(0);\n      h = a, i = [], j = d.preFilter;\n\n      while (h) {\n        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({\n          value: c,\n          type: e[0].replace(Q, " ")\n        }), h = h.slice(c.length));\n\n        for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({\n            value: c,\n            type: g,\n            matches: e\n          }), h = h.slice(c.length));\n        }\n\n        if (!c) break;\n      }\n\n      return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };\n\n    function qa(a) {\n      for (var b = 0, c = a.length, d = ""; c > b; b++) {\n        d += a[b].value;\n      }\n\n      return d;\n    }\n\n    function ra(a, b, c) {\n      var d = b.dir,\n          e = c && "parentNode" === d,\n          f = x++;\n      return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];\n\n        if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];\n            if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }\n\n    function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;\n\n        while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }\n\n        return !0;\n      } : a[0];\n    }\n\n    function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }\n\n      return c;\n    }\n\n    function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n      }\n\n      return g;\n    }\n\n    function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || "*", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;\n\n        if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;\n\n          while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }\n\n        if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;\n\n              while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }\n\n              e(null, r = [], j, i);\n            }\n\n            k = r.length;\n\n            while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }\n\n    function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));\n        return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }\n\n            return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({\n              value: " " === a[i - 2].type ? "*" : ""\n            })).replace(Q, "$1"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }\n\n          m.push(c);\n        }\n      }\n\n      return sa(m);\n    }\n\n    function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = "0",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG("*", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;\n\n        for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);\n\n            while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);\n                break;\n              }\n            }\n\n            k && (w = y);\n          }\n\n          c && ((l = !q && l) && r--, _f && t.push(l));\n        }\n\n        if (r += s, c && s !== r) {\n          o = 0;\n\n          while (q = b[o++]) {\n            q(t, u, g, h);\n          }\n\n          if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }\n            u = ua(u);\n          }\n\n          H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }\n\n        return k && (w = y, j = v), t;\n      };\n\n      return c ? ha(f) : f;\n    }\n\n    return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + " "];\n\n      if (!f) {\n        b || (b = g(a)), c = b.length;\n\n        while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }\n\n        f = A(a, xa(e, d)), f.selector = a;\n      }\n\n      return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = "function" == typeof a && a,\n          o = !f && g(a = n.selector || a);\n\n      if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;\n          n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }\n\n        i = W.needsContext.test(a) ? 0 : j.length;\n\n        while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;\n\n          if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;\n            break;\n          }\n        }\n      }\n\n      return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement("div"));\n    }), ia(function (a) {\n      return a.innerHTML = "<a href=\'#\'></a>", "#" === a.firstChild.getAttribute("href");\n    }) || ja("type|href|height|width", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");\n    }) || ja("value", function (a, b, c) {\n      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute("disabled");\n    }) || ja(K, function (a, b, c) {\n      var d;\n      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);\n\n  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;\n\n  var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;\n\n    while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;\n        d.push(a);\n      }\n    }\n\n    return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }\n\n    return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;\n\n  function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });\n    if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });\n\n    if ("string" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);\n      b = n.filter(b, a);\n    }\n\n    return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }\n\n  n.filter = function (a, b, c) {\n    var d = b[0];\n    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({\n    find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;\n      if ("string" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));\n\n      for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }\n\n      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d;\n    },\n    filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    },\n    not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    },\n    is: function is(a) {\n      return !!z(this, "string" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    }\n  });\n\n  var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;\n    if (!a) return this;\n\n    if (c = c || A, "string" == typeof a) {\n      if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);\n\n      if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }\n        return this;\n      }\n\n      return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }\n\n    return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };\n\n  C.prototype = n.fn, A = n(d);\n  var D = /^(?:parents|prev(?:Until|All))/,\n      E = {\n    children: !0,\n    contents: !0,\n    next: !0,\n    prev: !0\n  };\n  n.fn.extend({\n    has: function has(a) {\n      var b = n(a, this),\n          c = b.length;\n      return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    },\n    closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);\n            break;\n          }\n        }\n      }\n\n      return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    },\n    index: function index(a) {\n      return a ? "string" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    },\n    add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    },\n    addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    }\n  });\n\n  function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {\n      ;\n    }\n\n    return a;\n  }\n\n  n.each({\n    parent: function parent(a) {\n      var b = a.parentNode;\n      return b && 11 !== b.nodeType ? b : null;\n    },\n    parents: function parents(a) {\n      return u(a, "parentNode");\n    },\n    parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, "parentNode", c);\n    },\n    next: function next(a) {\n      return F(a, "nextSibling");\n    },\n    prev: function prev(a) {\n      return F(a, "previousSibling");\n    },\n    nextAll: function nextAll(a) {\n      return u(a, "nextSibling");\n    },\n    prevAll: function prevAll(a) {\n      return u(a, "previousSibling");\n    },\n    nextUntil: function nextUntil(a, b, c) {\n      return u(a, "nextSibling", c);\n    },\n    prevUntil: function prevUntil(a, b, c) {\n      return u(a, "previousSibling", c);\n    },\n    siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    },\n    children: function children(a) {\n      return v(a.firstChild);\n    },\n    contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    }\n  }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);\n      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });\n  var G = /\\S+/g;\n\n  function H(a) {\n    var b = {};\n    return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }\n\n  n.Callbacks = function (a) {\n    a = "string" == typeof a ? H(a) : n.extend({}, a);\n\n    var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();\n\n        while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }\n\n      a.memory || (c = !1), b = !1, e && (f = c ? [] : "");\n    },\n        j = {\n      add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      },\n      remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;\n\n          while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      },\n      has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      },\n      empty: function empty() {\n        return f && (f = []), this;\n      },\n      disable: function disable() {\n        return e = g = [], f = c = "", this;\n      },\n      disabled: function disabled() {\n        return !f;\n      },\n      lock: function lock() {\n        return e = g = [], c || (f = c = ""), this;\n      },\n      locked: function locked() {\n        return !!e;\n      },\n      fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      },\n      fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      },\n      fired: function fired() {\n        return !!d;\n      }\n    };\n\n    return j;\n  }, n.extend({\n    Deferred: function Deferred(a) {\n      var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]],\n          c = "pending",\n          d = {\n        state: function state() {\n          return c;\n        },\n        always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        },\n        then: function then() {\n          var a = arguments;\n          return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];\n              e[f[1]](function () {\n                var a = g && g.apply(this, arguments);\n                a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        },\n        promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        }\n      },\n          e = {};\n      return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];\n        d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + "With"](this === e ? d : this, arguments), this;\n        }, e[f[0] + "With"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    },\n    when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;\n\n      if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }\n      return f || g.resolveWith(k, c), g.promise();\n    }\n  });\n  var I;\n  n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({\n    isReady: !1,\n    readyWait: 1,\n    holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    },\n    ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler("ready"), n(d).off("ready"))));\n    }\n  });\n\n  function J() {\n    d.removeEventListener("DOMContentLoaded", J), a.removeEventListener("load", J), n.ready();\n  }\n\n  n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener("DOMContentLoaded", J), a.addEventListener("load", J))), I.promise(b);\n  }, n.ready.promise();\n\n  var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;\n\n    if ("object" === n.type(c)) {\n      e = !0;\n\n      for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }\n\n    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };\n\n  function M() {\n    this.expando = n.expando + M.uid++;\n  }\n\n  M.uid = 1, M.prototype = {\n    register: function register(a, b) {\n      var c = b || {};\n      return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, {\n        value: c,\n        writable: !0,\n        configurable: !0\n      }), a[this.expando];\n    },\n    cache: function cache(a) {\n      if (!L(a)) return {};\n      var b = a[this.expando];\n      return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {\n        value: b,\n        configurable: !0\n      }))), b;\n    },\n    set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);\n      if ("string" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }\n      return e;\n    },\n    get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    },\n    access: function access(a, b, c) {\n      var d;\n      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    },\n    remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];\n\n      if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;\n\n          while (c--) {\n            delete f[d[c]];\n          }\n        }\n        (void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    },\n    hasData: function hasData(a) {\n      var b = a[this.expando];\n      return void 0 !== b && !n.isEmptyObject(b);\n    }\n  };\n  var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;\n\n  function R(a, b, c) {\n    var d;\n    if (void 0 === c && 1 === a.nodeType) if (d = "data-" + b.replace(Q, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {\n      try {\n        c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}\n\n      O.set(a, b, c);\n    } else c = void 0;\n    return c;\n  }\n\n  n.extend({\n    hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    },\n    data: function data(a, b, c) {\n      return O.access(a, b, c);\n    },\n    removeData: function removeData(a, b) {\n      O.remove(a, b);\n    },\n    _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    },\n    _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    }\n  }), n.fn.extend({\n    data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;\n\n      if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, "hasDataAttrs"))) {\n          c = g.length;\n\n          while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }\n\n          N.set(f, "hasDataAttrs", !0);\n        }\n\n        return e;\n      }\n\n      return "object" == _typeof(a) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;\n\n        if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, "-$&").toLowerCase()), void 0 !== c) return c;\n          if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;\n          if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);\n          O.set(this, d, b), a.indexOf("-") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    },\n    removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    }\n  }), n.extend({\n    queue: function queue(a, b, c) {\n      var d;\n      return a ? (b = (b || "fx") + "queue", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    },\n    dequeue: function dequeue(a, b) {\n      b = b || "fx";\n\n      var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\n\n      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    },\n    _queueHooks: function _queueHooks(a, b) {\n      var c = b + "queueHooks";\n      return N.get(a, c) || N.access(a, c, {\n        empty: n.Callbacks("once memory").add(function () {\n          N.remove(a, [b + "queue", c]);\n        })\n      });\n    }\n  }), n.fn.extend({\n    queue: function queue(a, b) {\n      var c = 2;\n      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);\n        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a);\n      });\n    },\n    dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    },\n    clearQueue: function clearQueue(a) {\n      return this.queue(a || "fx", []);\n    },\n    promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\n\n      "string" != typeof a && (b = a, a = void 0), a = a || "fx";\n\n      while (g--) {\n        c = N.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));\n      }\n\n      return h(), e.promise(b);\n    }\n  });\n\n  var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"),\n      U = ["Top", "Right", "Bottom", "Left"],\n      V = function V(a, b) {\n    return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a);\n  };\n\n  function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, "");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? "" : "px"),\n        k = (n.cssNumber[b] || "px" !== j && +i) && T.exec(n.css(a, b));\n\n    if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;\n\n      do {\n        f = f || ".5", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }\n\n    return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }\n\n  var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = {\n    option: [1, "<select multiple=\'multiple\'>", "</select>"],\n    thead: [1, "<table>", "</table>"],\n    col: [2, "<table><colgroup>", "</colgroup></table>"],\n    tr: [2, "<table><tbody>", "</tbody></table>"],\n    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],\n    _default: [0, "", ""]\n  };\n  $.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;\n\n  function _(a, b) {\n    var c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [];\n    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }\n\n  function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], "globalEval", !b || N.get(b[c], "globalEval"));\n    }\n  }\n\n  var ba = /<|&#?\\w+;/;\n\n  function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if ("object" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement("div")), h = (Y.exec(f) || ["", ""])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];\n\n        while (k--) {\n          g = g.lastChild;\n        }\n\n        n.merge(m, g.childNodes), g = l.firstChild, g.textContent = "";\n      } else m.push(b.createTextNode(f));\n    }\n\n    l.textContent = "", o = 0;\n\n    while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), "script"), j && aa(g), c) {\n        k = 0;\n\n        while (f = g[k++]) {\n          Z.test(f.type || "") && c.push(f);\n        }\n      }\n    }\n\n    return l;\n  }\n\n  !function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement("div")),\n        c = d.createElement("input");\n    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();\n  var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;\n\n  function ga() {\n    return !0;\n  }\n\n  function ha() {\n    return !1;\n  }\n\n  function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }\n\n  function ja(a, b, c, d, e, f) {\n    var g, h;\n\n    if ("object" == _typeof(b)) {\n      "string" != typeof c && (d = d || c, c = void 0);\n\n      for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }\n\n      return a;\n    }\n\n    if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;\n    return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }\n\n  n.event = {\n    global: {},\n    add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);\n\n      if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return "undefined" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || "").match(G) || [""], j = b.length;\n\n        while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({\n            type: o,\n            origType: q,\n            data: d,\n            handler: c,\n            guid: c.guid,\n            selector: e,\n            needsContext: e && n.expr.match.needsContext.test(e),\n            namespace: p.join(".")\n          }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    },\n    remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);\n\n      if (r && (i = r.events)) {\n        b = (b || "").match(G) || [""], j = b.length;\n\n        while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\\\.)" + p.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)"), g = f = m.length;\n\n            while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }\n\n            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }\n\n        n.isEmptyObject(i) && N.remove(a, "handle events");\n      }\n    },\n    dispatch: function dispatch(a) {\n      a = n.event.fix(a);\n      var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, "events") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};\n\n      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;\n\n        while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;\n\n          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }\n\n        return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    },\n    handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;\n      if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }\n\n          d.length && g.push({\n            elem: i,\n            handlers: d\n          });\n        }\n      }\n      return h < b.length && g.push({\n        elem: this,\n        handlers: b.slice(h)\n      }), g;\n    },\n    props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),\n    fixHooks: {},\n    keyHooks: {\n      props: "char charCode key keyCode".split(" "),\n      filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      }\n    },\n    mouseHooks: {\n      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),\n      filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;\n        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      }\n    },\n    fix: function fix(a) {\n      if (a[n.expando]) return a;\n      var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];\n      h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;\n\n      while (b--) {\n        c = e[b], a[c] = g[c];\n      }\n\n      return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    },\n    special: {\n      load: {\n        noBubble: !0\n      },\n      focus: {\n        trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        },\n        delegateType: "focusin"\n      },\n      blur: {\n        trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        },\n        delegateType: "focusout"\n      },\n      click: {\n        trigger: function trigger() {\n          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0;\n        },\n        _default: function _default(a) {\n          return n.nodeName(a.target, "a");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        }\n      }\n    }\n  }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = {\n    constructor: n.Event,\n    isDefaultPrevented: ha,\n    isPropagationStopped: ha,\n    isImmediatePropagationStopped: ha,\n    isSimulated: !1,\n    preventDefault: function preventDefault() {\n      var a = this.originalEvent;\n      this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault();\n    },\n    stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;\n      this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation();\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;\n      this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n    }\n  }, n.each({\n    mouseenter: "mouseover",\n    mouseleave: "mouseout",\n    pointerenter: "pointerover",\n    pointerleave: "pointerout"\n  }, function (a, b) {\n    n.event.special[a] = {\n      delegateType: b,\n      bindType: b,\n      handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;\n        return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      }\n    };\n  }), n.fn.extend({\n    on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    },\n    one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    },\n    off: function off(a, b, c) {\n      var d, e;\n      if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;\n\n      if ("object" == _typeof(a)) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }\n\n        return this;\n      }\n\n      return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    }\n  });\n  var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n  function pa(a, b) {\n    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;\n  }\n\n  function qa(a) {\n    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a;\n  }\n\n  function ra(a) {\n    var b = na.exec(a.type);\n    return b ? a.type = b[1] : a.removeAttribute("type"), a;\n  }\n\n  function sa(a, b) {\n    var c, d, e, f, g, h, i, j;\n\n    if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};\n\n        for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }\n\n      O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }\n\n  function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\n    "input" === c && X.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue);\n  }\n\n  function ua(a, b, c, d) {\n    b = f.apply([], b);\n    var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);\n    if (r || o > 1 && "string" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);\n      r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });\n\n    if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, "script"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, "script"))), c.call(a[m], j, m);\n      }\n\n      if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || "") && !N.access(j, "globalEval") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, "")));\n      }\n    }\n\n    return a;\n  }\n\n  function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, "script")), d.parentNode.removeChild(d));\n    }\n\n    return a;\n  }\n\n  n.extend({\n    htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, "<$1></$2>");\n    },\n    clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);\n      if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }\n      if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);\n      return g = _(h, "script"), g.length > 0 && aa(g, !i && _(a, "script")), h;\n    },\n    cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }\n            c[N.expando] = void 0;\n          }\n\n          c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    }\n  }), n.fn.extend({\n    domManip: ua,\n    detach: function detach(a) {\n      return va(this, a, !0);\n    },\n    remove: function remove(a) {\n      return va(this, a);\n    },\n    text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    },\n    append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);\n          b.appendChild(a);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);\n          b.insertBefore(a, b.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    },\n    after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    },\n    empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = "");\n      }\n\n      return this;\n    },\n    clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    },\n    html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;\n        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;\n\n        if ("string" == typeof a && !la.test(a) && !$[(Y.exec(a) || ["", ""])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);\n\n          try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }\n\n            b = 0;\n          } catch (e) {}\n        }\n\n        b && this.empty().append(a);\n      }, null, a, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var a = [];\n      return ua(this, arguments, function (b) {\n        var c = this.parentNode;\n        n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    }\n  }), n.each({\n    appendTo: "append",\n    prependTo: "prepend",\n    insertBefore: "before",\n    insertAfter: "after",\n    replaceAll: "replaceWith"\n  }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }\n\n      return this.pushStack(d);\n    };\n  });\n  var wa,\n      xa = {\n    HTML: "block",\n    BODY: "block"\n  };\n\n  function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], "display");\n    return c.detach(), d;\n  }\n\n  function za(a) {\n    var b = d,\n        c = xa[a];\n    return c || (c = ya(a, b), "none" !== c && c || (wa = (wa || n("<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }\n\n  var Aa = /^margin/,\n      Ba = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;\n    return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};\n\n    for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }\n\n    e = c.apply(a, d || []);\n\n    for (f in b) {\n      a.style[f] = g[f];\n    }\n\n    return e;\n  },\n      Ea = d.documentElement;\n\n  !function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement("div"),\n        h = d.createElement("div");\n\n    if (h.style) {\n      var _i = function _i() {\n        h.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Ea.appendChild(g);\n        var d = a.getComputedStyle(h);\n        b = "1%" !== d.top, f = "2px" === d.marginLeft, c = "4px" === d.width, h.style.marginRight = "50%", e = "4px" === d.marginRight, Ea.removeChild(g);\n      };\n\n      h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h);\n      n.extend(l, {\n        pixelPosition: function pixelPosition() {\n          return _i(), b;\n        },\n        boxSizingReliable: function boxSizingReliable() {\n          return null == c && _i(), c;\n        },\n        pixelMarginRight: function pixelMarginRight() {\n          return null == c && _i(), e;\n        },\n        reliableMarginLeft: function reliableMarginLeft() {\n          return null == c && _i(), f;\n        },\n        reliableMarginRight: function reliableMarginRight() {\n          var b,\n              c = h.appendChild(d.createElement("div"));\n          return c.style.cssText = h.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", h.style.width = "1px", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n        }\n      });\n    }\n  }();\n\n  function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;\n    return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + "" : g;\n  }\n\n  function Ga(a, b) {\n    return {\n      get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      }\n    };\n  }\n\n  var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = {\n    position: "absolute",\n    visibility: "hidden",\n    display: "block"\n  },\n      Ja = {\n    letterSpacing: "0",\n    fontWeight: "400"\n  },\n      Ka = ["Webkit", "O", "Moz", "ms"],\n      La = d.createElement("div").style;\n\n  function Ma(a) {\n    if (a in La) return a;\n    var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;\n\n    while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }\n\n  function Na(a, b, c) {\n    var d = T.exec(b);\n    return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b;\n  }\n\n  function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      "margin" === c && (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e)));\n    }\n\n    return g;\n  }\n\n  function Pa(a, b, c) {\n    var d = !0,\n        e = "width" === b ? a.offsetWidth : a.offsetHeight,\n        f = Ca(a),\n        g = "border-box" === n.css(a, "boxSizing", !1, f);\n\n    if (0 >= e || null == e) {\n      if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e;\n      d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n    }\n\n    return e + Oa(a, b, c || (g ? "border" : "content"), d, f) + "px";\n  }\n\n  function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && V(d) && (f[g] = N.access(d, "olddisplay", za(d.nodeName)))) : (e = V(d), "none" === c && e || N.set(d, "olddisplay", e ? c : n.css(d, "display"))));\n    }\n\n    for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));\n    }\n\n    return a;\n  }\n\n  n.extend({\n    cssHooks: {\n      opacity: {\n        get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, "opacity");\n            return "" === c ? "1" : c;\n          }\n        }\n      }\n    },\n    cssNumber: {\n      animationIterationCount: !0,\n      columnCount: !0,\n      fillOpacity: !0,\n      flexGrow: !0,\n      flexShrink: !0,\n      fontWeight: !0,\n      lineHeight: !0,\n      opacity: !0,\n      order: !0,\n      orphans: !0,\n      widows: !0,\n      zIndex: !0,\n      zoom: !0\n    },\n    cssProps: {\n      "float": "cssFloat"\n    },\n    style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;\n        return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = _typeof(c), "string" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (n.cssNumber[h] ? "" : "px")), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    },\n    css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);\n      return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), "normal" === e && b in Ja && (e = Ja[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    }\n  }), n.each(["height", "width"], function (a, b) {\n    n.cssHooks[b] = {\n      get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, "display")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      },\n      set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, "border-box" === n.css(a, "boxSizing", !1, f), f);\n        return g && (e = T.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      }\n    };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, "marginLeft")) || a.getBoundingClientRect().left - Da(a, {\n      marginLeft: 0\n    }, function () {\n      return a.getBoundingClientRect().left;\n    })) + "px" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, {\n      display: "inline-block"\n    }, Fa, [a, "marginRight"]) : void 0;\n  }), n.each({\n    margin: "",\n    padding: "",\n    border: "Width"\n  }, function (a, b) {\n    n.cssHooks[a + b] = {\n      expand: function expand(c) {\n        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }\n\n        return e;\n      }\n    }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({\n    css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;\n\n        if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }\n\n          return f;\n        }\n\n        return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    },\n    show: function show() {\n      return Qa(this, !0);\n    },\n    hide: function hide() {\n      return Qa(this);\n    },\n    toggle: function toggle(a) {\n      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    }\n  });\n\n  function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }\n\n  n.Tween = Ra, Ra.prototype = {\n    constructor: Ra,\n    init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px");\n    },\n    cur: function cur() {\n      var a = Ra.propHooks[this.prop];\n      return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    },\n    run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];\n      return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    }\n  }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = {\n    _default: {\n      get: function get(a) {\n        var b;\n        return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0);\n      },\n      set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      }\n    }\n  }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = {\n    set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    }\n  }, n.easing = {\n    linear: function linear(a) {\n      return a;\n    },\n    swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    },\n    _default: "swing"\n  }, n.fx = Ra.prototype.init, n.fx.step = {};\n  var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;\n\n  function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }\n\n  function Xa(a, b) {\n    var c,\n        d = 0,\n        e = {\n      height: a\n    };\n\n    for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e["margin" + c] = e["padding" + c] = a;\n    }\n\n    return b && (e.opacity = e.width = a), e;\n  }\n\n  function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners["*"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }\n\n  function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, "fxshow");\n    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, "fx").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? N.get(a, "olddisplay") || za(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));\n\n    for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {\n          if ("show" !== e || !q || void 0 === q[d]) continue;\n          p = !0;\n        }\n\n        m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }\n\n    if (n.isEmptyObject(m)) "inline" === ("none" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? "hidden" in q && (p = q.hidden) : q = N.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;\n        N.remove(a, "fxshow");\n\n        for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });\n\n      for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0));\n      }\n    }\n  }\n\n  function $a(a, b) {\n    var c, d, e, f, g;\n\n    for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {\n        f = g.expand(f), delete a[d];\n\n        for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }\n\n  function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;\n\n      for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }\n\n      return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({\n      elem: a,\n      props: n.extend({}, b),\n      opts: n.extend(!0, {\n        specialEasing: {},\n        easing: n.easing._default\n      }, c),\n      originalProperties: b,\n      originalOptions: c,\n      startTime: Sa || Wa(),\n      duration: c.duration,\n      tweens: [],\n      createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);\n        return j.tweens.push(d), d;\n      },\n      stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;\n        if (e) return this;\n\n        for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }\n\n        return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      }\n    }),\n        k = j.props;\n\n    for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }\n\n    return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {\n      elem: a,\n      anim: j,\n      queue: j.opts.queue\n    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }\n\n  n.Animation = n.extend(_a, {\n    tweeners: {\n      "*": [function (a, b) {\n        var c = this.createTween(a, b);\n        return W(c.elem, a, T.exec(b), c), c;\n      }]\n    },\n    tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(G);\n\n      for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    },\n    prefilters: [Za],\n    prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    }\n  }), n.speed = function (a, b, c) {\n    var d = a && "object" == _typeof(a) ? n.extend({}, a) : {\n      complete: c || !c && b || n.isFunction(a) && a,\n      duration: a,\n      easing: c && b || b && !n.isFunction(b) && b\n    };\n    return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({\n    fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css("opacity", 0).show().end().animate({\n        opacity: b\n      }, a, c, d);\n    },\n    animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);\n\n        (e || N.get(this, "finish")) && b.stop(!0);\n      };\n\n      return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    },\n    stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;\n        delete a.stop, b(c);\n      };\n\n      return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + "queueHooks",\n            f = n.timers,\n            g = N.get(this);\n        if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }\n\n        for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }\n\n        !b && c || n.dequeue(this, a);\n      });\n    },\n    finish: function finish(a) {\n      return a !== !1 && (a = a || "fx"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + "queue"],\n            e = c[a + "queueHooks"],\n            f = n.timers,\n            g = d ? d.length : 0;\n\n        for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }\n\n        for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }\n\n        delete c.finish;\n      });\n    }\n  }), n.each(["toggle", "show", "hide"], function (a, b) {\n    var c = n.fn[b];\n\n    n.fn[b] = function (a, d, e) {\n      return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({\n    slideDown: Xa("show"),\n    slideUp: Xa("hide"),\n    slideToggle: Xa("toggle"),\n    fadeIn: {\n      opacity: "show"\n    },\n    fadeOut: {\n      opacity: "hide"\n    },\n    fadeToggle: {\n      opacity: "toggle"\n    }\n  }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;\n\n    for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }\n\n    c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    _default: 400\n  }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);\n\n      d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement("input"),\n        b = d.createElement("select"),\n        c = b.appendChild(d.createElement("option"));\n    a.type = "checkbox", l.checkOn = "" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement("input"), a.value = "t", a.type = "radio", l.radioValue = "t" === a.value;\n  }();\n  var ab,\n      bb = n.expr.attrHandle;\n  n.fn.extend({\n    attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    }\n  }), n.extend({\n    attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;\n      if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    },\n    attrHooks: {\n      type: {\n        set: function set(a, b) {\n          if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) {\n            var c = a.value;\n            return a.setAttribute("type", b), c && (a.value = c), b;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);\n      if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    }\n  }), ab = {\n    set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    }\n  }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;\n\n    bb[b] = function (a, b, d) {\n      var e, f;\n      return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });\n  var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;\n  n.fn.extend({\n    prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    },\n    removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    }\n  }), n.extend({\n    prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;\n      if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(a) {\n          var b = n.find.attr(a, "tabindex");\n          return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        }\n      }\n    },\n    propFix: {\n      "for": "htmlFor",\n      "class": "className"\n    }\n  }), l.optSelected || (n.propHooks.selected = {\n    get: function get(a) {\n      var b = a.parentNode;\n      return b && b.parentNode && b.parentNode.selectedIndex, null;\n    },\n    set: function set(a) {\n      var b = a.parentNode;\n      b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n    }\n  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });\n  var eb = /[\\t\\r\\n\\f]/g;\n\n  function fb(a) {\n    return a.getAttribute && a.getAttribute("class") || "";\n  }\n\n  n.fn.extend({\n    addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;\n      if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });\n\n      if ("string" == typeof a && a) {\n        b = a.match(G) || [];\n\n        while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {\n            g = 0;\n\n            while (f = b[g++]) {\n              d.indexOf(" " + f + " ") < 0 && (d += f + " ");\n            }\n\n            h = n.trim(d), e !== h && c.setAttribute("class", h);\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;\n      if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });\n      if (!arguments.length) return this.attr("class", "");\n\n      if ("string" == typeof a && a) {\n        b = a.match(G) || [];\n\n        while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {\n            g = 0;\n\n            while (f = b[g++]) {\n              while (d.indexOf(" " + f + " ") > -1) {\n                d = d.replace(" " + f + " ", " ");\n              }\n            }\n\n            h = n.trim(d), e !== h && c.setAttribute("class", h);\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(a, b) {\n      var c = _typeof(a);\n\n      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;\n\n        if ("string" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];\n\n          while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else void 0 !== a && "boolean" !== c || (b = fb(this), b && N.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : N.get(this, "__className__") || ""));\n      });\n    },\n    hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;\n      b = " " + a + " ";\n\n      while (c = this[d++]) {\n        if (1 === c.nodeType && (" " + fb(c) + " ").replace(eb, " ").indexOf(b) > -1) return !0;\n      }\n\n      return !1;\n    }\n  });\n  var gb = /\\r/g,\n      hb = /[\\x20\\t\\r\\n\\f]+/g;\n  n.fn.extend({\n    val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];\n      {\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;\n          1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? "" : a + "";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));\n        });\n        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(gb, "") : null == c ? "" : c);\n      }\n    }\n  }), n.extend({\n    valHooks: {\n      option: {\n        get: function get(a) {\n          var b = n.find.attr(a, "value");\n          return null != b ? b : n.trim(n.text(a)).replace(hb, " ");\n        }\n      },\n      select: {\n        get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, "optgroup"))) {\n              if (b = n(c).val(), f) return b;\n              g.push(b);\n            }\n          }\n\n          return g;\n        },\n        set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;\n\n          while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }\n\n          return c || (a.selectedIndex = -1), f;\n        }\n      }\n    }\n  }), n.each(["radio", "checkbox"], function () {\n    n.valHooks[this] = {\n      set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      }\n    }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute("value") ? "on" : a.value;\n    });\n  });\n  var ib = /^(?:focusinfocus|focusoutblur)$/;\n  n.extend(n.event, {\n    trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, "type") ? b.type : b,\n          r = k.call(b, "namespace") ? b.namespace.split(".") : [];\n\n      if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(".") > -1 && (r = q.split("."), q = r.shift(), r.sort()), l = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == _typeof(b) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\\\.)" + r.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }\n\n          i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }\n\n        g = 0;\n\n        while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, "events") || {})[b.type] && N.get(h, "handle"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }\n\n        return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    },\n    simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, {\n        type: a,\n        isSimulated: !0\n      });\n      n.event.trigger(d, null, b);\n    }\n  }), n.fn.extend({\n    trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    },\n    triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];\n      return c ? n.event.trigger(a, b, c, !0) : void 0;\n    }\n  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({\n    hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    }\n  }), l.focusin = "onfocusin" in a, l.focusin || n.each({\n    focus: "focusin",\n    blur: "focusout"\n  }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };\n\n    n.event.special[b] = {\n      setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);\n        e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      },\n      teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;\n        e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      }\n    };\n  });\n  var jb = a.location,\n      kb = n.now(),\n      lb = /\\?/;\n  n.parseJSON = function (a) {\n    return JSON.parse(a + "");\n  }, n.parseXML = function (b) {\n    var c;\n    if (!b || "string" != typeof b) return null;\n\n    try {\n      c = new a.DOMParser().parseFromString(b, "text/xml");\n    } catch (d) {\n      c = void 0;\n    }\n\n    return c && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c;\n  };\n  var mb = /#.*$/,\n      nb = /([?&])_=[^&]*/,\n      ob = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      qb = /^(?:GET|HEAD)$/,\n      rb = /^\\/\\//,\n      sb = {},\n      tb = {},\n      ub = "*/".concat("*"),\n      vb = d.createElement("a");\n  vb.href = jb.href;\n\n  function wb(a) {\n    return function (b, c) {\n      "string" != typeof b && (c = b, b = "*");\n      var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];\n      if (n.isFunction(c)) while (d = f[e++]) {\n        "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }\n\n  function xb(a, b, c, d) {\n    var e = {},\n        f = a === tb;\n\n    function g(h) {\n      var i;\n      return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);\n        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }\n\n    return g(b.dataTypes[0]) || !e["*"] && g("*");\n  }\n\n  function yb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};\n\n    for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }\n\n    return d && n.extend(!0, a, d), a;\n  }\n\n  function zb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;\n\n    while ("*" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));\n    }\n\n    if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);\n        break;\n      }\n    }\n    if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + " " + i[0]]) {\n          f = e;\n          break;\n        }\n\n        g || (g = e);\n      }\n\n      f = f || g;\n    }\n    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }\n\n  function Ab(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();\n    if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }\n    f = k.shift();\n\n    while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i;else if ("*" !== i && i !== f) {\n        if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) {\n          if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));\n            break;\n          }\n        }\n        if (g !== !0) if (g && a["throws"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return {\n            state: "parsererror",\n            error: g ? l : "No conversion from " + i + " to " + f\n          };\n        }\n      }\n    }\n\n    return {\n      state: "success",\n      data: b\n    };\n  }\n\n  n.extend({\n    active: 0,\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: jb.href,\n      type: "GET",\n      isLocal: pb.test(jb.protocol),\n      global: !0,\n      processData: !0,\n      async: !0,\n      contentType: "application/x-www-form-urlencoded; charset=UTF-8",\n      accepts: {\n        "*": ub,\n        text: "text/plain",\n        html: "text/html",\n        xml: "application/xml, text/xml",\n        json: "application/json, text/javascript"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: "responseXML",\n        text: "responseText",\n        json: "responseJSON"\n      },\n      converters: {\n        "* text": String,\n        "text html": !0,\n        "text json": n.parseJSON,\n        "text xml": n.parseXML\n      },\n      flatOptions: {\n        url: !0,\n        context: !0\n      }\n    },\n    ajaxSetup: function ajaxSetup(a, b) {\n      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a);\n    },\n    ajaxPrefilter: wb(sb),\n    ajaxTransport: wb(tb),\n    ajax: function ajax(b, c) {\n      "object" == _typeof(b) && (c = b, b = void 0), c = c || {};\n      var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks("once memory"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = "canceled",\n          x = {\n        readyState: 0,\n        getResponseHeader: function getResponseHeader(a) {\n          var b;\n\n          if (2 === v) {\n            if (!h) {\n              h = {};\n\n              while (b = ob.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }\n\n            b = h[a.toLowerCase()];\n          }\n\n          return null == b ? null : b;\n        },\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        },\n        setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();\n          return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        },\n        overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        },\n        statusCode: function statusCode(a) {\n          var b;\n          if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);\n          return this;\n        },\n        abort: function abort(a) {\n          var b = a || w;\n          return e && e.abort(b), z(0, b), this;\n        }\n      };\n\n      if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + "").replace(mb, "").replace(rb, jb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || "*").toLowerCase().match(G) || [""], null == m.crossDomain) {\n        j = d.createElement("a");\n\n        try {\n          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + "//" + vb.host != j.protocol + "//" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }\n\n      if (m.data && m.processData && "string" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;\n      k = n.event && m.global, k && 0 === n.active++ && n.event.trigger("ajaxStart"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? "&" : "?") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, "$1_=" + kb++) : f + (lb.test(f) ? "&" : "?") + "_=" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader("If-Modified-Since", n.lastModified[f]), n.etag[f] && x.setRequestHeader("If-None-Match", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader("Content-Type", m.contentType), x.setRequestHeader("Accept", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + ("*" !== m.dataTypes[0] ? ", " + ub + "; q=0.01" : "") : m.accepts["*"]);\n\n      for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }\n\n      if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();\n      w = "abort";\n\n      for (l in {\n        success: 1,\n        error: 1,\n        complete: 1\n      }) {\n        x[l](m[l]);\n      }\n\n      if (e = xb(tb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger("ajaxSend", [x, m]), 2 === v) return x;\n        m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort("timeout");\n        }, m.timeout));\n\n        try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;\n          z(-1, y);\n        }\n      } else z(-1, "No Transport");\n\n      function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;\n        2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader("Last-Modified"), w && (n.lastModified[f] = w), w = x.getResponseHeader("etag"), w && (n.etag[f] = w)), 204 === b || "HEAD" === m.type ? y = "nocontent" : 304 === b ? y = "notmodified" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = "error", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + "", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? "ajaxSuccess" : "ajaxError", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger("ajaxComplete", [x, m]), --n.active || n.event.trigger("ajaxStop")));\n      }\n\n      return x;\n    },\n    getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, "json");\n    },\n    getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, "script");\n    }\n  }), n.each(["get", "post"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({\n        url: a,\n        type: b,\n        dataType: e,\n        data: c,\n        success: d\n      }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({\n      url: a,\n      type: "GET",\n      dataType: "script",\n      async: !1,\n      global: !1,\n      "throws": !0\n    });\n  }, n.fn.extend({\n    wrapAll: function wrapAll(a) {\n      var b;\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;\n\n        while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }\n\n        return a;\n      }).append(this)), this);\n    },\n    wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();\n        c.length ? c.wrapAll(a) : b.append(a);\n      });\n    },\n    wrap: function wrap(a) {\n      var b = n.isFunction(a);\n      return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    },\n    unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes);\n      }).end();\n    }\n  }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };\n  var Bb = /%20/g,\n      Cb = /\\[\\]$/,\n      Db = /\\r?\\n/g,\n      Eb = /^(?:submit|button|image|reset|file)$/i,\n      Fb = /^(?:input|select|textarea|keygen)/i;\n\n  function Gb(a, b, c, d) {\n    var e;\n    if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Cb.test(a) ? d(a, e) : Gb(a + "[" + ("object" == _typeof(e) && null != e ? b : "") + "]", e, c, d);\n    });else if (c || "object" !== n.type(b)) d(a, b);else for (e in b) {\n      Gb(a + "[" + e + "]", b[e], c, d);\n    }\n  }\n\n  n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);\n    };\n\n    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Gb(c, a[c], b, e);\n    }\n    return d.join("&").replace(Bb, "+");\n  }, n.fn.extend({\n    serialize: function serialize() {\n      return n.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, "elements");\n        return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;\n        return this.name && !n(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();\n        return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return {\n            name: b.name,\n            value: a.replace(Db, "\\r\\n")\n          };\n        }) : {\n          name: b.name,\n          value: c.replace(Db, "\\r\\n")\n        };\n      }).get();\n    }\n  }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };\n  var Hb = {\n    0: 200,\n    1223: 204\n  },\n      Ib = n.ajaxSettings.xhr();\n  l.cors = !!Ib && "withCredentials" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) {\n    var _c, d;\n\n    return l.cors || Ib && !b.crossDomain ? {\n      send: function send(e, f) {\n        var g,\n            h = b.xhr();\n        if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }\n        b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");\n\n        for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }\n\n        _c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {\n              binary: h.response\n            } : {\n              text: h.responseText\n            }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c("abort");\n\n        try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      },\n      abort: function abort() {\n        _c && _c();\n      }\n    } : void 0;\n  }), n.ajaxSetup({\n    accepts: {\n      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      "text script": function textScript(a) {\n        return n.globalEval(a), a;\n      }\n    }\n  }), n.ajaxPrefilter("script", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET");\n  }), n.ajaxTransport("script", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;\n\n      return {\n        send: function send(e, f) {\n          b = n("<script>").prop({\n            charset: a.scriptCharset,\n            src: a.url\n          }).on("load error", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f("error" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        },\n        abort: function abort() {\n          _c2 && _c2();\n        }\n      };\n    }\n  });\n  var Jb = [],\n      Kb = /(=)\\?(?=&|$)|\\?\\?/;\n  n.ajaxSetup({\n    jsonp: "callback",\n    jsonpCallback: function jsonpCallback() {\n      var a = Jb.pop() || n.expando + "_" + kb++;\n      return this[a] = !0, a;\n    }\n  }), n.ajaxPrefilter("json jsonp", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Kb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Kb.test(b.data) && "data");\n    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, "$1" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () {\n      return g || n.error(e + " was not called"), g[0];\n    }, b.dataTypes[0] = "json", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), "script") : void 0;\n  }), n.parseHTML = function (a, b, c) {\n    if (!a || "string" != typeof a) return null;\n    "boolean" == typeof b && (c = b, b = !1), b = b || d;\n    var e = x.exec(a),\n        f = !c && [];\n    return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };\n  var Lb = n.fn.load;\n  n.fn.load = function (a, b, c) {\n    if ("string" != typeof a && Lb) return Lb.apply(this, arguments);\n    var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(" ");\n    return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == _typeof(b) && (e = "POST"), g.length > 0 && n.ajax({\n      url: a,\n      type: e || "GET",\n      dataType: "html",\n      data: b\n    }).done(function (a) {\n      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(this, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };\n\n  function Mb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }\n\n  n.offset = {\n    setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, "position"),\n          l = n(a),\n          m = {};\n      "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m);\n    }\n  }, n.fn.extend({\n    offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });\n      var b,\n          c,\n          d = this[0],\n          e = {\n        top: 0,\n        left: 0\n      },\n          f = d && d.ownerDocument;\n      if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), {\n        top: e.top + c.pageYOffset - b.clientTop,\n        left: e.left + c.pageXOffset - b.clientLeft\n      }) : e;\n    },\n    position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = {\n          top: 0,\n          left: 0\n        };\n        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {\n          top: b.top - d.top - n.css(c, "marginTop", !0),\n          left: b.left - d.left - n.css(c, "marginLeft", !0)\n        };\n      }\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;\n\n        while (a && "static" === n.css(a, "position")) {\n          a = a.offsetParent;\n        }\n\n        return a || Ea;\n      });\n    }\n  }), n.each({\n    scrollLeft: "pageXOffset",\n    scrollTop: "pageYOffset"\n  }, function (a, b) {\n    var c = "pageYOffset" === b;\n\n    n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Mb(a);\n        return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each(["top", "left"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + "px" : c) : void 0;\n    });\n  }), n.each({\n    Height: "height",\n    Width: "width"\n  }, function (a, b) {\n    n.each({\n      padding: "inner" + a,\n      content: b,\n      "": "outer" + a\n    }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || "boolean" != typeof d),\n            g = c || (d === !0 || e === !0 ? "margin" : "border");\n        return K(this, function (b, c, d) {\n          var e;\n          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({\n    bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    },\n    unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    },\n    delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    },\n    undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);\n    },\n    size: function size() {\n      return this.length;\n    }\n  }), n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {\n    return n;\n  });\n  var Nb = a.jQuery,\n      Ob = a.$;\n  return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});'},2305:function(n,e,t){t(1226)(t(2306))},2306:function(n,e){n.exports='function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n!function (t, e, i) {\n  var n = t.L,\n      o = {};\n  o.version = "0.7.7", "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && "object" == _typeof(module.exports) ? module.exports = o : "function" == typeof define && define.amd && define(o), o.noConflict = function () {\n    return t.L = n, this;\n  }, t.L = o, o.Util = {\n    extend: function extend(t) {\n      var e,\n          i,\n          n,\n          o,\n          s = Array.prototype.slice.call(arguments, 1);\n\n      for (i = 0, n = s.length; n > i; i++) {\n        o = s[i] || {};\n\n        for (e in o) {\n          o.hasOwnProperty(e) && (t[e] = o[e]);\n        }\n      }\n\n      return t;\n    },\n    bind: function bind(t, e) {\n      var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\n      return function () {\n        return t.apply(e, i || arguments);\n      };\n    },\n    stamp: function () {\n      var t = 0,\n          e = "_leaflet_id";\n      return function (i) {\n        return i[e] = i[e] || ++t, i[e];\n      };\n    }(),\n    invokeEach: function invokeEach(t, e, i) {\n      var n, o;\n\n      if ("object" == _typeof(t)) {\n        o = Array.prototype.slice.call(arguments, 3);\n\n        for (n in t) {\n          e.apply(i, [n, t[n]].concat(o));\n        }\n\n        return !0;\n      }\n\n      return !1;\n    },\n    limitExecByInterval: function limitExecByInterval(t, e, i) {\n      var n, o;\n      return function s() {\n        var a = arguments;\n        return n ? void (o = !0) : (n = !0, setTimeout(function () {\n          n = !1, o && (s.apply(i, a), o = !1);\n        }, e), void t.apply(i, a));\n      };\n    },\n    falseFn: function falseFn() {\n      return !1;\n    },\n    formatNum: function formatNum(t, e) {\n      var i = Math.pow(10, e || 5);\n      return Math.round(t * i) / i;\n    },\n    trim: function trim(t) {\n      return t.trim ? t.trim() : t.replace(/^\\s+|\\s+$/g, "");\n    },\n    splitWords: function splitWords(t) {\n      return o.Util.trim(t).split(/\\s+/);\n    },\n    setOptions: function setOptions(t, e) {\n      return t.options = o.extend({}, t.options, e), t.options;\n    },\n    getParamString: function getParamString(t, e, i) {\n      var n = [];\n\n      for (var o in t) {\n        n.push(encodeURIComponent(i ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));\n      }\n\n      return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&");\n    },\n    template: function template(t, e) {\n      return t.replace(/\\{ *([\\w_]+) *\\}/g, function (t, n) {\n        var o = e[n];\n        if (o === i) throw new Error("No value provided for variable " + t);\n        return "function" == typeof o && (o = o(e)), o;\n      });\n    },\n    isArray: Array.isArray || function (t) {\n      return "[object Array]" === Object.prototype.toString.call(t);\n    },\n    emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="\n  }, function () {\n    function e(e) {\n      var i,\n          n,\n          o = ["webkit", "moz", "o", "ms"];\n\n      for (i = 0; i < o.length && !n; i++) {\n        n = t[o[i] + e];\n      }\n\n      return n;\n    }\n\n    function i(e) {\n      var i = +new Date(),\n          o = Math.max(0, 16 - (i - n));\n      return n = i + o, t.setTimeout(e, o);\n    }\n\n    var n = 0,\n        s = t.requestAnimationFrame || e("RequestAnimationFrame") || i,\n        a = t.cancelAnimationFrame || e("CancelAnimationFrame") || e("CancelRequestAnimationFrame") || function (e) {\n      t.clearTimeout(e);\n    };\n\n    o.Util.requestAnimFrame = function (e, n, a, r) {\n      return e = o.bind(e, n), a && s === i ? void e() : s.call(t, e, r);\n    }, o.Util.cancelAnimFrame = function (e) {\n      e && a.call(t, e);\n    };\n  }(), o.extend = o.Util.extend, o.bind = o.Util.bind, o.stamp = o.Util.stamp, o.setOptions = o.Util.setOptions, o.Class = function () {}, o.Class.extend = function (t) {\n    var e = function e() {\n      this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks();\n    },\n        i = function i() {};\n\n    i.prototype = this.prototype;\n    var n = new i();\n    n.constructor = e, e.prototype = n;\n\n    for (var s in this) {\n      this.hasOwnProperty(s) && "prototype" !== s && (e[s] = this[s]);\n    }\n\n    t.statics && (o.extend(e, t.statics), delete t.statics), t.includes && (o.Util.extend.apply(null, [n].concat(t.includes)), delete t.includes), t.options && n.options && (t.options = o.extend({}, n.options, t.options)), o.extend(n, t), n._initHooks = [];\n    var a = this;\n    return e.__super__ = a.prototype, n.callInitHooks = function () {\n      if (!this._initHooksCalled) {\n        a.prototype.callInitHooks && a.prototype.callInitHooks.call(this), this._initHooksCalled = !0;\n\n        for (var t = 0, e = n._initHooks.length; e > t; t++) {\n          n._initHooks[t].call(this);\n        }\n      }\n    }, e;\n  }, o.Class.include = function (t) {\n    o.extend(this.prototype, t);\n  }, o.Class.mergeOptions = function (t) {\n    o.extend(this.prototype.options, t);\n  }, o.Class.addInitHook = function (t) {\n    var e = Array.prototype.slice.call(arguments, 1),\n        i = "function" == typeof t ? t : function () {\n      this[t].apply(this, e);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i);\n  };\n  var s = "_leaflet_events";\n  o.Mixin = {}, o.Mixin.Events = {\n    addEventListener: function addEventListener(t, e, i) {\n      if (o.Util.invokeEach(t, this.addEventListener, this, e, i)) return this;\n      var n,\n          a,\n          r,\n          h,\n          l,\n          u,\n          c,\n          d = this[s] = this[s] || {},\n          p = i && i !== this && o.stamp(i);\n\n      for (t = o.Util.splitWords(t), n = 0, a = t.length; a > n; n++) {\n        r = {\n          action: e,\n          context: i || this\n        }, h = t[n], p ? (l = h + "_idx", u = l + "_len", c = d[l] = d[l] || {}, c[p] || (c[p] = [], d[u] = (d[u] || 0) + 1), c[p].push(r)) : (d[h] = d[h] || [], d[h].push(r));\n      }\n\n      return this;\n    },\n    hasEventListeners: function hasEventListeners(t) {\n      var e = this[s];\n      return !!e && (t in e && e[t].length > 0 || t + "_idx" in e && e[t + "_idx_len"] > 0);\n    },\n    removeEventListener: function removeEventListener(t, e, i) {\n      if (!this[s]) return this;\n      if (!t) return this.clearAllEventListeners();\n      if (o.Util.invokeEach(t, this.removeEventListener, this, e, i)) return this;\n      var n,\n          a,\n          r,\n          h,\n          l,\n          u,\n          c,\n          d,\n          p,\n          _ = this[s],\n          m = i && i !== this && o.stamp(i);\n\n      for (t = o.Util.splitWords(t), n = 0, a = t.length; a > n; n++) {\n        if (r = t[n], u = r + "_idx", c = u + "_len", d = _[u], e) {\n          if (h = m && d ? d[m] : _[r]) {\n            for (l = h.length - 1; l >= 0; l--) {\n              h[l].action !== e || i && h[l].context !== i || (p = h.splice(l, 1), p[0].action = o.Util.falseFn);\n            }\n\n            i && d && 0 === h.length && (delete d[m], _[c]--);\n          }\n        } else delete _[r], delete _[u], delete _[c];\n      }\n\n      return this;\n    },\n    clearAllEventListeners: function clearAllEventListeners() {\n      return delete this[s], this;\n    },\n    fireEvent: function fireEvent(t, e) {\n      if (!this.hasEventListeners(t)) return this;\n      var i,\n          n,\n          a,\n          r,\n          h,\n          l = o.Util.extend({}, e, {\n        type: t,\n        target: this\n      }),\n          u = this[s];\n      if (u[t]) for (i = u[t].slice(), n = 0, a = i.length; a > n; n++) {\n        i[n].action.call(i[n].context, l);\n      }\n      r = u[t + "_idx"];\n\n      for (h in r) {\n        if (i = r[h].slice()) for (n = 0, a = i.length; a > n; n++) {\n          i[n].action.call(i[n].context, l);\n        }\n      }\n\n      return this;\n    },\n    addOneTimeEventListener: function addOneTimeEventListener(t, e, i) {\n      if (o.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i)) return this;\n      var n = o.bind(function () {\n        this.removeEventListener(t, e, i).removeEventListener(t, n, i);\n      }, this);\n      return this.addEventListener(t, e, i).addEventListener(t, n, i);\n    }\n  }, o.Mixin.Events.on = o.Mixin.Events.addEventListener, o.Mixin.Events.off = o.Mixin.Events.removeEventListener, o.Mixin.Events.once = o.Mixin.Events.addOneTimeEventListener, o.Mixin.Events.fire = o.Mixin.Events.fireEvent, function () {\n    var n = "ActiveXObject" in t,\n        s = n && !e.addEventListener,\n        a = navigator.userAgent.toLowerCase(),\n        r = -1 !== a.indexOf("webkit"),\n        h = -1 !== a.indexOf("chrome"),\n        l = -1 !== a.indexOf("phantom"),\n        u = -1 !== a.indexOf("android"),\n        c = -1 !== a.search("android [23]"),\n        d = -1 !== a.indexOf("gecko"),\n        p = (typeof orientation === "undefined" ? "undefined" : _typeof(orientation)) != i + "",\n        _ = !t.PointerEvent && t.MSPointerEvent,\n        m = t.PointerEvent && t.navigator.pointerEnabled || _,\n        f = "devicePixelRatio" in t && t.devicePixelRatio > 1 || "matchMedia" in t && t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches,\n        g = e.documentElement,\n        v = n && "transition" in g.style,\n        y = "WebKitCSSMatrix" in t && "m11" in new t.WebKitCSSMatrix() && !c,\n        P = "MozPerspective" in g.style,\n        L = "OTransition" in g.style,\n        x = !t.L_DISABLE_3D && (v || y || P || L) && !l,\n        w = !t.L_NO_TOUCH && !l && (m || "ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch);\n\n    o.Browser = {\n      ie: n,\n      ielt9: s,\n      webkit: r,\n      gecko: d && !r && !t.opera && !n,\n      android: u,\n      android23: c,\n      chrome: h,\n      ie3d: v,\n      webkit3d: y,\n      gecko3d: P,\n      opera3d: L,\n      any3d: x,\n      mobile: p,\n      mobileWebkit: p && r,\n      mobileWebkit3d: p && y,\n      mobileOpera: p && t.opera,\n      touch: w,\n      msPointer: _,\n      pointer: m,\n      retina: f\n    };\n  }(), o.Point = function (t, e, i) {\n    this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e;\n  }, o.Point.prototype = {\n    clone: function clone() {\n      return new o.Point(this.x, this.y);\n    },\n    add: function add(t) {\n      return this.clone()._add(o.point(t));\n    },\n    _add: function _add(t) {\n      return this.x += t.x, this.y += t.y, this;\n    },\n    subtract: function subtract(t) {\n      return this.clone()._subtract(o.point(t));\n    },\n    _subtract: function _subtract(t) {\n      return this.x -= t.x, this.y -= t.y, this;\n    },\n    divideBy: function divideBy(t) {\n      return this.clone()._divideBy(t);\n    },\n    _divideBy: function _divideBy(t) {\n      return this.x /= t, this.y /= t, this;\n    },\n    multiplyBy: function multiplyBy(t) {\n      return this.clone()._multiplyBy(t);\n    },\n    _multiplyBy: function _multiplyBy(t) {\n      return this.x *= t, this.y *= t, this;\n    },\n    round: function round() {\n      return this.clone()._round();\n    },\n    _round: function _round() {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n    },\n    floor: function floor() {\n      return this.clone()._floor();\n    },\n    _floor: function _floor() {\n      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;\n    },\n    distanceTo: function distanceTo(t) {\n      t = o.point(t);\n      var e = t.x - this.x,\n          i = t.y - this.y;\n      return Math.sqrt(e * e + i * i);\n    },\n    equals: function equals(t) {\n      return t = o.point(t), t.x === this.x && t.y === this.y;\n    },\n    contains: function contains(t) {\n      return t = o.point(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y);\n    },\n    toString: function toString() {\n      return "Point(" + o.Util.formatNum(this.x) + ", " + o.Util.formatNum(this.y) + ")";\n    }\n  }, o.point = function (t, e, n) {\n    return t instanceof o.Point ? t : o.Util.isArray(t) ? new o.Point(t[0], t[1]) : t === i || null === t ? t : new o.Point(t, e, n);\n  }, o.Bounds = function (t, e) {\n    if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++) {\n      this.extend(i[n]);\n    }\n  }, o.Bounds.prototype = {\n    extend: function extend(t) {\n      return t = o.point(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this;\n    },\n    getCenter: function getCenter(t) {\n      return new o.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t);\n    },\n    getBottomLeft: function getBottomLeft() {\n      return new o.Point(this.min.x, this.max.y);\n    },\n    getTopRight: function getTopRight() {\n      return new o.Point(this.max.x, this.min.y);\n    },\n    getSize: function getSize() {\n      return this.max.subtract(this.min);\n    },\n    contains: function contains(t) {\n      var e, i;\n      return t = "number" == typeof t[0] || t instanceof o.Point ? o.point(t) : o.bounds(t), t instanceof o.Bounds ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y;\n    },\n    intersects: function intersects(t) {\n      t = o.bounds(t);\n      var e = this.min,\n          i = this.max,\n          n = t.min,\n          s = t.max,\n          a = s.x >= e.x && n.x <= i.x,\n          r = s.y >= e.y && n.y <= i.y;\n      return a && r;\n    },\n    isValid: function isValid() {\n      return !(!this.min || !this.max);\n    }\n  }, o.bounds = function (t, e) {\n    return !t || t instanceof o.Bounds ? t : new o.Bounds(t, e);\n  }, o.Transformation = function (t, e, i, n) {\n    this._a = t, this._b = e, this._c = i, this._d = n;\n  }, o.Transformation.prototype = {\n    transform: function transform(t, e) {\n      return this._transform(t.clone(), e);\n    },\n    _transform: function _transform(t, e) {\n      return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t;\n    },\n    untransform: function untransform(t, e) {\n      return e = e || 1, new o.Point((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c);\n    }\n  }, o.DomUtil = {\n    get: function get(t) {\n      return "string" == typeof t ? e.getElementById(t) : t;\n    },\n    getStyle: function getStyle(t, i) {\n      var n = t.style[i];\n\n      if (!n && t.currentStyle && (n = t.currentStyle[i]), (!n || "auto" === n) && e.defaultView) {\n        var o = e.defaultView.getComputedStyle(t, null);\n        n = o ? o[i] : null;\n      }\n\n      return "auto" === n ? null : n;\n    },\n    getViewportOffset: function getViewportOffset(t) {\n      var i,\n          n = 0,\n          s = 0,\n          a = t,\n          r = e.body,\n          h = e.documentElement;\n\n      do {\n        if (n += a.offsetTop || 0, s += a.offsetLeft || 0, n += parseInt(o.DomUtil.getStyle(a, "borderTopWidth"), 10) || 0, s += parseInt(o.DomUtil.getStyle(a, "borderLeftWidth"), 10) || 0, i = o.DomUtil.getStyle(a, "position"), a.offsetParent === r && "absolute" === i) break;\n\n        if ("fixed" === i) {\n          n += r.scrollTop || h.scrollTop || 0, s += r.scrollLeft || h.scrollLeft || 0;\n          break;\n        }\n\n        if ("relative" === i && !a.offsetLeft) {\n          var l = o.DomUtil.getStyle(a, "width"),\n              u = o.DomUtil.getStyle(a, "max-width"),\n              c = a.getBoundingClientRect();\n          ("none" !== l || "none" !== u) && (s += c.left + a.clientLeft), n += c.top + (r.scrollTop || h.scrollTop || 0);\n          break;\n        }\n\n        a = a.offsetParent;\n      } while (a);\n\n      a = t;\n\n      do {\n        if (a === r) break;\n        n -= a.scrollTop || 0, s -= a.scrollLeft || 0, a = a.parentNode;\n      } while (a);\n\n      return new o.Point(s, n);\n    },\n    documentIsLtr: function documentIsLtr() {\n      return o.DomUtil._docIsLtrCached || (o.DomUtil._docIsLtrCached = !0, o.DomUtil._docIsLtr = "ltr" === o.DomUtil.getStyle(e.body, "direction")), o.DomUtil._docIsLtr;\n    },\n    create: function create(t, i, n) {\n      var o = e.createElement(t);\n      return o.className = i, n && n.appendChild(o), o;\n    },\n    hasClass: function hasClass(t, e) {\n      if (t.classList !== i) return t.classList.contains(e);\n\n      var n = o.DomUtil._getClass(t);\n\n      return n.length > 0 && new RegExp("(^|\\\\s)" + e + "(\\\\s|$)").test(n);\n    },\n    addClass: function addClass(t, e) {\n      if (t.classList !== i) for (var n = o.Util.splitWords(e), s = 0, a = n.length; a > s; s++) {\n        t.classList.add(n[s]);\n      } else if (!o.DomUtil.hasClass(t, e)) {\n        var r = o.DomUtil._getClass(t);\n\n        o.DomUtil._setClass(t, (r ? r + " " : "") + e);\n      }\n    },\n    removeClass: function removeClass(t, e) {\n      t.classList !== i ? t.classList.remove(e) : o.DomUtil._setClass(t, o.Util.trim((" " + o.DomUtil._getClass(t) + " ").replace(" " + e + " ", " ")));\n    },\n    _setClass: function _setClass(t, e) {\n      t.className.baseVal === i ? t.className = e : t.className.baseVal = e;\n    },\n    _getClass: function _getClass(t) {\n      return t.className.baseVal === i ? t.className : t.className.baseVal;\n    },\n    setOpacity: function setOpacity(t, e) {\n      if ("opacity" in t.style) t.style.opacity = e;else if ("filter" in t.style) {\n        var i = !1,\n            n = "DXImageTransform.Microsoft.Alpha";\n\n        try {\n          i = t.filters.item(n);\n        } catch (o) {\n          if (1 === e) return;\n        }\n\n        e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")";\n      }\n    },\n    testProp: function testProp(t) {\n      for (var i = e.documentElement.style, n = 0; n < t.length; n++) {\n        if (t[n] in i) return t[n];\n      }\n\n      return !1;\n    },\n    getTranslateString: function getTranslateString(t) {\n      var e = o.Browser.webkit3d,\n          i = "translate" + (e ? "3d" : "") + "(",\n          n = (e ? ",0" : "") + ")";\n      return i + t.x + "px," + t.y + "px" + n;\n    },\n    getScaleString: function getScaleString(t, e) {\n      var i = o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t))),\n          n = " scale(" + t + ") ";\n      return i + n;\n    },\n    setPosition: function setPosition(t, e, i) {\n      t._leaflet_pos = e, !i && o.Browser.any3d ? t.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(e) : (t.style.left = e.x + "px", t.style.top = e.y + "px");\n    },\n    getPosition: function getPosition(t) {\n      return t._leaflet_pos;\n    }\n  }, o.DomUtil.TRANSFORM = o.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), o.DomUtil.TRANSITION = o.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), o.DomUtil.TRANSITION_END = "webkitTransition" === o.DomUtil.TRANSITION || "OTransition" === o.DomUtil.TRANSITION ? o.DomUtil.TRANSITION + "End" : "transitionend", function () {\n    if ("onselectstart" in e) o.extend(o.DomUtil, {\n      disableTextSelection: function disableTextSelection() {\n        o.DomEvent.on(t, "selectstart", o.DomEvent.preventDefault);\n      },\n      enableTextSelection: function enableTextSelection() {\n        o.DomEvent.off(t, "selectstart", o.DomEvent.preventDefault);\n      }\n    });else {\n      var i = o.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);\n      o.extend(o.DomUtil, {\n        disableTextSelection: function disableTextSelection() {\n          if (i) {\n            var t = e.documentElement.style;\n            this._userSelect = t[i], t[i] = "none";\n          }\n        },\n        enableTextSelection: function enableTextSelection() {\n          i && (e.documentElement.style[i] = this._userSelect, delete this._userSelect);\n        }\n      });\n    }\n    o.extend(o.DomUtil, {\n      disableImageDrag: function disableImageDrag() {\n        o.DomEvent.on(t, "dragstart", o.DomEvent.preventDefault);\n      },\n      enableImageDrag: function enableImageDrag() {\n        o.DomEvent.off(t, "dragstart", o.DomEvent.preventDefault);\n      }\n    });\n  }(), o.LatLng = function (t, e, n) {\n    if (t = parseFloat(t), e = parseFloat(e), isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");\n    this.lat = t, this.lng = e, n !== i && (this.alt = parseFloat(n));\n  }, o.extend(o.LatLng, {\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n    MAX_MARGIN: 1e-9\n  }), o.LatLng.prototype = {\n    equals: function equals(t) {\n      if (!t) return !1;\n      t = o.latLng(t);\n      var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));\n      return e <= o.LatLng.MAX_MARGIN;\n    },\n    toString: function toString(t) {\n      return "LatLng(" + o.Util.formatNum(this.lat, t) + ", " + o.Util.formatNum(this.lng, t) + ")";\n    },\n    distanceTo: function distanceTo(t) {\n      t = o.latLng(t);\n      var e = 6378137,\n          i = o.LatLng.DEG_TO_RAD,\n          n = (t.lat - this.lat) * i,\n          s = (t.lng - this.lng) * i,\n          a = this.lat * i,\n          r = t.lat * i,\n          h = Math.sin(n / 2),\n          l = Math.sin(s / 2),\n          u = h * h + l * l * Math.cos(a) * Math.cos(r);\n      return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u));\n    },\n    wrap: function wrap(t, e) {\n      var i = this.lng;\n      return t = t || -180, e = e || 180, i = (i + e) % (e - t) + (t > i || i === e ? e : t), new o.LatLng(this.lat, i);\n    }\n  }, o.latLng = function (t, e) {\n    return t instanceof o.LatLng ? t : o.Util.isArray(t) ? "number" == typeof t[0] || "string" == typeof t[0] ? new o.LatLng(t[0], t[1], t[2]) : null : t === i || null === t ? t : "object" == _typeof(t) && "lat" in t ? new o.LatLng(t.lat, "lng" in t ? t.lng : t.lon) : e === i ? null : new o.LatLng(t, e);\n  }, o.LatLngBounds = function (t, e) {\n    if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++) {\n      this.extend(i[n]);\n    }\n  }, o.LatLngBounds.prototype = {\n    extend: function extend(t) {\n      if (!t) return this;\n      var e = o.latLng(t);\n      return t = null !== e ? e : o.latLngBounds(t), t instanceof o.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat), this._southWest.lng = Math.min(t.lng, this._southWest.lng), this._northEast.lat = Math.max(t.lat, this._northEast.lat), this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new o.LatLng(t.lat, t.lng), this._northEast = new o.LatLng(t.lat, t.lng)) : t instanceof o.LatLngBounds && (this.extend(t._southWest), this.extend(t._northEast)), this;\n    },\n    pad: function pad(t) {\n      var e = this._southWest,\n          i = this._northEast,\n          n = Math.abs(e.lat - i.lat) * t,\n          s = Math.abs(e.lng - i.lng) * t;\n      return new o.LatLngBounds(new o.LatLng(e.lat - n, e.lng - s), new o.LatLng(i.lat + n, i.lng + s));\n    },\n    getCenter: function getCenter() {\n      return new o.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    getSouthWest: function getSouthWest() {\n      return this._southWest;\n    },\n    getNorthEast: function getNorthEast() {\n      return this._northEast;\n    },\n    getNorthWest: function getNorthWest() {\n      return new o.LatLng(this.getNorth(), this.getWest());\n    },\n    getSouthEast: function getSouthEast() {\n      return new o.LatLng(this.getSouth(), this.getEast());\n    },\n    getWest: function getWest() {\n      return this._southWest.lng;\n    },\n    getSouth: function getSouth() {\n      return this._southWest.lat;\n    },\n    getEast: function getEast() {\n      return this._northEast.lng;\n    },\n    getNorth: function getNorth() {\n      return this._northEast.lat;\n    },\n    contains: function contains(t) {\n      t = "number" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t);\n      var e,\n          i,\n          n = this._southWest,\n          s = this._northEast;\n      return t instanceof o.LatLngBounds ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= s.lat && e.lng >= n.lng && i.lng <= s.lng;\n    },\n    intersects: function intersects(t) {\n      t = o.latLngBounds(t);\n      var e = this._southWest,\n          i = this._northEast,\n          n = t.getSouthWest(),\n          s = t.getNorthEast(),\n          a = s.lat >= e.lat && n.lat <= i.lat,\n          r = s.lng >= e.lng && n.lng <= i.lng;\n      return a && r;\n    },\n    toBBoxString: function toBBoxString() {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");\n    },\n    equals: function equals(t) {\n      return t ? (t = o.latLngBounds(t), this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1;\n    },\n    isValid: function isValid() {\n      return !(!this._southWest || !this._northEast);\n    }\n  }, o.latLngBounds = function (t, e) {\n    return !t || t instanceof o.LatLngBounds ? t : new o.LatLngBounds(t, e);\n  }, o.Projection = {}, o.Projection.SphericalMercator = {\n    MAX_LATITUDE: 85.0511287798,\n    project: function project(t) {\n      var e = o.LatLng.DEG_TO_RAD,\n          i = this.MAX_LATITUDE,\n          n = Math.max(Math.min(i, t.lat), -i),\n          s = t.lng * e,\n          a = n * e;\n      return a = Math.log(Math.tan(Math.PI / 4 + a / 2)), new o.Point(s, a);\n    },\n    unproject: function unproject(t) {\n      var e = o.LatLng.RAD_TO_DEG,\n          i = t.x * e,\n          n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;\n      return new o.LatLng(n, i);\n    }\n  }, o.Projection.LonLat = {\n    project: function project(t) {\n      return new o.Point(t.lng, t.lat);\n    },\n    unproject: function unproject(t) {\n      return new o.LatLng(t.y, t.x);\n    }\n  }, o.CRS = {\n    latLngToPoint: function latLngToPoint(t, e) {\n      var i = this.projection.project(t),\n          n = this.scale(e);\n      return this.transformation._transform(i, n);\n    },\n    pointToLatLng: function pointToLatLng(t, e) {\n      var i = this.scale(e),\n          n = this.transformation.untransform(t, i);\n      return this.projection.unproject(n);\n    },\n    project: function project(t) {\n      return this.projection.project(t);\n    },\n    scale: function scale(t) {\n      return 256 * Math.pow(2, t);\n    },\n    getSize: function getSize(t) {\n      var e = this.scale(t);\n      return o.point(e, e);\n    }\n  }, o.CRS.Simple = o.extend({}, o.CRS, {\n    projection: o.Projection.LonLat,\n    transformation: new o.Transformation(1, 0, -1, 0),\n    scale: function scale(t) {\n      return Math.pow(2, t);\n    }\n  }), o.CRS.EPSG3857 = o.extend({}, o.CRS, {\n    code: "EPSG:3857",\n    projection: o.Projection.SphericalMercator,\n    transformation: new o.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),\n    project: function project(t) {\n      var e = this.projection.project(t),\n          i = 6378137;\n      return e.multiplyBy(i);\n    }\n  }), o.CRS.EPSG900913 = o.extend({}, o.CRS.EPSG3857, {\n    code: "EPSG:900913"\n  }), o.CRS.EPSG4326 = o.extend({}, o.CRS, {\n    code: "EPSG:4326",\n    projection: o.Projection.LonLat,\n    transformation: new o.Transformation(1 / 360, .5, -1 / 360, .5)\n  }), o.Map = o.Class.extend({\n    includes: o.Mixin.Events,\n    options: {\n      crs: o.CRS.EPSG3857,\n      fadeAnimation: o.DomUtil.TRANSITION && !o.Browser.android23,\n      trackResize: !0,\n      markerZoomAnimation: o.DomUtil.TRANSITION && o.Browser.any3d\n    },\n    initialize: function initialize(t, e) {\n      e = o.setOptions(this, e), this._initContainer(t), this._initLayout(), this._onResize = o.bind(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.center && e.zoom !== i && this.setView(o.latLng(e.center), e.zoom, {\n        reset: !0\n      }), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0, this.callInitHooks(), this._addLayers(e.layers);\n    },\n    setView: function setView(t, e) {\n      return e = e === i ? this.getZoom() : e, this._resetView(o.latLng(t), this._limitZoom(e)), this;\n    },\n    setZoom: function setZoom(t, e) {\n      return this._loaded ? this.setView(this.getCenter(), t, {\n        zoom: e\n      }) : (this._zoom = this._limitZoom(t), this);\n    },\n    zoomIn: function zoomIn(t, e) {\n      return this.setZoom(this._zoom + (t || 1), e);\n    },\n    zoomOut: function zoomOut(t, e) {\n      return this.setZoom(this._zoom - (t || 1), e);\n    },\n    setZoomAround: function setZoomAround(t, e, i) {\n      var n = this.getZoomScale(e),\n          s = this.getSize().divideBy(2),\n          a = t instanceof o.Point ? t : this.latLngToContainerPoint(t),\n          r = a.subtract(s).multiplyBy(1 - 1 / n),\n          h = this.containerPointToLatLng(s.add(r));\n      return this.setView(h, e, {\n        zoom: i\n      });\n    },\n    fitBounds: function fitBounds(t, e) {\n      e = e || {}, t = t.getBounds ? t.getBounds() : o.latLngBounds(t);\n      var i = o.point(e.paddingTopLeft || e.padding || [0, 0]),\n          n = o.point(e.paddingBottomRight || e.padding || [0, 0]),\n          s = this.getBoundsZoom(t, !1, i.add(n));\n      s = e.maxZoom ? Math.min(e.maxZoom, s) : s;\n      var a = n.subtract(i).divideBy(2),\n          r = this.project(t.getSouthWest(), s),\n          h = this.project(t.getNorthEast(), s),\n          l = this.unproject(r.add(h).divideBy(2).add(a), s);\n      return this.setView(l, s, e);\n    },\n    fitWorld: function fitWorld(t) {\n      return this.fitBounds([[-90, -180], [90, 180]], t);\n    },\n    panTo: function panTo(t, e) {\n      return this.setView(t, this._zoom, {\n        pan: e\n      });\n    },\n    panBy: function panBy(t) {\n      return this.fire("movestart"), this._rawPanBy(o.point(t)), this.fire("move"), this.fire("moveend");\n    },\n    setMaxBounds: function setMaxBounds(t) {\n      return t = o.latLngBounds(t), this.options.maxBounds = t, t ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this);\n    },\n    panInsideBounds: function panInsideBounds(t, e) {\n      var i = this.getCenter(),\n          n = this._limitCenter(i, this._zoom, t);\n\n      return i.equals(n) ? this : this.panTo(n, e);\n    },\n    addLayer: function addLayer(t) {\n      var e = o.stamp(t);\n      return this._layers[e] ? this : (this._layers[e] = t, !t.options || isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t, this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, t.on("load", this._onTileLayerLoad, this)), this._loaded && this._layerAdd(t), this);\n    },\n    removeLayer: function removeLayer(t) {\n      var e = o.stamp(t);\n      return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && this.fire("layerremove", {\n        layer: t\n      }), this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, t.off("load", this._onTileLayerLoad, this)), this) : this;\n    },\n    hasLayer: function hasLayer(t) {\n      return t ? o.stamp(t) in this._layers : !1;\n    },\n    eachLayer: function eachLayer(t, e) {\n      for (var i in this._layers) {\n        t.call(e, this._layers[i]);\n      }\n\n      return this;\n    },\n    invalidateSize: function invalidateSize(t) {\n      if (!this._loaded) return this;\n      t = o.extend({\n        animate: !1,\n        pan: !0\n      }, t === !0 ? {\n        animate: !0\n      } : t);\n      var e = this.getSize();\n      this._sizeChanged = !0, this._initialCenter = null;\n      var i = this.getSize(),\n          n = e.divideBy(2).round(),\n          s = i.divideBy(2).round(),\n          a = n.subtract(s);\n      return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(o.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {\n        oldSize: e,\n        newSize: i\n      })) : this;\n    },\n    addHandler: function addHandler(t, e) {\n      if (!e) return this;\n      var i = this[t] = new e(this);\n      return this._handlers.push(i), this.options[t] && i.enable(), this;\n    },\n    remove: function remove() {\n      this._loaded && this.fire("unload"), this._initEvents("off");\n\n      try {\n        delete this._container._leaflet;\n      } catch (t) {\n        this._container._leaflet = i;\n      }\n\n      return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this;\n    },\n    getCenter: function getCenter() {\n      return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    getZoom: function getZoom() {\n      return this._zoom;\n    },\n    getBounds: function getBounds() {\n      var t = this.getPixelBounds(),\n          e = this.unproject(t.getBottomLeft()),\n          i = this.unproject(t.getTopRight());\n      return new o.LatLngBounds(e, i);\n    },\n    getMinZoom: function getMinZoom() {\n      return this.options.minZoom === i ? this._layersMinZoom === i ? 0 : this._layersMinZoom : this.options.minZoom;\n    },\n    getMaxZoom: function getMaxZoom() {\n      return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;\n    },\n    getBoundsZoom: function getBoundsZoom(t, e, i) {\n      t = o.latLngBounds(t);\n      var n,\n          s = this.getMinZoom() - (e ? 1 : 0),\n          a = this.getMaxZoom(),\n          r = this.getSize(),\n          h = t.getNorthWest(),\n          l = t.getSouthEast(),\n          u = !0;\n      i = o.point(i || [0, 0]);\n\n      do {\n        s++, n = this.project(l, s).subtract(this.project(h, s)).add(i), u = e ? n.x < r.x || n.y < r.y : r.contains(n);\n      } while (u && a >= s);\n\n      return u && e ? null : e ? s : s - 1;\n    },\n    getSize: function getSize() {\n      return (!this._size || this._sizeChanged) && (this._size = new o.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone();\n    },\n    getPixelBounds: function getPixelBounds() {\n      var t = this._getTopLeftPoint();\n\n      return new o.Bounds(t, t.add(this.getSize()));\n    },\n    getPixelOrigin: function getPixelOrigin() {\n      return this._checkIfLoaded(), this._initialTopLeftPoint;\n    },\n    getPanes: function getPanes() {\n      return this._panes;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    getZoomScale: function getZoomScale(t) {\n      var e = this.options.crs;\n      return e.scale(t) / e.scale(this._zoom);\n    },\n    getScaleZoom: function getScaleZoom(t) {\n      return this._zoom + Math.log(t) / Math.LN2;\n    },\n    project: function project(t, e) {\n      return e = e === i ? this._zoom : e, this.options.crs.latLngToPoint(o.latLng(t), e);\n    },\n    unproject: function unproject(t, e) {\n      return e = e === i ? this._zoom : e, this.options.crs.pointToLatLng(o.point(t), e);\n    },\n    layerPointToLatLng: function layerPointToLatLng(t) {\n      var e = o.point(t).add(this.getPixelOrigin());\n      return this.unproject(e);\n    },\n    latLngToLayerPoint: function latLngToLayerPoint(t) {\n      var e = this.project(o.latLng(t))._round();\n\n      return e._subtract(this.getPixelOrigin());\n    },\n    containerPointToLayerPoint: function containerPointToLayerPoint(t) {\n      return o.point(t).subtract(this._getMapPanePos());\n    },\n    layerPointToContainerPoint: function layerPointToContainerPoint(t) {\n      return o.point(t).add(this._getMapPanePos());\n    },\n    containerPointToLatLng: function containerPointToLatLng(t) {\n      var e = this.containerPointToLayerPoint(o.point(t));\n      return this.layerPointToLatLng(e);\n    },\n    latLngToContainerPoint: function latLngToContainerPoint(t) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)));\n    },\n    mouseEventToContainerPoint: function mouseEventToContainerPoint(t) {\n      return o.DomEvent.getMousePosition(t, this._container);\n    },\n    mouseEventToLayerPoint: function mouseEventToLayerPoint(t) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t));\n    },\n    mouseEventToLatLng: function mouseEventToLatLng(t) {\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(t));\n    },\n    _initContainer: function _initContainer(t) {\n      var e = this._container = o.DomUtil.get(t);\n      if (!e) throw new Error("Map container not found.");\n      if (e._leaflet) throw new Error("Map container is already initialized.");\n      e._leaflet = !0;\n    },\n    _initLayout: function _initLayout() {\n      var t = this._container;\n      o.DomUtil.addClass(t, "leaflet-container" + (o.Browser.touch ? " leaflet-touch" : "") + (o.Browser.retina ? " leaflet-retina" : "") + (o.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));\n      var e = o.DomUtil.getStyle(t, "position");\n      "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();\n    },\n    _initPanes: function _initPanes() {\n      var t = this._panes = {};\n      this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), t.shadowPane = this._createPane("leaflet-shadow-pane"), t.overlayPane = this._createPane("leaflet-overlay-pane"), t.markerPane = this._createPane("leaflet-marker-pane"), t.popupPane = this._createPane("leaflet-popup-pane");\n      var e = " leaflet-zoom-hide";\n      this.options.markerZoomAnimation || (o.DomUtil.addClass(t.markerPane, e), o.DomUtil.addClass(t.shadowPane, e), o.DomUtil.addClass(t.popupPane, e));\n    },\n    _createPane: function _createPane(t, e) {\n      return o.DomUtil.create("div", t, e || this._panes.objectsPane);\n    },\n    _clearPanes: function _clearPanes() {\n      this._container.removeChild(this._mapPane);\n    },\n    _addLayers: function _addLayers(t) {\n      t = t ? o.Util.isArray(t) ? t : [t] : [];\n\n      for (var e = 0, i = t.length; i > e; e++) {\n        this.addLayer(t[e]);\n      }\n    },\n    _resetView: function _resetView(t, e, i, n) {\n      var s = this._zoom !== e;\n      n || (this.fire("movestart"), s && this.fire("zoomstart")), this._zoom = e, this._initialCenter = t, this._initialTopLeftPoint = this._getNewTopLeftPoint(t), i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : o.DomUtil.setPosition(this._mapPane, new o.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;\n      var a = !this._loaded;\n      this._loaded = !0, this.fire("viewreset", {\n        hard: !i\n      }), a && (this.fire("load"), this.eachLayer(this._layerAdd, this)), this.fire("move"), (s || n) && this.fire("zoomend"), this.fire("moveend", {\n        hard: !i\n      });\n    },\n    _rawPanBy: function _rawPanBy(t) {\n      o.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t));\n    },\n    _getZoomSpan: function _getZoomSpan() {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _updateZoomLevels: function _updateZoomLevels() {\n      var t,\n          e = 1 / 0,\n          n = -(1 / 0),\n          o = this._getZoomSpan();\n\n      for (t in this._zoomBoundLayers) {\n        var s = this._zoomBoundLayers[t];\n        isNaN(s.options.minZoom) || (e = Math.min(e, s.options.minZoom)), isNaN(s.options.maxZoom) || (n = Math.max(n, s.options.maxZoom));\n      }\n\n      t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n, this._layersMinZoom = e), o !== this._getZoomSpan() && this.fire("zoomlevelschange");\n    },\n    _panInsideMaxBounds: function _panInsideMaxBounds() {\n      this.panInsideBounds(this.options.maxBounds);\n    },\n    _checkIfLoaded: function _checkIfLoaded() {\n      if (!this._loaded) throw new Error("Set map center and zoom first.");\n    },\n    _initEvents: function _initEvents(e) {\n      if (o.DomEvent) {\n        e = e || "on", o.DomEvent[e](this._container, "click", this._onMouseClick, this);\n        var i,\n            n,\n            s = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];\n\n        for (i = 0, n = s.length; n > i; i++) {\n          o.DomEvent[e](this._container, s[i], this._fireMouseEvent, this);\n        }\n\n        this.options.trackResize && o.DomEvent[e](t, "resize", this._onResize, this);\n      }\n    },\n    _onResize: function _onResize() {\n      o.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = o.Util.requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: !0\n        });\n      }, this, !1, this._container);\n    },\n    _onMouseClick: function _onMouseClick(t) {\n      !this._loaded || !t._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || o.DomEvent._skipped(t) || (this.fire("preclick"), this._fireMouseEvent(t));\n    },\n    _fireMouseEvent: function _fireMouseEvent(t) {\n      if (this._loaded && !o.DomEvent._skipped(t)) {\n        var e = t.type;\n\n        if (e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, this.hasEventListeners(e)) {\n          "contextmenu" === e && o.DomEvent.preventDefault(t);\n          var i = this.mouseEventToContainerPoint(t),\n              n = this.containerPointToLayerPoint(i),\n              s = this.layerPointToLatLng(n);\n          this.fire(e, {\n            latlng: s,\n            layerPoint: n,\n            containerPoint: i,\n            originalEvent: t\n          });\n        }\n      }\n    },\n    _onTileLayerLoad: function _onTileLayerLoad() {\n      this._tileLayersToLoad--, this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload");\n    },\n    _clearHandlers: function _clearHandlers() {\n      for (var t = 0, e = this._handlers.length; e > t; t++) {\n        this._handlers[t].disable();\n      }\n    },\n    whenReady: function whenReady(t, e) {\n      return this._loaded ? t.call(e || this, this) : this.on("load", t, e), this;\n    },\n    _layerAdd: function _layerAdd(t) {\n      t.onAdd(this), this.fire("layeradd", {\n        layer: t\n      });\n    },\n    _getMapPanePos: function _getMapPanePos() {\n      return o.DomUtil.getPosition(this._mapPane);\n    },\n    _moved: function _moved() {\n      var t = this._getMapPanePos();\n\n      return t && !t.equals([0, 0]);\n    },\n    _getTopLeftPoint: function _getTopLeftPoint() {\n      return this.getPixelOrigin().subtract(this._getMapPanePos());\n    },\n    _getNewTopLeftPoint: function _getNewTopLeftPoint(t, e) {\n      var i = this.getSize()._divideBy(2);\n\n      return this.project(t, e)._subtract(i)._round();\n    },\n    _latLngToNewLayerPoint: function _latLngToNewLayerPoint(t, e, i) {\n      var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());\n\n      return this.project(t, e)._subtract(n);\n    },\n    _getCenterLayerPoint: function _getCenterLayerPoint() {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    _getCenterOffset: function _getCenterOffset(t) {\n      return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint());\n    },\n    _limitCenter: function _limitCenter(t, e, i) {\n      if (!i) return t;\n\n      var n = this.project(t, e),\n          s = this.getSize().divideBy(2),\n          a = new o.Bounds(n.subtract(s), n.add(s)),\n          r = this._getBoundsOffset(a, i, e);\n\n      return this.unproject(n.add(r), e);\n    },\n    _limitOffset: function _limitOffset(t, e) {\n      if (!e) return t;\n      var i = this.getPixelBounds(),\n          n = new o.Bounds(i.min.add(t), i.max.add(t));\n      return t.add(this._getBoundsOffset(n, e));\n    },\n    _getBoundsOffset: function _getBoundsOffset(t, e, i) {\n      var n = this.project(e.getNorthWest(), i).subtract(t.min),\n          s = this.project(e.getSouthEast(), i).subtract(t.max),\n          a = this._rebound(n.x, -s.x),\n          r = this._rebound(n.y, -s.y);\n\n      return new o.Point(a, r);\n    },\n    _rebound: function _rebound(t, e) {\n      return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e));\n    },\n    _limitZoom: function _limitZoom(t) {\n      var e = this.getMinZoom(),\n          i = this.getMaxZoom();\n      return Math.max(e, Math.min(i, t));\n    }\n  }), o.map = function (t, e) {\n    return new o.Map(t, e);\n  }, o.Projection.Mercator = {\n    MAX_LATITUDE: 85.0840591556,\n    R_MINOR: 6356752.314245179,\n    R_MAJOR: 6378137,\n    project: function project(t) {\n      var e = o.LatLng.DEG_TO_RAD,\n          i = this.MAX_LATITUDE,\n          n = Math.max(Math.min(i, t.lat), -i),\n          s = this.R_MAJOR,\n          a = this.R_MINOR,\n          r = t.lng * e * s,\n          h = n * e,\n          l = a / s,\n          u = Math.sqrt(1 - l * l),\n          c = u * Math.sin(h);\n      c = Math.pow((1 - c) / (1 + c), .5 * u);\n      var d = Math.tan(.5 * (.5 * Math.PI - h)) / c;\n      return h = -s * Math.log(d), new o.Point(r, h);\n    },\n    unproject: function unproject(t) {\n      for (var e, i = o.LatLng.RAD_TO_DEG, n = this.R_MAJOR, s = this.R_MINOR, a = t.x * i / n, r = s / n, h = Math.sqrt(1 - r * r), l = Math.exp(-t.y / n), u = Math.PI / 2 - 2 * Math.atan(l), c = 15, d = 1e-7, p = c, _ = .1; Math.abs(_) > d && --p > 0;) {\n        e = h * Math.sin(u), _ = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), .5 * h)) - u, u += _;\n      }\n\n      return new o.LatLng(u * i, a);\n    }\n  }, o.CRS.EPSG3395 = o.extend({}, o.CRS, {\n    code: "EPSG:3395",\n    projection: o.Projection.Mercator,\n    transformation: function () {\n      var t = o.Projection.Mercator,\n          e = t.R_MAJOR,\n          i = .5 / (Math.PI * e);\n      return new o.Transformation(i, .5, -i, .5);\n    }()\n  }), o.TileLayer = o.Class.extend({\n    includes: o.Mixin.Events,\n    options: {\n      minZoom: 0,\n      maxZoom: 18,\n      tileSize: 256,\n      subdomains: "abc",\n      errorTileUrl: "",\n      attribution: "",\n      zoomOffset: 0,\n      opacity: 1,\n      unloadInvisibleTiles: o.Browser.mobile,\n      updateWhenIdle: o.Browser.mobile\n    },\n    initialize: function initialize(t, e) {\n      e = o.setOptions(this, e), e.detectRetina && o.Browser.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomOffset++, e.minZoom > 0 && e.minZoom--, this.options.maxZoom--), e.bounds && (e.bounds = o.latLngBounds(e.bounds)), this._url = t;\n      var i = this.options.subdomains;\n      "string" == typeof i && (this.options.subdomains = i.split(""));\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, this._animated = t._zoomAnimated, this._initContainer(), t.on({\n        viewreset: this._reset,\n        moveend: this._update\n      }, this), this._animated && t.on({\n        zoomanim: this._animateZoom,\n        zoomend: this._endZoomAnim\n      }, this), this.options.updateWhenIdle || (this._limitedUpdate = o.Util.limitExecByInterval(this._update, 150, this), t.on("move", this._limitedUpdate, this)), this._reset(), this._update();\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    onRemove: function onRemove(t) {\n      this._container.parentNode.removeChild(this._container), t.off({\n        viewreset: this._reset,\n        moveend: this._update\n      }, this), this._animated && t.off({\n        zoomanim: this._animateZoom,\n        zoomend: this._endZoomAnim\n      }, this), this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this), this._container = null, this._map = null;\n    },\n    bringToFront: function bringToFront() {\n      var t = this._map._panes.tilePane;\n      return this._container && (t.appendChild(this._container), this._setAutoZIndex(t, Math.max)), this;\n    },\n    bringToBack: function bringToBack() {\n      var t = this._map._panes.tilePane;\n      return this._container && (t.insertBefore(this._container, t.firstChild), this._setAutoZIndex(t, Math.min)), this;\n    },\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._map && this._updateOpacity(), this;\n    },\n    setZIndex: function setZIndex(t) {\n      return this.options.zIndex = t, this._updateZIndex(), this;\n    },\n    setUrl: function setUrl(t, e) {\n      return this._url = t, e || this.redraw(), this;\n    },\n    redraw: function redraw() {\n      return this._map && (this._reset({\n        hard: !0\n      }), this._update()), this;\n    },\n    _updateZIndex: function _updateZIndex() {\n      this._container && this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex);\n    },\n    _setAutoZIndex: function _setAutoZIndex(t, e) {\n      var i,\n          n,\n          o,\n          s = t.children,\n          a = -e(1 / 0, -(1 / 0));\n\n      for (n = 0, o = s.length; o > n; n++) {\n        s[n] !== this._container && (i = parseInt(s[n].style.zIndex, 10), isNaN(i) || (a = e(a, i)));\n      }\n\n      this.options.zIndex = this._container.style.zIndex = (isFinite(a) ? a : 0) + e(1, -1);\n    },\n    _updateOpacity: function _updateOpacity() {\n      var t,\n          e = this._tiles;\n      if (o.Browser.ielt9) for (t in e) {\n        o.DomUtil.setOpacity(e[t], this.options.opacity);\n      } else o.DomUtil.setOpacity(this._container, this.options.opacity);\n    },\n    _initContainer: function _initContainer() {\n      var t = this._map._panes.tilePane;\n\n      if (!this._container) {\n        if (this._container = o.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) {\n          var e = "leaflet-tile-container";\n          this._bgBuffer = o.DomUtil.create("div", e, this._container), this._tileContainer = o.DomUtil.create("div", e, this._container);\n        } else this._tileContainer = this._container;\n\n        t.appendChild(this._container), this.options.opacity < 1 && this._updateOpacity();\n      }\n    },\n    _reset: function _reset(t) {\n      for (var e in this._tiles) {\n        this.fire("tileunload", {\n          tile: this._tiles[e]\n        });\n      }\n\n      this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), this._tileContainer.innerHTML = "", this._animated && t && t.hard && this._clearBgBuffer(), this._initContainer();\n    },\n    _getTileSize: function _getTileSize() {\n      var t = this._map,\n          e = t.getZoom() + this.options.zoomOffset,\n          i = this.options.maxNativeZoom,\n          n = this.options.tileSize;\n      return i && e > i && (n = Math.round(t.getZoomScale(e) / t.getZoomScale(i) * n)), n;\n    },\n    _update: function _update() {\n      if (this._map) {\n        var t = this._map,\n            e = t.getPixelBounds(),\n            i = t.getZoom(),\n            n = this._getTileSize();\n\n        if (!(i > this.options.maxZoom || i < this.options.minZoom)) {\n          var s = o.bounds(e.min.divideBy(n)._floor(), e.max.divideBy(n)._floor());\n          this._addTilesFromCenterOut(s), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(s);\n        }\n      }\n    },\n    _addTilesFromCenterOut: function _addTilesFromCenterOut(t) {\n      var i,\n          n,\n          s,\n          a = [],\n          r = t.getCenter();\n\n      for (i = t.min.y; i <= t.max.y; i++) {\n        for (n = t.min.x; n <= t.max.x; n++) {\n          s = new o.Point(n, i), this._tileShouldBeLoaded(s) && a.push(s);\n        }\n      }\n\n      var h = a.length;\n\n      if (0 !== h) {\n        a.sort(function (t, e) {\n          return t.distanceTo(r) - e.distanceTo(r);\n        });\n        var l = e.createDocumentFragment();\n\n        for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += h, n = 0; h > n; n++) {\n          this._addTile(a[n], l);\n        }\n\n        this._tileContainer.appendChild(l);\n      }\n    },\n    _tileShouldBeLoaded: function _tileShouldBeLoaded(t) {\n      if (t.x + ":" + t.y in this._tiles) return !1;\n      var e = this.options;\n\n      if (!e.continuousWorld) {\n        var i = this._getWrapTileNum();\n\n        if (e.noWrap && (t.x < 0 || t.x >= i.x) || t.y < 0 || t.y >= i.y) return !1;\n      }\n\n      if (e.bounds) {\n        var n = this._getTileSize(),\n            o = t.multiplyBy(n),\n            s = o.add([n, n]),\n            a = this._map.unproject(o),\n            r = this._map.unproject(s);\n\n        if (e.continuousWorld || e.noWrap || (a = a.wrap(), r = r.wrap()), !e.bounds.intersects([a, r])) return !1;\n      }\n\n      return !0;\n    },\n    _removeOtherTiles: function _removeOtherTiles(t) {\n      var e, i, n, o;\n\n      for (o in this._tiles) {\n        e = o.split(":"), i = parseInt(e[0], 10), n = parseInt(e[1], 10), (i < t.min.x || i > t.max.x || n < t.min.y || n > t.max.y) && this._removeTile(o);\n      }\n    },\n    _removeTile: function _removeTile(t) {\n      var e = this._tiles[t];\n      this.fire("tileunload", {\n        tile: e,\n        url: e.src\n      }), this.options.reuseTiles ? (o.DomUtil.removeClass(e, "leaflet-tile-loaded"), this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e), o.Browser.android || (e.onload = null, e.src = o.Util.emptyImageUrl), delete this._tiles[t];\n    },\n    _addTile: function _addTile(t, e) {\n      var i = this._getTilePos(t),\n          n = this._getTile();\n\n      o.DomUtil.setPosition(n, i, o.Browser.chrome), this._tiles[t.x + ":" + t.y] = n, this._loadTile(n, t), n.parentNode !== this._tileContainer && e.appendChild(n);\n    },\n    _getZoomForUrl: function _getZoomForUrl() {\n      var t = this.options,\n          e = this._map.getZoom();\n\n      return t.zoomReverse && (e = t.maxZoom - e), e += t.zoomOffset, t.maxNativeZoom ? Math.min(e, t.maxNativeZoom) : e;\n    },\n    _getTilePos: function _getTilePos(t) {\n      var e = this._map.getPixelOrigin(),\n          i = this._getTileSize();\n\n      return t.multiplyBy(i).subtract(e);\n    },\n    getTileUrl: function getTileUrl(t) {\n      return o.Util.template(this._url, o.extend({\n        s: this._getSubdomain(t),\n        z: t.z,\n        x: t.x,\n        y: t.y\n      }, this.options));\n    },\n    _getWrapTileNum: function _getWrapTileNum() {\n      var t = this._map.options.crs,\n          e = t.getSize(this._map.getZoom());\n      return e.divideBy(this._getTileSize())._floor();\n    },\n    _adjustTilePoint: function _adjustTilePoint(t) {\n      var e = this._getWrapTileNum();\n\n      this.options.continuousWorld || this.options.noWrap || (t.x = (t.x % e.x + e.x) % e.x), this.options.tms && (t.y = e.y - t.y - 1), t.z = this._getZoomForUrl();\n    },\n    _getSubdomain: function _getSubdomain(t) {\n      var e = Math.abs(t.x + t.y) % this.options.subdomains.length;\n      return this.options.subdomains[e];\n    },\n    _getTile: function _getTile() {\n      if (this.options.reuseTiles && this._unusedTiles.length > 0) {\n        var t = this._unusedTiles.pop();\n\n        return this._resetTile(t), t;\n      }\n\n      return this._createTile();\n    },\n    _resetTile: function _resetTile() {},\n    _createTile: function _createTile() {\n      var t = o.DomUtil.create("img", "leaflet-tile");\n      return t.style.width = t.style.height = this._getTileSize() + "px", t.galleryimg = "no", t.onselectstart = t.onmousemove = o.Util.falseFn, o.Browser.ielt9 && this.options.opacity !== i && o.DomUtil.setOpacity(t, this.options.opacity), o.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden"), t;\n    },\n    _loadTile: function _loadTile(t, e) {\n      t._layer = this, t.onload = this._tileOnLoad, t.onerror = this._tileOnError, this._adjustTilePoint(e), t.src = this.getTileUrl(e), this.fire("tileloadstart", {\n        tile: t,\n        url: t.src\n      });\n    },\n    _tileLoaded: function _tileLoaded() {\n      this._tilesToLoad--, this._animated && o.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated"), this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(o.bind(this._clearBgBuffer, this), 500)));\n    },\n    _tileOnLoad: function _tileOnLoad() {\n      var t = this._layer;\n      this.src !== o.Util.emptyImageUrl && (o.DomUtil.addClass(this, "leaflet-tile-loaded"), t.fire("tileload", {\n        tile: this,\n        url: this.src\n      })), t._tileLoaded();\n    },\n    _tileOnError: function _tileOnError() {\n      var t = this._layer;\n      t.fire("tileerror", {\n        tile: this,\n        url: this.src\n      });\n      var e = t.options.errorTileUrl;\n      e && (this.src = e), t._tileLoaded();\n    }\n  }), o.tileLayer = function (t, e) {\n    return new o.TileLayer(t, e);\n  }, o.TileLayer.WMS = o.TileLayer.extend({\n    defaultWmsParams: {\n      service: "WMS",\n      request: "GetMap",\n      version: "1.1.1",\n      layers: "",\n      styles: "",\n      format: "image/jpeg",\n      transparent: !1\n    },\n    initialize: function initialize(t, e) {\n      this._url = t;\n      var i = o.extend({}, this.defaultWmsParams),\n          n = e.tileSize || this.options.tileSize;\n      e.detectRetina && o.Browser.retina ? i.width = i.height = 2 * n : i.width = i.height = n;\n\n      for (var s in e) {\n        this.options.hasOwnProperty(s) || "crs" === s || (i[s] = e[s]);\n      }\n\n      this.wmsParams = i, o.setOptions(this, e);\n    },\n    onAdd: function onAdd(t) {\n      this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);\n      var e = this._wmsVersion >= 1.3 ? "crs" : "srs";\n      this.wmsParams[e] = this._crs.code, o.TileLayer.prototype.onAdd.call(this, t);\n    },\n    getTileUrl: function getTileUrl(t) {\n      var e = this._map,\n          i = this.options.tileSize,\n          n = t.multiplyBy(i),\n          s = n.add([i, i]),\n          a = this._crs.project(e.unproject(n, t.z)),\n          r = this._crs.project(e.unproject(s, t.z)),\n          h = this._wmsVersion >= 1.3 && this._crs === o.CRS.EPSG4326 ? [r.y, a.x, a.y, r.x].join(",") : [a.x, r.y, r.x, a.y].join(","),\n          l = o.Util.template(this._url, {\n        s: this._getSubdomain(t)\n      });\n\n      return l + o.Util.getParamString(this.wmsParams, l, !0) + "&BBOX=" + h;\n    },\n    setParams: function setParams(t, e) {\n      return o.extend(this.wmsParams, t), e || this.redraw(), this;\n    }\n  }), o.tileLayer.wms = function (t, e) {\n    return new o.TileLayer.WMS(t, e);\n  }, o.TileLayer.Canvas = o.TileLayer.extend({\n    options: {\n      async: !1\n    },\n    initialize: function initialize(t) {\n      o.setOptions(this, t);\n    },\n    redraw: function redraw() {\n      this._map && (this._reset({\n        hard: !0\n      }), this._update());\n\n      for (var t in this._tiles) {\n        this._redrawTile(this._tiles[t]);\n      }\n\n      return this;\n    },\n    _redrawTile: function _redrawTile(t) {\n      this.drawTile(t, t._tilePoint, this._map._zoom);\n    },\n    _createTile: function _createTile() {\n      var t = o.DomUtil.create("canvas", "leaflet-tile");\n      return t.width = t.height = this.options.tileSize, t.onselectstart = t.onmousemove = o.Util.falseFn, t;\n    },\n    _loadTile: function _loadTile(t, e) {\n      t._layer = this, t._tilePoint = e, this._redrawTile(t), this.options.async || this.tileDrawn(t);\n    },\n    drawTile: function drawTile() {},\n    tileDrawn: function tileDrawn(t) {\n      this._tileOnLoad.call(t);\n    }\n  }), o.tileLayer.canvas = function (t) {\n    return new o.TileLayer.Canvas(t);\n  }, o.ImageOverlay = o.Class.extend({\n    includes: o.Mixin.Events,\n    options: {\n      opacity: 1\n    },\n    initialize: function initialize(t, e, i) {\n      this._url = t, this._bounds = o.latLngBounds(e), o.setOptions(this, i);\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, this._image || this._initImage(), t._panes.overlayPane.appendChild(this._image), t.on("viewreset", this._reset, this), t.options.zoomAnimation && o.Browser.any3d && t.on("zoomanim", this._animateZoom, this), this._reset();\n    },\n    onRemove: function onRemove(t) {\n      t.getPanes().overlayPane.removeChild(this._image), t.off("viewreset", this._reset, this), t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this);\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._updateOpacity(), this;\n    },\n    bringToFront: function bringToFront() {\n      return this._image && this._map._panes.overlayPane.appendChild(this._image), this;\n    },\n    bringToBack: function bringToBack() {\n      var t = this._map._panes.overlayPane;\n      return this._image && t.insertBefore(this._image, t.firstChild), this;\n    },\n    setUrl: function setUrl(t) {\n      this._url = t, this._image.src = this._url;\n    },\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    _initImage: function _initImage() {\n      this._image = o.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && o.Browser.any3d ? o.DomUtil.addClass(this._image, "leaflet-zoom-animated") : o.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), o.extend(this._image, {\n        galleryimg: "no",\n        onselectstart: o.Util.falseFn,\n        onmousemove: o.Util.falseFn,\n        onload: o.bind(this._onImageLoad, this),\n        src: this._url\n      });\n    },\n    _animateZoom: function _animateZoom(t) {\n      var e = this._map,\n          i = this._image,\n          n = e.getZoomScale(t.zoom),\n          s = this._bounds.getNorthWest(),\n          a = this._bounds.getSouthEast(),\n          r = e._latLngToNewLayerPoint(s, t.zoom, t.center),\n          h = e._latLngToNewLayerPoint(a, t.zoom, t.center)._subtract(r),\n          l = r._add(h._multiplyBy(.5 * (1 - 1 / n)));\n\n      i.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(l) + " scale(" + n + ") ";\n    },\n    _reset: function _reset() {\n      var t = this._image,\n          e = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\n          i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);\n\n      o.DomUtil.setPosition(t, e), t.style.width = i.x + "px", t.style.height = i.y + "px";\n    },\n    _onImageLoad: function _onImageLoad() {\n      this.fire("load");\n    },\n    _updateOpacity: function _updateOpacity() {\n      o.DomUtil.setOpacity(this._image, this.options.opacity);\n    }\n  }), o.imageOverlay = function (t, e, i) {\n    return new o.ImageOverlay(t, e, i);\n  }, o.Icon = o.Class.extend({\n    options: {\n      className: ""\n    },\n    initialize: function initialize(t) {\n      o.setOptions(this, t);\n    },\n    createIcon: function createIcon(t) {\n      return this._createIcon("icon", t);\n    },\n    createShadow: function createShadow(t) {\n      return this._createIcon("shadow", t);\n    },\n    _createIcon: function _createIcon(t, e) {\n      var i = this._getIconUrl(t);\n\n      if (!i) {\n        if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs).");\n        return null;\n      }\n\n      var n;\n      return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i), this._setIconStyles(n, t), n;\n    },\n    _setIconStyles: function _setIconStyles(t, e) {\n      var i,\n          n = this.options,\n          s = o.point(n[e + "Size"]);\n      i = "shadow" === e ? o.point(n.shadowAnchor || n.iconAnchor) : o.point(n.iconAnchor), !i && s && (i = s.divideBy(2, !0)), t.className = "leaflet-marker-" + e + " " + n.className, i && (t.style.marginLeft = -i.x + "px", t.style.marginTop = -i.y + "px"), s && (t.style.width = s.x + "px", t.style.height = s.y + "px");\n    },\n    _createImg: function _createImg(t, i) {\n      return i = i || e.createElement("img"), i.src = t, i;\n    },\n    _getIconUrl: function _getIconUrl(t) {\n      return o.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"];\n    }\n  }), o.icon = function (t) {\n    return new o.Icon(t);\n  }, o.Icon.Default = o.Icon.extend({\n    options: {\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function _getIconUrl(t) {\n      var e = t + "Url";\n      if (this.options[e]) return this.options[e];\n      o.Browser.retina && "icon" === t && (t += "-2x");\n      var i = o.Icon.Default.imagePath;\n      if (!i) throw new Error("Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.");\n      return i + "/marker-" + t + ".png";\n    }\n  }), o.Icon.Default.imagePath = function () {\n    var t,\n        i,\n        n,\n        o,\n        s,\n        a = e.getElementsByTagName("script"),\n        r = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n    for (t = 0, i = a.length; i > t; t++) {\n      if (n = a[t].src, o = n.match(r)) return s = n.split(r)[0], (s ? s + "/" : "") + "images";\n    }\n  }(), o.Marker = o.Class.extend({\n    includes: o.Mixin.Events,\n    options: {\n      icon: new o.Icon.Default(),\n      title: "",\n      alt: "",\n      clickable: !0,\n      draggable: !1,\n      keyboard: !0,\n      zIndexOffset: 0,\n      opacity: 1,\n      riseOnHover: !1,\n      riseOffset: 250\n    },\n    initialize: function initialize(t, e) {\n      o.setOptions(this, e), this._latlng = o.latLng(t);\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, t.on("viewreset", this.update, this), this._initIcon(), this.update(), this.fire("add"), t.options.zoomAnimation && t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this);\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    onRemove: function onRemove(t) {\n      this.dragging && this.dragging.disable(), this._removeIcon(), this._removeShadow(), this.fire("remove"), t.off({\n        viewreset: this.update,\n        zoomanim: this._animateZoom\n      }, this), this._map = null;\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(t) {\n      return this._latlng = o.latLng(t), this.update(), this.fire("move", {\n        latlng: this._latlng\n      });\n    },\n    setZIndexOffset: function setZIndexOffset(t) {\n      return this.options.zIndexOffset = t, this.update(), this;\n    },\n    setIcon: function setIcon(t) {\n      return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this;\n    },\n    update: function update() {\n      return this._icon && this._setPos(this._map.latLngToLayerPoint(this._latlng).round()), this;\n    },\n    _initIcon: function _initIcon() {\n      var t = this.options,\n          e = this._map,\n          i = e.options.zoomAnimation && e.options.markerZoomAnimation,\n          n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide",\n          s = t.icon.createIcon(this._icon),\n          a = !1;\n      s !== this._icon && (this._icon && this._removeIcon(), a = !0, t.title && (s.title = t.title), t.alt && (s.alt = t.alt)), o.DomUtil.addClass(s, n), t.keyboard && (s.tabIndex = "0"), this._icon = s, this._initInteraction(), t.riseOnHover && o.DomEvent.on(s, "mouseover", this._bringToFront, this).on(s, "mouseout", this._resetZIndex, this);\n      var r = t.icon.createShadow(this._shadow),\n          h = !1;\n      r !== this._shadow && (this._removeShadow(), h = !0), r && o.DomUtil.addClass(r, n), this._shadow = r, t.opacity < 1 && this._updateOpacity();\n      var l = this._map._panes;\n      a && l.markerPane.appendChild(this._icon), r && h && l.shadowPane.appendChild(this._shadow);\n    },\n    _removeIcon: function _removeIcon() {\n      this.options.riseOnHover && o.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), this._map._panes.markerPane.removeChild(this._icon), this._icon = null;\n    },\n    _removeShadow: function _removeShadow() {\n      this._shadow && this._map._panes.shadowPane.removeChild(this._shadow), this._shadow = null;\n    },\n    _setPos: function _setPos(t) {\n      o.DomUtil.setPosition(this._icon, t), this._shadow && o.DomUtil.setPosition(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex();\n    },\n    _updateZIndex: function _updateZIndex(t) {\n      this._icon.style.zIndex = this._zIndex + t;\n    },\n    _animateZoom: function _animateZoom(t) {\n      var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();\n\n      this._setPos(e);\n    },\n    _initInteraction: function _initInteraction() {\n      if (this.options.clickable) {\n        var t = this._icon,\n            e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];\n        o.DomUtil.addClass(t, "leaflet-clickable"), o.DomEvent.on(t, "click", this._onMouseClick, this), o.DomEvent.on(t, "keypress", this._onKeyPress, this);\n\n        for (var i = 0; i < e.length; i++) {\n          o.DomEvent.on(t, e[i], this._fireMouseEvent, this);\n        }\n\n        o.Handler.MarkerDrag && (this.dragging = new o.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable());\n      }\n    },\n    _onMouseClick: function _onMouseClick(t) {\n      var e = this.dragging && this.dragging.moved();\n      (this.hasEventListeners(t.type) || e) && o.DomEvent.stopPropagation(t), e || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(t.type, {\n        originalEvent: t,\n        latlng: this._latlng\n      });\n    },\n    _onKeyPress: function _onKeyPress(t) {\n      13 === t.keyCode && this.fire("click", {\n        originalEvent: t,\n        latlng: this._latlng\n      });\n    },\n    _fireMouseEvent: function _fireMouseEvent(t) {\n      this.fire(t.type, {\n        originalEvent: t,\n        latlng: this._latlng\n      }), "contextmenu" === t.type && this.hasEventListeners(t.type) && o.DomEvent.preventDefault(t), "mousedown" !== t.type ? o.DomEvent.stopPropagation(t) : o.DomEvent.preventDefault(t);\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._map && this._updateOpacity(), this;\n    },\n    _updateOpacity: function _updateOpacity() {\n      o.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && o.DomUtil.setOpacity(this._shadow, this.options.opacity);\n    },\n    _bringToFront: function _bringToFront() {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function _resetZIndex() {\n      this._updateZIndex(0);\n    }\n  }), o.marker = function (t, e) {\n    return new o.Marker(t, e);\n  }, o.DivIcon = o.Icon.extend({\n    options: {\n      iconSize: [12, 12],\n      className: "leaflet-div-icon",\n      html: !1\n    },\n    createIcon: function createIcon(t) {\n      var i = t && "DIV" === t.tagName ? t : e.createElement("div"),\n          n = this.options;\n      return n.html !== !1 ? i.innerHTML = n.html : i.innerHTML = "", n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"), this._setIconStyles(i, "icon"), i;\n    },\n    createShadow: function createShadow() {\n      return null;\n    }\n  }), o.divIcon = function (t) {\n    return new o.DivIcon(t);\n  }, o.Map.mergeOptions({\n    closePopupOnClick: !0\n  }), o.Popup = o.Class.extend({\n    includes: o.Mixin.Events,\n    options: {\n      minWidth: 50,\n      maxWidth: 300,\n      autoPan: !0,\n      closeButton: !0,\n      offset: [0, 7],\n      autoPanPadding: [5, 5],\n      keepInView: !1,\n      className: "",\n      zoomAnimation: !0\n    },\n    initialize: function initialize(t, e) {\n      o.setOptions(this, t), this._source = e, this._animated = o.Browser.any3d && this.options.zoomAnimation, this._isOpen = !1;\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, this._container || this._initLayout();\n      var e = t.options.fadeAnimation;\n      e && o.DomUtil.setOpacity(this._container, 0), t._panes.popupPane.appendChild(this._container), t.on(this._getEvents(), this), this.update(), e && o.DomUtil.setOpacity(this._container, 1), this.fire("open"), t.fire("popupopen", {\n        popup: this\n      }), this._source && this._source.fire("popupopen", {\n        popup: this\n      });\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    openOn: function openOn(t) {\n      return t.openPopup(this), this;\n    },\n    onRemove: function onRemove(t) {\n      t._panes.popupPane.removeChild(this._container), o.Util.falseFn(this._container.offsetWidth), t.off(this._getEvents(), this), t.options.fadeAnimation && o.DomUtil.setOpacity(this._container, 0), this._map = null, this.fire("close"), t.fire("popupclose", {\n        popup: this\n      }), this._source && this._source.fire("popupclose", {\n        popup: this\n      });\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(t) {\n      return this._latlng = o.latLng(t), this._map && (this._updatePosition(), this._adjustPan()), this;\n    },\n    getContent: function getContent() {\n      return this._content;\n    },\n    setContent: function setContent(t) {\n      return this._content = t, this.update(), this;\n    },\n    update: function update() {\n      this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());\n    },\n    _getEvents: function _getEvents() {\n      var t = {\n        viewreset: this._updatePosition\n      };\n      return this._animated && (t.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t;\n    },\n    _close: function _close() {\n      this._map && this._map.closePopup(this);\n    },\n    _initLayout: function _initLayout() {\n      var t,\n          e = "leaflet-popup",\n          i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"),\n          n = this._container = o.DomUtil.create("div", i);\n      this.options.closeButton && (t = this._closeButton = o.DomUtil.create("a", e + "-close-button", n), t.href = "#close", t.innerHTML = "&#215;", o.DomEvent.disableClickPropagation(t), o.DomEvent.on(t, "click", this._onCloseButtonClick, this));\n      var s = this._wrapper = o.DomUtil.create("div", e + "-content-wrapper", n);\n      o.DomEvent.disableClickPropagation(s), this._contentNode = o.DomUtil.create("div", e + "-content", s), o.DomEvent.disableScrollPropagation(this._contentNode), o.DomEvent.on(s, "contextmenu", o.DomEvent.stopPropagation), this._tipContainer = o.DomUtil.create("div", e + "-tip-container", n), this._tip = o.DomUtil.create("div", e + "-tip", this._tipContainer);\n    },\n    _updateContent: function _updateContent() {\n      if (this._content) {\n        if ("string" == typeof this._content) this._contentNode.innerHTML = this._content;else {\n          for (; this._contentNode.hasChildNodes();) {\n            this._contentNode.removeChild(this._contentNode.firstChild);\n          }\n\n          this._contentNode.appendChild(this._content);\n        }\n        this.fire("contentupdate");\n      }\n    },\n    _updateLayout: function _updateLayout() {\n      var t = this._contentNode,\n          e = t.style;\n      e.width = "", e.whiteSpace = "nowrap";\n      var i = t.offsetWidth;\n      i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";\n      var n = t.offsetHeight,\n          s = this.options.maxHeight,\n          a = "leaflet-popup-scrolled";\n      s && n > s ? (e.height = s + "px", o.DomUtil.addClass(t, a)) : o.DomUtil.removeClass(t, a), this._containerWidth = this._container.offsetWidth;\n    },\n    _updatePosition: function _updatePosition() {\n      if (this._map) {\n        var t = this._map.latLngToLayerPoint(this._latlng),\n            e = this._animated,\n            i = o.point(this.options.offset);\n\n        e && o.DomUtil.setPosition(this._container, t), this._containerBottom = -i.y - (e ? 0 : t.y), this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + (e ? 0 : t.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px";\n      }\n    },\n    _zoomAnimation: function _zoomAnimation(t) {\n      var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);\n\n      o.DomUtil.setPosition(this._container, e);\n    },\n    _adjustPan: function _adjustPan() {\n      if (this.options.autoPan) {\n        var t = this._map,\n            e = this._container.offsetHeight,\n            i = this._containerWidth,\n            n = new o.Point(this._containerLeft, -e - this._containerBottom);\n        this._animated && n._add(o.DomUtil.getPosition(this._container));\n        var s = t.layerPointToContainerPoint(n),\n            a = o.point(this.options.autoPanPadding),\n            r = o.point(this.options.autoPanPaddingTopLeft || a),\n            h = o.point(this.options.autoPanPaddingBottomRight || a),\n            l = t.getSize(),\n            u = 0,\n            c = 0;\n        s.x + i + h.x > l.x && (u = s.x + i - l.x + h.x), s.x - u - r.x < 0 && (u = s.x - r.x), s.y + e + h.y > l.y && (c = s.y + e - l.y + h.y), s.y - c - r.y < 0 && (c = s.y - r.y), (u || c) && t.fire("autopanstart").panBy([u, c]);\n      }\n    },\n    _onCloseButtonClick: function _onCloseButtonClick(t) {\n      this._close(), o.DomEvent.stop(t);\n    }\n  }), o.popup = function (t, e) {\n    return new o.Popup(t, e);\n  }, o.Map.include({\n    openPopup: function openPopup(t, e, i) {\n      if (this.closePopup(), !(t instanceof o.Popup)) {\n        var n = t;\n        t = new o.Popup(i).setLatLng(e).setContent(n);\n      }\n\n      return t._isOpen = !0, this._popup = t, this.addLayer(t);\n    },\n    closePopup: function closePopup(t) {\n      return t && t !== this._popup || (t = this._popup, this._popup = null), t && (this.removeLayer(t), t._isOpen = !1), this;\n    }\n  }), o.Marker.include({\n    openPopup: function openPopup() {\n      return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this;\n    },\n    closePopup: function closePopup() {\n      return this._popup && this._popup._close(), this;\n    },\n    togglePopup: function togglePopup() {\n      return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()), this;\n    },\n    bindPopup: function bindPopup(t, e) {\n      var i = o.point(this.options.icon.options.popupAnchor || [0, 0]);\n      return i = i.add(o.Popup.prototype.options.offset), e && e.offset && (i = i.add(e.offset)), e = o.extend({\n        offset: i\n      }, e), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), t instanceof o.Popup ? (o.setOptions(t, e), this._popup = t, t._source = this) : this._popup = new o.Popup(e, this).setContent(t), this;\n    },\n    setPopupContent: function setPopupContent(t) {\n      return this._popup && this._popup.setContent(t), this;\n    },\n    unbindPopup: function unbindPopup() {\n      return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this;\n    },\n    getPopup: function getPopup() {\n      return this._popup;\n    },\n    _movePopup: function _movePopup(t) {\n      this._popup.setLatLng(t.latlng);\n    }\n  }), o.LayerGroup = o.Class.extend({\n    initialize: function initialize(t) {\n      this._layers = {};\n      var e, i;\n      if (t) for (e = 0, i = t.length; i > e; e++) {\n        this.addLayer(t[e]);\n      }\n    },\n    addLayer: function addLayer(t) {\n      var e = this.getLayerId(t);\n      return this._layers[e] = t, this._map && this._map.addLayer(t), this;\n    },\n    removeLayer: function removeLayer(t) {\n      var e = t in this._layers ? t : this.getLayerId(t);\n      return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this;\n    },\n    hasLayer: function hasLayer(t) {\n      return t ? t in this._layers || this.getLayerId(t) in this._layers : !1;\n    },\n    clearLayers: function clearLayers() {\n      return this.eachLayer(this.removeLayer, this), this;\n    },\n    invoke: function invoke(t) {\n      var e,\n          i,\n          n = Array.prototype.slice.call(arguments, 1);\n\n      for (e in this._layers) {\n        i = this._layers[e], i[t] && i[t].apply(i, n);\n      }\n\n      return this;\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, this.eachLayer(t.addLayer, t);\n    },\n    onRemove: function onRemove(t) {\n      this.eachLayer(t.removeLayer, t), this._map = null;\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    eachLayer: function eachLayer(t, e) {\n      for (var i in this._layers) {\n        t.call(e, this._layers[i]);\n      }\n\n      return this;\n    },\n    getLayer: function getLayer(t) {\n      return this._layers[t];\n    },\n    getLayers: function getLayers() {\n      var t = [];\n\n      for (var e in this._layers) {\n        t.push(this._layers[e]);\n      }\n\n      return t;\n    },\n    setZIndex: function setZIndex(t) {\n      return this.invoke("setZIndex", t);\n    },\n    getLayerId: function getLayerId(t) {\n      return o.stamp(t);\n    }\n  }), o.layerGroup = function (t) {\n    return new o.LayerGroup(t);\n  }, o.FeatureGroup = o.LayerGroup.extend({\n    includes: o.Mixin.Events,\n    statics: {\n      EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"\n    },\n    addLayer: function addLayer(t) {\n      return this.hasLayer(t) ? this : ("on" in t && t.on(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.addLayer.call(this, t), this._popupContent && t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {\n        layer: t\n      }));\n    },\n    removeLayer: function removeLayer(t) {\n      return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), "off" in t && t.off(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.removeLayer.call(this, t), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {\n        layer: t\n      })) : this;\n    },\n    bindPopup: function bindPopup(t, e) {\n      return this._popupContent = t, this._popupOptions = e, this.invoke("bindPopup", t, e);\n    },\n    openPopup: function openPopup(t) {\n      for (var e in this._layers) {\n        this._layers[e].openPopup(t);\n\n        break;\n      }\n\n      return this;\n    },\n    setStyle: function setStyle(t) {\n      return this.invoke("setStyle", t);\n    },\n    bringToFront: function bringToFront() {\n      return this.invoke("bringToFront");\n    },\n    bringToBack: function bringToBack() {\n      return this.invoke("bringToBack");\n    },\n    getBounds: function getBounds() {\n      var t = new o.LatLngBounds();\n      return this.eachLayer(function (e) {\n        t.extend(e instanceof o.Marker ? e.getLatLng() : e.getBounds());\n      }), t;\n    },\n    _propagateEvent: function _propagateEvent(t) {\n      t = o.extend({\n        layer: t.target,\n        target: this\n      }, t), this.fire(t.type, t);\n    }\n  }), o.featureGroup = function (t) {\n    return new o.FeatureGroup(t);\n  }, o.Path = o.Class.extend({\n    includes: [o.Mixin.Events],\n    statics: {\n      CLIP_PADDING: function () {\n        var e = o.Browser.mobile ? 1280 : 2e3,\n            i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;\n        return Math.max(0, Math.min(.5, i));\n      }()\n    },\n    options: {\n      stroke: !0,\n      color: "#0033ff",\n      dashArray: null,\n      lineCap: null,\n      lineJoin: null,\n      weight: 5,\n      opacity: .5,\n      fill: !1,\n      fillColor: null,\n      fillOpacity: .2,\n      clickable: !0\n    },\n    initialize: function initialize(t) {\n      o.setOptions(this, t);\n    },\n    onAdd: function onAdd(t) {\n      this._map = t, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), t.on({\n        viewreset: this.projectLatlngs,\n        moveend: this._updatePath\n      }, this);\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    onRemove: function onRemove(t) {\n      t._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, o.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), t.off({\n        viewreset: this.projectLatlngs,\n        moveend: this._updatePath\n      }, this);\n    },\n    projectLatlngs: function projectLatlngs() {},\n    setStyle: function setStyle(t) {\n      return o.setOptions(this, t), this._container && this._updateStyle(), this;\n    },\n    redraw: function redraw() {\n      return this._map && (this.projectLatlngs(), this._updatePath()), this;\n    }\n  }), o.Map.include({\n    _updatePathViewport: function _updatePathViewport() {\n      var t = o.Path.CLIP_PADDING,\n          e = this.getSize(),\n          i = o.DomUtil.getPosition(this._mapPane),\n          n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),\n          s = n.add(e.multiplyBy(1 + 2 * t)._round());\n\n      this._pathViewport = new o.Bounds(n, s);\n    }\n  }), o.Path.SVG_NS = "http://www.w3.org/2000/svg", o.Browser.svg = !(!e.createElementNS || !e.createElementNS(o.Path.SVG_NS, "svg").createSVGRect), o.Path = o.Path.extend({\n    statics: {\n      SVG: o.Browser.svg\n    },\n    bringToFront: function bringToFront() {\n      var t = this._map._pathRoot,\n          e = this._container;\n      return e && t.lastChild !== e && t.appendChild(e), this;\n    },\n    bringToBack: function bringToBack() {\n      var t = this._map._pathRoot,\n          e = this._container,\n          i = t.firstChild;\n      return e && i !== e && t.insertBefore(e, i), this;\n    },\n    getPathString: function getPathString() {},\n    _createElement: function _createElement(t) {\n      return e.createElementNS(o.Path.SVG_NS, t);\n    },\n    _initElements: function _initElements() {\n      this._map._initPathRoot(), this._initPath(), this._initStyle();\n    },\n    _initPath: function _initPath() {\n      this._container = this._createElement("g"), this._path = this._createElement("path"), this.options.className && o.DomUtil.addClass(this._path, this.options.className), this._container.appendChild(this._path);\n    },\n    _initStyle: function _initStyle() {\n      this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents), this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none"), this._updateStyle();\n    },\n    _updateStyle: function _updateStyle() {\n      this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none");\n    },\n    _updatePath: function _updatePath() {\n      var t = this.getPathString();\n      t || (t = "M0 0"), this._path.setAttribute("d", t);\n    },\n    _initEvents: function _initEvents() {\n      if (this.options.clickable) {\n        (o.Browser.svg || !o.Browser.vml) && o.DomUtil.addClass(this._path, "leaflet-clickable"), o.DomEvent.on(this._container, "click", this._onMouseClick, this);\n\n        for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], e = 0; e < t.length; e++) {\n          o.DomEvent.on(this._container, t[e], this._fireMouseEvent, this);\n        }\n      }\n    },\n    _onMouseClick: function _onMouseClick(t) {\n      this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t);\n    },\n    _fireMouseEvent: function _fireMouseEvent(t) {\n      if (this._map && this.hasEventListeners(t.type)) {\n        var e = this._map,\n            i = e.mouseEventToContainerPoint(t),\n            n = e.containerPointToLayerPoint(i),\n            s = e.layerPointToLatLng(n);\n        this.fire(t.type, {\n          latlng: s,\n          layerPoint: n,\n          containerPoint: i,\n          originalEvent: t\n        }), "contextmenu" === t.type && o.DomEvent.preventDefault(t), "mousemove" !== t.type && o.DomEvent.stopPropagation(t);\n      }\n    }\n  }), o.Map.include({\n    _initPathRoot: function _initPathRoot() {\n      this._pathRoot || (this._pathRoot = o.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && o.Browser.any3d ? (o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({\n        zoomanim: this._animatePathZoom,\n        zoomend: this._endPathZoom\n      })) : o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport());\n    },\n    _animatePathZoom: function _animatePathZoom(t) {\n      var e = this.getZoomScale(t.zoom),\n          i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);\n\n      this._pathRoot.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(i) + " scale(" + e + ") ", this._pathZooming = !0;\n    },\n    _endPathZoom: function _endPathZoom() {\n      this._pathZooming = !1;\n    },\n    _updateSvgViewport: function _updateSvgViewport() {\n      if (!this._pathZooming) {\n        this._updatePathViewport();\n\n        var t = this._pathViewport,\n            e = t.min,\n            i = t.max,\n            n = i.x - e.x,\n            s = i.y - e.y,\n            a = this._pathRoot,\n            r = this._panes.overlayPane;\n        o.Browser.mobileWebkit && r.removeChild(a), o.DomUtil.setPosition(a, e), a.setAttribute("width", n), a.setAttribute("height", s), a.setAttribute("viewBox", [e.x, e.y, n, s].join(" ")), o.Browser.mobileWebkit && r.appendChild(a);\n      }\n    }\n  }), o.Path.include({\n    bindPopup: function bindPopup(t, e) {\n      return t instanceof o.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new o.Popup(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this;\n    },\n    unbindPopup: function unbindPopup() {\n      return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this;\n    },\n    openPopup: function openPopup(t) {\n      return this._popup && (t = t || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({\n        latlng: t\n      })), this;\n    },\n    closePopup: function closePopup() {\n      return this._popup && this._popup._close(), this;\n    },\n    _openPopup: function _openPopup(t) {\n      this._popup.setLatLng(t.latlng), this._map.openPopup(this._popup);\n    }\n  }), o.Browser.vml = !o.Browser.svg && function () {\n    try {\n      var t = e.createElement("div");\n      t.innerHTML = \'<v:shape adj="1"/>\';\n      var i = t.firstChild;\n      return i.style.behavior = "url(#default#VML)", i && "object" == _typeof(i.adj);\n    } catch (n) {\n      return !1;\n    }\n  }(), o.Path = o.Browser.svg || !o.Browser.vml ? o.Path : o.Path.extend({\n    statics: {\n      VML: !0,\n      CLIP_PADDING: .02\n    },\n    _createElement: function () {\n      try {\n        return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) {\n          return e.createElement("<lvml:" + t + \' class="lvml">\');\n        };\n      } catch (t) {\n        return function (t) {\n          return e.createElement("<" + t + \' xmlns="urn:schemas-microsoft.com:vml" class="lvml">\');\n        };\n      }\n    }(),\n    _initPath: function _initPath() {\n      var t = this._container = this._createElement("shape");\n\n      o.DomUtil.addClass(t, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : "")), this.options.clickable && o.DomUtil.addClass(t, "leaflet-clickable"), t.coordsize = "1 1", this._path = this._createElement("path"), t.appendChild(this._path), this._map._pathRoot.appendChild(t);\n    },\n    _initStyle: function _initStyle() {\n      this._updateStyle();\n    },\n    _updateStyle: function _updateStyle() {\n      var t = this._stroke,\n          e = this._fill,\n          i = this.options,\n          n = this._container;\n      n.stroked = i.stroke, n.filled = i.fill, i.stroke ? (t || (t = this._stroke = this._createElement("stroke"), t.endcap = "round", n.appendChild(t)), t.weight = i.weight + "px", t.color = i.color, t.opacity = i.opacity, i.dashArray ? t.dashStyle = o.Util.isArray(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : t.dashStyle = "", i.lineCap && (t.endcap = i.lineCap.replace("butt", "flat")), i.lineJoin && (t.joinstyle = i.lineJoin)) : t && (n.removeChild(t), this._stroke = null), i.fill ? (e || (e = this._fill = this._createElement("fill"), n.appendChild(e)), e.color = i.fillColor || i.color, e.opacity = i.fillOpacity) : e && (n.removeChild(e), this._fill = null);\n    },\n    _updatePath: function _updatePath() {\n      var t = this._container.style;\n      t.display = "none", this._path.v = this.getPathString() + " ", t.display = "";\n    }\n  }), o.Map.include(o.Browser.svg || !o.Browser.vml ? {} : {\n    _initPathRoot: function _initPathRoot() {\n      if (!this._pathRoot) {\n        var t = this._pathRoot = e.createElement("div");\n        t.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(t), this.on("moveend", this._updatePathViewport), this._updatePathViewport();\n      }\n    }\n  }), o.Browser.canvas = function () {\n    return !!e.createElement("canvas").getContext;\n  }(), o.Path = o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? o.Path : o.Path.extend({\n    statics: {\n      CANVAS: !0,\n      SVG: !1\n    },\n    redraw: function redraw() {\n      return this._map && (this.projectLatlngs(), this._requestUpdate()), this;\n    },\n    setStyle: function setStyle(t) {\n      return o.setOptions(this, t), this._map && (this._updateStyle(), this._requestUpdate()), this;\n    },\n    onRemove: function onRemove(t) {\n      t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this)), this._requestUpdate(), this.fire("remove"), this._map = null;\n    },\n    _requestUpdate: function _requestUpdate() {\n      this._map && !o.Path._updateRequest && (o.Path._updateRequest = o.Util.requestAnimFrame(this._fireMapMoveEnd, this._map));\n    },\n    _fireMapMoveEnd: function _fireMapMoveEnd() {\n      o.Path._updateRequest = null, this.fire("moveend");\n    },\n    _initElements: function _initElements() {\n      this._map._initPathRoot(), this._ctx = this._map._canvasCtx;\n    },\n    _updateStyle: function _updateStyle() {\n      var t = this.options;\n      t.stroke && (this._ctx.lineWidth = t.weight, this._ctx.strokeStyle = t.color), t.fill && (this._ctx.fillStyle = t.fillColor || t.color), t.lineCap && (this._ctx.lineCap = t.lineCap), t.lineJoin && (this._ctx.lineJoin = t.lineJoin);\n    },\n    _drawPath: function _drawPath() {\n      var t, e, i, n, s, a;\n\n      for (this._ctx.beginPath(), t = 0, i = this._parts.length; i > t; t++) {\n        for (e = 0, n = this._parts[t].length; n > e; e++) {\n          s = this._parts[t][e], a = (0 === e ? "move" : "line") + "To", this._ctx[a](s.x, s.y);\n        }\n\n        this instanceof o.Polygon && this._ctx.closePath();\n      }\n    },\n    _checkIfEmpty: function _checkIfEmpty() {\n      return !this._parts.length;\n    },\n    _updatePath: function _updatePath() {\n      if (!this._checkIfEmpty()) {\n        var t = this._ctx,\n            e = this.options;\n        this._drawPath(), t.save(), this._updateStyle(), e.fill && (t.globalAlpha = e.fillOpacity, t.fill(e.fillRule || "evenodd")), e.stroke && (t.globalAlpha = e.opacity, t.stroke()), t.restore();\n      }\n    },\n    _initEvents: function _initEvents() {\n      this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click dblclick contextmenu", this._fireMouseEvent, this));\n    },\n    _fireMouseEvent: function _fireMouseEvent(t) {\n      this._containsPoint(t.layerPoint) && this.fire(t.type, t);\n    },\n    _onMouseMove: function _onMouseMove(t) {\n      this._map && !this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", t)));\n    }\n  }), o.Map.include(o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? {} : {\n    _initPathRoot: function _initPathRoot() {\n      var t,\n          i = this._pathRoot;\n      i || (i = this._pathRoot = e.createElement("canvas"), i.style.position = "absolute", t = this._canvasCtx = i.getContext("2d"), t.lineCap = "round", t.lineJoin = "round", this._panes.overlayPane.appendChild(i), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport());\n    },\n    _updateCanvasViewport: function _updateCanvasViewport() {\n      if (!this._pathZooming) {\n        this._updatePathViewport();\n\n        var t = this._pathViewport,\n            e = t.min,\n            i = t.max.subtract(e),\n            n = this._pathRoot;\n        o.DomUtil.setPosition(n, e), n.width = i.x, n.height = i.y, n.getContext("2d").translate(-e.x, -e.y);\n      }\n    }\n  }), o.LineUtil = {\n    simplify: function simplify(t, e) {\n      if (!e || !t.length) return t.slice();\n      var i = e * e;\n      return t = this._reducePoints(t, i), t = this._simplifyDP(t, i);\n    },\n    pointToSegmentDistance: function pointToSegmentDistance(t, e, i) {\n      return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0));\n    },\n    closestPointOnSegment: function closestPointOnSegment(t, e, i) {\n      return this._sqClosestPointOnSegment(t, e, i);\n    },\n    _simplifyDP: function _simplifyDP(t, e) {\n      var n = t.length,\n          o = (typeof Uint8Array === "undefined" ? "undefined" : _typeof(Uint8Array)) != i + "" ? Uint8Array : Array,\n          s = new o(n);\n      s[0] = s[n - 1] = 1, this._simplifyDPStep(t, s, e, 0, n - 1);\n      var a,\n          r = [];\n\n      for (a = 0; n > a; a++) {\n        s[a] && r.push(t[a]);\n      }\n\n      return r;\n    },\n    _simplifyDPStep: function _simplifyDPStep(t, e, i, n, o) {\n      var s,\n          a,\n          r,\n          h = 0;\n\n      for (a = n + 1; o - 1 >= a; a++) {\n        r = this._sqClosestPointOnSegment(t[a], t[n], t[o], !0), r > h && (s = a, h = r);\n      }\n\n      h > i && (e[s] = 1, this._simplifyDPStep(t, e, i, n, s), this._simplifyDPStep(t, e, i, s, o));\n    },\n    _reducePoints: function _reducePoints(t, e) {\n      for (var i = [t[0]], n = 1, o = 0, s = t.length; s > n; n++) {\n        this._sqDist(t[n], t[o]) > e && (i.push(t[n]), o = n);\n      }\n\n      return s - 1 > o && i.push(t[s - 1]), i;\n    },\n    clipSegment: function clipSegment(t, e, i, n) {\n      var o,\n          s,\n          a,\n          r = n ? this._lastCode : this._getBitCode(t, i),\n          h = this._getBitCode(e, i);\n\n      for (this._lastCode = h;;) {\n        if (!(r | h)) return [t, e];\n        if (r & h) return !1;\n        o = r || h, s = this._getEdgeIntersection(t, e, o, i), a = this._getBitCode(s, i), o === r ? (t = s, r = a) : (e = s, h = a);\n      }\n    },\n    _getEdgeIntersection: function _getEdgeIntersection(t, e, i, n) {\n      var s = e.x - t.x,\n          a = e.y - t.y,\n          r = n.min,\n          h = n.max;\n      return 8 & i ? new o.Point(t.x + s * (h.y - t.y) / a, h.y) : 4 & i ? new o.Point(t.x + s * (r.y - t.y) / a, r.y) : 2 & i ? new o.Point(h.x, t.y + a * (h.x - t.x) / s) : 1 & i ? new o.Point(r.x, t.y + a * (r.x - t.x) / s) : void 0;\n    },\n    _getBitCode: function _getBitCode(t, e) {\n      var i = 0;\n      return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i;\n    },\n    _sqDist: function _sqDist(t, e) {\n      var i = e.x - t.x,\n          n = e.y - t.y;\n      return i * i + n * n;\n    },\n    _sqClosestPointOnSegment: function _sqClosestPointOnSegment(t, e, i, n) {\n      var s,\n          a = e.x,\n          r = e.y,\n          h = i.x - a,\n          l = i.y - r,\n          u = h * h + l * l;\n      return u > 0 && (s = ((t.x - a) * h + (t.y - r) * l) / u, s > 1 ? (a = i.x, r = i.y) : s > 0 && (a += h * s, r += l * s)), h = t.x - a, l = t.y - r, n ? h * h + l * l : new o.Point(a, r);\n    }\n  }, o.Polyline = o.Path.extend({\n    initialize: function initialize(t, e) {\n      o.Path.prototype.initialize.call(this, e), this._latlngs = this._convertLatLngs(t);\n    },\n    options: {\n      smoothFactor: 1,\n      noClip: !1\n    },\n    projectLatlngs: function projectLatlngs() {\n      this._originalPoints = [];\n\n      for (var t = 0, e = this._latlngs.length; e > t; t++) {\n        this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t]);\n      }\n    },\n    getPathString: function getPathString() {\n      for (var t = 0, e = this._parts.length, i = ""; e > t; t++) {\n        i += this._getPathPartStr(this._parts[t]);\n      }\n\n      return i;\n    },\n    getLatLngs: function getLatLngs() {\n      return this._latlngs;\n    },\n    setLatLngs: function setLatLngs(t) {\n      return this._latlngs = this._convertLatLngs(t), this.redraw();\n    },\n    addLatLng: function addLatLng(t) {\n      return this._latlngs.push(o.latLng(t)), this.redraw();\n    },\n    spliceLatLngs: function spliceLatLngs() {\n      var t = [].splice.apply(this._latlngs, arguments);\n      return this._convertLatLngs(this._latlngs, !0), this.redraw(), t;\n    },\n    closestLayerPoint: function closestLayerPoint(t) {\n      for (var e, i, n = 1 / 0, s = this._parts, a = null, r = 0, h = s.length; h > r; r++) {\n        for (var l = s[r], u = 1, c = l.length; c > u; u++) {\n          e = l[u - 1], i = l[u];\n\n          var d = o.LineUtil._sqClosestPointOnSegment(t, e, i, !0);\n\n          n > d && (n = d, a = o.LineUtil._sqClosestPointOnSegment(t, e, i));\n        }\n      }\n\n      return a && (a.distance = Math.sqrt(n)), a;\n    },\n    getBounds: function getBounds() {\n      return new o.LatLngBounds(this.getLatLngs());\n    },\n    _convertLatLngs: function _convertLatLngs(t, e) {\n      var i,\n          n,\n          s = e ? t : [];\n\n      for (i = 0, n = t.length; n > i; i++) {\n        if (o.Util.isArray(t[i]) && "number" != typeof t[i][0]) return;\n        s[i] = o.latLng(t[i]);\n      }\n\n      return s;\n    },\n    _initEvents: function _initEvents() {\n      o.Path.prototype._initEvents.call(this);\n    },\n    _getPathPartStr: function _getPathPartStr(t) {\n      for (var e, i = o.Path.VML, n = 0, s = t.length, a = ""; s > n; n++) {\n        e = t[n], i && e._round(), a += (n ? "L" : "M") + e.x + " " + e.y;\n      }\n\n      return a;\n    },\n    _clipPoints: function _clipPoints() {\n      var t,\n          e,\n          i,\n          n = this._originalPoints,\n          s = n.length;\n      if (this.options.noClip) return void (this._parts = [n]);\n      this._parts = [];\n      var a = this._parts,\n          r = this._map._pathViewport,\n          h = o.LineUtil;\n\n      for (t = 0, e = 0; s - 1 > t; t++) {\n        i = h.clipSegment(n[t], n[t + 1], r, t), i && (a[e] = a[e] || [], a[e].push(i[0]), (i[1] !== n[t + 1] || t === s - 2) && (a[e].push(i[1]), e++));\n      }\n    },\n    _simplifyPoints: function _simplifyPoints() {\n      for (var t = this._parts, e = o.LineUtil, i = 0, n = t.length; n > i; i++) {\n        t[i] = e.simplify(t[i], this.options.smoothFactor);\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._map && (this._clipPoints(), this._simplifyPoints(), o.Path.prototype._updatePath.call(this));\n    }\n  }), o.polyline = function (t, e) {\n    return new o.Polyline(t, e);\n  }, o.PolyUtil = {}, o.PolyUtil.clipPolygon = function (t, e) {\n    var i,\n        n,\n        s,\n        a,\n        r,\n        h,\n        l,\n        u,\n        c,\n        d = [1, 4, 2, 8],\n        p = o.LineUtil;\n\n    for (n = 0, l = t.length; l > n; n++) {\n      t[n]._code = p._getBitCode(t[n], e);\n    }\n\n    for (a = 0; 4 > a; a++) {\n      for (u = d[a], i = [], n = 0, l = t.length, s = l - 1; l > n; s = n++) {\n        r = t[n], h = t[s], r._code & u ? h._code & u || (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)) : (h._code & u && (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)), i.push(r));\n      }\n\n      t = i;\n    }\n\n    return t;\n  }, o.Polygon = o.Polyline.extend({\n    options: {\n      fill: !0\n    },\n    initialize: function initialize(t, e) {\n      o.Polyline.prototype.initialize.call(this, t, e), this._initWithHoles(t);\n    },\n    _initWithHoles: function _initWithHoles(t) {\n      var e, i, n;\n      if (t && o.Util.isArray(t[0]) && "number" != typeof t[0][0]) for (this._latlngs = this._convertLatLngs(t[0]), this._holes = t.slice(1), e = 0, i = this._holes.length; i > e; e++) {\n        n = this._holes[e] = this._convertLatLngs(this._holes[e]), n[0].equals(n[n.length - 1]) && n.pop();\n      }\n      t = this._latlngs, t.length >= 2 && t[0].equals(t[t.length - 1]) && t.pop();\n    },\n    projectLatlngs: function projectLatlngs() {\n      if (o.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {\n        var t, e, i, n;\n\n        for (t = 0, i = this._holes.length; i > t; t++) {\n          for (this._holePoints[t] = [], e = 0, n = this._holes[t].length; n > e; e++) {\n            this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e]);\n          }\n        }\n      }\n    },\n    setLatLngs: function setLatLngs(t) {\n      return t && o.Util.isArray(t[0]) && "number" != typeof t[0][0] ? (this._initWithHoles(t), this.redraw()) : o.Polyline.prototype.setLatLngs.call(this, t);\n    },\n    _clipPoints: function _clipPoints() {\n      var t = this._originalPoints,\n          e = [];\n\n      if (this._parts = [t].concat(this._holePoints), !this.options.noClip) {\n        for (var i = 0, n = this._parts.length; n > i; i++) {\n          var s = o.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\n          s.length && e.push(s);\n        }\n\n        this._parts = e;\n      }\n    },\n    _getPathPartStr: function _getPathPartStr(t) {\n      var e = o.Polyline.prototype._getPathPartStr.call(this, t);\n\n      return e + (o.Browser.svg ? "z" : "x");\n    }\n  }), o.polygon = function (t, e) {\n    return new o.Polygon(t, e);\n  }, function () {\n    function t(t) {\n      return o.FeatureGroup.extend({\n        initialize: function initialize(t, e) {\n          this._layers = {}, this._options = e, this.setLatLngs(t);\n        },\n        setLatLngs: function setLatLngs(e) {\n          var i = 0,\n              n = e.length;\n\n          for (this.eachLayer(function (t) {\n            n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t);\n          }, this); n > i;) {\n            this.addLayer(new t(e[i++], this._options));\n          }\n\n          return this;\n        },\n        getLatLngs: function getLatLngs() {\n          var t = [];\n          return this.eachLayer(function (e) {\n            t.push(e.getLatLngs());\n          }), t;\n        }\n      });\n    }\n\n    o.MultiPolyline = t(o.Polyline), o.MultiPolygon = t(o.Polygon), o.multiPolyline = function (t, e) {\n      return new o.MultiPolyline(t, e);\n    }, o.multiPolygon = function (t, e) {\n      return new o.MultiPolygon(t, e);\n    };\n  }(), o.Rectangle = o.Polygon.extend({\n    initialize: function initialize(t, e) {\n      o.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e);\n    },\n    setBounds: function setBounds(t) {\n      this.setLatLngs(this._boundsToLatLngs(t));\n    },\n    _boundsToLatLngs: function _boundsToLatLngs(t) {\n      return t = o.latLngBounds(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()];\n    }\n  }), o.rectangle = function (t, e) {\n    return new o.Rectangle(t, e);\n  }, o.Circle = o.Path.extend({\n    initialize: function initialize(t, e, i) {\n      o.Path.prototype.initialize.call(this, i), this._latlng = o.latLng(t), this._mRadius = e;\n    },\n    options: {\n      fill: !0\n    },\n    setLatLng: function setLatLng(t) {\n      return this._latlng = o.latLng(t), this.redraw();\n    },\n    setRadius: function setRadius(t) {\n      return this._mRadius = t, this.redraw();\n    },\n    projectLatlngs: function projectLatlngs() {\n      var t = this._getLngRadius(),\n          e = this._latlng,\n          i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);\n\n      this._point = this._map.latLngToLayerPoint(e), this._radius = Math.max(this._point.x - i.x, 1);\n    },\n    getBounds: function getBounds() {\n      var t = this._getLngRadius(),\n          e = this._mRadius / 40075017 * 360,\n          i = this._latlng;\n\n      return new o.LatLngBounds([i.lat - e, i.lng - t], [i.lat + e, i.lng + t]);\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    getPathString: function getPathString() {\n      var t = this._point,\n          e = this._radius;\n      return this._checkIfEmpty() ? "" : o.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - .1) + "," + (t.y - e) + " z" : (t._round(), e = Math.round(e), "AL " + t.x + "," + t.y + " " + e + "," + e + " 0,23592600");\n    },\n    getRadius: function getRadius() {\n      return this._mRadius;\n    },\n    _getLatRadius: function _getLatRadius() {\n      return this._mRadius / 40075017 * 360;\n    },\n    _getLngRadius: function _getLngRadius() {\n      return this._getLatRadius() / Math.cos(o.LatLng.DEG_TO_RAD * this._latlng.lat);\n    },\n    _checkIfEmpty: function _checkIfEmpty() {\n      if (!this._map) return !1;\n      var t = this._map._pathViewport,\n          e = this._radius,\n          i = this._point;\n      return i.x - e > t.max.x || i.y - e > t.max.y || i.x + e < t.min.x || i.y + e < t.min.y;\n    }\n  }), o.circle = function (t, e, i) {\n    return new o.Circle(t, e, i);\n  }, o.CircleMarker = o.Circle.extend({\n    options: {\n      radius: 10,\n      weight: 2\n    },\n    initialize: function initialize(t, e) {\n      o.Circle.prototype.initialize.call(this, t, null, e), this._radius = this.options.radius;\n    },\n    projectLatlngs: function projectLatlngs() {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n    },\n    _updateStyle: function _updateStyle() {\n      o.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius);\n    },\n    setLatLng: function setLatLng(t) {\n      return o.Circle.prototype.setLatLng.call(this, t), this._popup && this._popup._isOpen && this._popup.setLatLng(t), this;\n    },\n    setRadius: function setRadius(t) {\n      return this.options.radius = this._radius = t, this.redraw();\n    },\n    getRadius: function getRadius() {\n      return this._radius;\n    }\n  }), o.circleMarker = function (t, e) {\n    return new o.CircleMarker(t, e);\n  }, o.Polyline.include(o.Path.CANVAS ? {\n    _containsPoint: function _containsPoint(t, e) {\n      var i,\n          n,\n          s,\n          a,\n          r,\n          h,\n          l,\n          u = this.options.weight / 2;\n\n      for (o.Browser.touch && (u += 10), i = 0, a = this._parts.length; a > i; i++) {\n        for (l = this._parts[i], n = 0, r = l.length, s = r - 1; r > n; s = n++) {\n          if ((e || 0 !== n) && (h = o.LineUtil.pointToSegmentDistance(t, l[s], l[n]), u >= h)) return !0;\n        }\n      }\n\n      return !1;\n    }\n  } : {}), o.Polygon.include(o.Path.CANVAS ? {\n    _containsPoint: function _containsPoint(t) {\n      var e,\n          i,\n          n,\n          s,\n          a,\n          r,\n          h,\n          l,\n          u = !1;\n      if (o.Polyline.prototype._containsPoint.call(this, t, !0)) return !0;\n\n      for (s = 0, h = this._parts.length; h > s; s++) {\n        for (e = this._parts[s], a = 0, l = e.length, r = l - 1; l > a; r = a++) {\n          i = e[a], n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u);\n        }\n      }\n\n      return u;\n    }\n  } : {}), o.Circle.include(o.Path.CANVAS ? {\n    _drawPath: function _drawPath() {\n      var t = this._point;\n      this._ctx.beginPath(), this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1);\n    },\n    _containsPoint: function _containsPoint(t) {\n      var e = this._point,\n          i = this.options.stroke ? this.options.weight / 2 : 0;\n      return t.distanceTo(e) <= this._radius + i;\n    }\n  } : {}), o.CircleMarker.include(o.Path.CANVAS ? {\n    _updateStyle: function _updateStyle() {\n      o.Path.prototype._updateStyle.call(this);\n    }\n  } : {}), o.GeoJSON = o.FeatureGroup.extend({\n    initialize: function initialize(t, e) {\n      o.setOptions(this, e), this._layers = {}, t && this.addData(t);\n    },\n    addData: function addData(t) {\n      var e,\n          i,\n          n,\n          s = o.Util.isArray(t) ? t : t.features;\n\n      if (s) {\n        for (e = 0, i = s.length; i > e; e++) {\n          n = s[e], (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(s[e]);\n        }\n\n        return this;\n      }\n\n      var a = this.options;\n\n      if (!a.filter || a.filter(t)) {\n        var r = o.GeoJSON.geometryToLayer(t, a.pointToLayer, a.coordsToLatLng, a);\n        return r.feature = o.GeoJSON.asFeature(t), r.defaultOptions = r.options, this.resetStyle(r), a.onEachFeature && a.onEachFeature(t, r), this.addLayer(r);\n      }\n    },\n    resetStyle: function resetStyle(t) {\n      var e = this.options.style;\n      e && (o.Util.extend(t.options, t.defaultOptions), this._setLayerStyle(t, e));\n    },\n    setStyle: function setStyle(t) {\n      this.eachLayer(function (e) {\n        this._setLayerStyle(e, t);\n      }, this);\n    },\n    _setLayerStyle: function _setLayerStyle(t, e) {\n      "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e);\n    }\n  }), o.extend(o.GeoJSON, {\n    geometryToLayer: function geometryToLayer(t, e, i, n) {\n      var s,\n          a,\n          r,\n          h,\n          l = "Feature" === t.type ? t.geometry : t,\n          u = l.coordinates,\n          c = [];\n\n      switch (i = i || this.coordsToLatLng, l.type) {\n        case "Point":\n          return s = i(u), e ? e(t, s) : new o.Marker(s);\n\n        case "MultiPoint":\n          for (r = 0, h = u.length; h > r; r++) {\n            s = i(u[r]), c.push(e ? e(t, s) : new o.Marker(s));\n          }\n\n          return new o.FeatureGroup(c);\n\n        case "LineString":\n          return a = this.coordsToLatLngs(u, 0, i), new o.Polyline(a, n);\n\n        case "Polygon":\n          if (2 === u.length && !u[1].length) throw new Error("Invalid GeoJSON object.");\n          return a = this.coordsToLatLngs(u, 1, i), new o.Polygon(a, n);\n\n        case "MultiLineString":\n          return a = this.coordsToLatLngs(u, 1, i), new o.MultiPolyline(a, n);\n\n        case "MultiPolygon":\n          return a = this.coordsToLatLngs(u, 2, i), new o.MultiPolygon(a, n);\n\n        case "GeometryCollection":\n          for (r = 0, h = l.geometries.length; h > r; r++) {\n            c.push(this.geometryToLayer({\n              geometry: l.geometries[r],\n              type: "Feature",\n              properties: t.properties\n            }, e, i, n));\n          }\n\n          return new o.FeatureGroup(c);\n\n        default:\n          throw new Error("Invalid GeoJSON object.");\n      }\n    },\n    coordsToLatLng: function coordsToLatLng(t) {\n      return new o.LatLng(t[1], t[0], t[2]);\n    },\n    coordsToLatLngs: function coordsToLatLngs(t, e, i) {\n      var n,\n          o,\n          s,\n          a = [];\n\n      for (o = 0, s = t.length; s > o; o++) {\n        n = e ? this.coordsToLatLngs(t[o], e - 1, i) : (i || this.coordsToLatLng)(t[o]), a.push(n);\n      }\n\n      return a;\n    },\n    latLngToCoords: function latLngToCoords(t) {\n      var e = [t.lng, t.lat];\n      return t.alt !== i && e.push(t.alt), e;\n    },\n    latLngsToCoords: function latLngsToCoords(t) {\n      for (var e = [], i = 0, n = t.length; n > i; i++) {\n        e.push(o.GeoJSON.latLngToCoords(t[i]));\n      }\n\n      return e;\n    },\n    getFeature: function getFeature(t, e) {\n      return t.feature ? o.extend({}, t.feature, {\n        geometry: e\n      }) : o.GeoJSON.asFeature(e);\n    },\n    asFeature: function asFeature(t) {\n      return "Feature" === t.type ? t : {\n        type: "Feature",\n        properties: {},\n        geometry: t\n      };\n    }\n  });\n  var a = {\n    toGeoJSON: function toGeoJSON() {\n      return o.GeoJSON.getFeature(this, {\n        type: "Point",\n        coordinates: o.GeoJSON.latLngToCoords(this.getLatLng())\n      });\n    }\n  };\n  o.Marker.include(a), o.Circle.include(a), o.CircleMarker.include(a), o.Polyline.include({\n    toGeoJSON: function toGeoJSON() {\n      return o.GeoJSON.getFeature(this, {\n        type: "LineString",\n        coordinates: o.GeoJSON.latLngsToCoords(this.getLatLngs())\n      });\n    }\n  }), o.Polygon.include({\n    toGeoJSON: function toGeoJSON() {\n      var t,\n          e,\n          i,\n          n = [o.GeoJSON.latLngsToCoords(this.getLatLngs())];\n      if (n[0].push(n[0][0]), this._holes) for (t = 0, e = this._holes.length; e > t; t++) {\n        i = o.GeoJSON.latLngsToCoords(this._holes[t]), i.push(i[0]), n.push(i);\n      }\n      return o.GeoJSON.getFeature(this, {\n        type: "Polygon",\n        coordinates: n\n      });\n    }\n  }), function () {\n    function t(t) {\n      return function () {\n        var e = [];\n        return this.eachLayer(function (t) {\n          e.push(t.toGeoJSON().geometry.coordinates);\n        }), o.GeoJSON.getFeature(this, {\n          type: t,\n          coordinates: e\n        });\n      };\n    }\n\n    o.MultiPolyline.include({\n      toGeoJSON: t("MultiLineString")\n    }), o.MultiPolygon.include({\n      toGeoJSON: t("MultiPolygon")\n    }), o.LayerGroup.include({\n      toGeoJSON: function toGeoJSON() {\n        var e,\n            i = this.feature && this.feature.geometry,\n            n = [];\n        if (i && "MultiPoint" === i.type) return t("MultiPoint").call(this);\n        var s = i && "GeometryCollection" === i.type;\n        return this.eachLayer(function (t) {\n          t.toGeoJSON && (e = t.toGeoJSON(), n.push(s ? e.geometry : o.GeoJSON.asFeature(e)));\n        }), s ? o.GeoJSON.getFeature(this, {\n          geometries: n,\n          type: "GeometryCollection"\n        }) : {\n          type: "FeatureCollection",\n          features: n\n        };\n      }\n    });\n  }(), o.geoJson = function (t, e) {\n    return new o.GeoJSON(t, e);\n  }, o.DomEvent = {\n    addListener: function addListener(t, e, i, n) {\n      var s,\n          a,\n          r,\n          h = o.stamp(i),\n          l = "_leaflet_" + e + h;\n      return t[l] ? this : (s = function s(e) {\n        return i.call(n || t, e || o.DomEvent._getEvent());\n      }, o.Browser.pointer && 0 === e.indexOf("touch") ? this.addPointerListener(t, e, s, h) : (o.Browser.touch && "dblclick" === e && this.addDoubleTapListener && this.addDoubleTapListener(t, s, h), "addEventListener" in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", s, !1), t.addEventListener(e, s, !1)) : "mouseenter" === e || "mouseleave" === e ? (a = s, r = "mouseenter" === e ? "mouseover" : "mouseout", s = function s(e) {\n        return o.DomEvent._checkMouse(t, e) ? a(e) : void 0;\n      }, t.addEventListener(r, s, !1)) : "click" === e && o.Browser.android ? (a = s, s = function s(t) {\n        return o.DomEvent._filterClick(t, a);\n      }, t.addEventListener(e, s, !1)) : t.addEventListener(e, s, !1) : "attachEvent" in t && t.attachEvent("on" + e, s), t[l] = s, this));\n    },\n    removeListener: function removeListener(t, e, i) {\n      var n = o.stamp(i),\n          s = "_leaflet_" + e + n,\n          a = t[s];\n      return a ? (o.Browser.pointer && 0 === e.indexOf("touch") ? this.removePointerListener(t, e, n) : o.Browser.touch && "dblclick" === e && this.removeDoubleTapListener ? this.removeDoubleTapListener(t, n) : "removeEventListener" in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", a, !1), t.removeEventListener(e, a, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", a, !1) : t.removeEventListener(e, a, !1) : "detachEvent" in t && t.detachEvent("on" + e, a), t[s] = null, this) : this;\n    },\n    stopPropagation: function stopPropagation(t) {\n      return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, o.DomEvent._skipped(t), this;\n    },\n    disableScrollPropagation: function disableScrollPropagation(t) {\n      var e = o.DomEvent.stopPropagation;\n      return o.DomEvent.on(t, "mousewheel", e).on(t, "MozMousePixelScroll", e);\n    },\n    disableClickPropagation: function disableClickPropagation(t) {\n      for (var e = o.DomEvent.stopPropagation, i = o.Draggable.START.length - 1; i >= 0; i--) {\n        o.DomEvent.on(t, o.Draggable.START[i], e);\n      }\n\n      return o.DomEvent.on(t, "click", o.DomEvent._fakeStop).on(t, "dblclick", e);\n    },\n    preventDefault: function preventDefault(t) {\n      return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;\n    },\n    stop: function stop(t) {\n      return o.DomEvent.preventDefault(t).stopPropagation(t);\n    },\n    getMousePosition: function getMousePosition(t, e) {\n      if (!e) return new o.Point(t.clientX, t.clientY);\n      var i = e.getBoundingClientRect();\n      return new o.Point(t.clientX - i.left - e.clientLeft, t.clientY - i.top - e.clientTop);\n    },\n    getWheelDelta: function getWheelDelta(t) {\n      var e = 0;\n      return t.wheelDelta && (e = t.wheelDelta / 120), t.detail && (e = -t.detail / 3), e;\n    },\n    _skipEvents: {},\n    _fakeStop: function _fakeStop(t) {\n      o.DomEvent._skipEvents[t.type] = !0;\n    },\n    _skipped: function _skipped(t) {\n      var e = this._skipEvents[t.type];\n      return this._skipEvents[t.type] = !1, e;\n    },\n    _checkMouse: function _checkMouse(t, e) {\n      var i = e.relatedTarget;\n      if (!i) return !0;\n\n      try {\n        for (; i && i !== t;) {\n          i = i.parentNode;\n        }\n      } catch (n) {\n        return !1;\n      }\n\n      return i !== t;\n    },\n    _getEvent: function _getEvent() {\n      var e = t.event;\n      if (!e) for (var i = arguments.callee.caller; i && (e = i.arguments[0], !e || t.Event !== e.constructor);) {\n        i = i.caller;\n      }\n      return e;\n    },\n    _filterClick: function _filterClick(t, e) {\n      var i = t.timeStamp || t.originalEvent.timeStamp,\n          n = o.DomEvent._lastClick && i - o.DomEvent._lastClick;\n      return n && n > 100 && 500 > n || t.target._simulatedClick && !t._simulated ? void o.DomEvent.stop(t) : (o.DomEvent._lastClick = i, e(t));\n    }\n  }, o.DomEvent.on = o.DomEvent.addListener, o.DomEvent.off = o.DomEvent.removeListener, o.Draggable = o.Class.extend({\n    includes: o.Mixin.Events,\n    statics: {\n      START: o.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],\n      END: {\n        mousedown: "mouseup",\n        touchstart: "touchend",\n        pointerdown: "touchend",\n        MSPointerDown: "touchend"\n      },\n      MOVE: {\n        mousedown: "mousemove",\n        touchstart: "touchmove",\n        pointerdown: "touchmove",\n        MSPointerDown: "touchmove"\n      }\n    },\n    initialize: function initialize(t, e) {\n      this._element = t, this._dragStartTarget = e || t;\n    },\n    enable: function enable() {\n      if (!this._enabled) {\n        for (var t = o.Draggable.START.length - 1; t >= 0; t--) {\n          o.DomEvent.on(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);\n        }\n\n        this._enabled = !0;\n      }\n    },\n    disable: function disable() {\n      if (this._enabled) {\n        for (var t = o.Draggable.START.length - 1; t >= 0; t--) {\n          o.DomEvent.off(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);\n        }\n\n        this._enabled = !1, this._moved = !1;\n      }\n    },\n    _onDown: function _onDown(t) {\n      if (this._moved = !1, !t.shiftKey && (1 === t.which || 1 === t.button || t.touches) && (o.DomEvent.stopPropagation(t), !o.Draggable._disabled && (o.DomUtil.disableImageDrag(), o.DomUtil.disableTextSelection(), !this._moving))) {\n        var i = t.touches ? t.touches[0] : t;\n        this._startPoint = new o.Point(i.clientX, i.clientY), this._startPos = this._newPos = o.DomUtil.getPosition(this._element), o.DomEvent.on(e, o.Draggable.MOVE[t.type], this._onMove, this).on(e, o.Draggable.END[t.type], this._onUp, this);\n      }\n    },\n    _onMove: function _onMove(t) {\n      if (t.touches && t.touches.length > 1) return void (this._moved = !0);\n      var i = t.touches && 1 === t.touches.length ? t.touches[0] : t,\n          n = new o.Point(i.clientX, i.clientY),\n          s = n.subtract(this._startPoint);\n      (s.x || s.y) && (o.Browser.touch && Math.abs(s.x) + Math.abs(s.y) < 3 || (o.DomEvent.preventDefault(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = o.DomUtil.getPosition(this._element).subtract(s), o.DomUtil.addClass(e.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, o.DomUtil.addClass(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(s), this._moving = !0, o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget)));\n    },\n    _updatePosition: function _updatePosition() {\n      this.fire("predrag"), o.DomUtil.setPosition(this._element, this._newPos), this.fire("drag");\n    },\n    _onUp: function _onUp() {\n      o.DomUtil.removeClass(e.body, "leaflet-dragging"), this._lastTarget && (o.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null);\n\n      for (var t in o.Draggable.MOVE) {\n        o.DomEvent.off(e, o.Draggable.MOVE[t], this._onMove).off(e, o.Draggable.END[t], this._onUp);\n      }\n\n      o.DomUtil.enableImageDrag(), o.DomUtil.enableTextSelection(), this._moved && this._moving && (o.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {\n        distance: this._newPos.distanceTo(this._startPos)\n      })), this._moving = !1;\n    }\n  }), o.Handler = o.Class.extend({\n    initialize: function initialize(t) {\n      this._map = t;\n    },\n    enable: function enable() {\n      this._enabled || (this._enabled = !0, this.addHooks());\n    },\n    disable: function disable() {\n      this._enabled && (this._enabled = !1, this.removeHooks());\n    },\n    enabled: function enabled() {\n      return !!this._enabled;\n    }\n  }), o.Map.mergeOptions({\n    dragging: !0,\n    inertia: !o.Browser.android23,\n    inertiaDeceleration: 3400,\n    inertiaMaxSpeed: 1 / 0,\n    inertiaThreshold: o.Browser.touch ? 32 : 18,\n    easeLinearity: .25,\n    worldCopyJump: !1\n  }), o.Map.Drag = o.Handler.extend({\n    addHooks: function addHooks() {\n      if (!this._draggable) {\n        var t = this._map;\n        this._draggable = new o.Draggable(t._mapPane, t._container), this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), t.on("viewreset", this._onViewReset, this), t.whenReady(this._onViewReset, this));\n      }\n\n      this._draggable.enable();\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.disable();\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _onDragStart: function _onDragStart() {\n      var t = this._map;\n      t._panAnim && t._panAnim.stop(), t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = []);\n    },\n    _onDrag: function _onDrag() {\n      if (this._map.options.inertia) {\n        var t = this._lastTime = +new Date(),\n            e = this._lastPos = this._draggable._newPos;\n        this._positions.push(e), this._times.push(t), t - this._times[0] > 200 && (this._positions.shift(), this._times.shift());\n      }\n\n      this._map.fire("move").fire("drag");\n    },\n    _onViewReset: function _onViewReset() {\n      var t = this._map.getSize()._divideBy(2),\n          e = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.project([0, 180]).x;\n    },\n    _onPreDrag: function _onPreDrag() {\n      var t = this._worldWidth,\n          e = Math.round(t / 2),\n          i = this._initialWorldOffset,\n          n = this._draggable._newPos.x,\n          o = (n - e + i) % t + e - i,\n          s = (n + e + i) % t - e - i,\n          a = Math.abs(o + i) < Math.abs(s + i) ? o : s;\n      this._draggable._newPos.x = a;\n    },\n    _onDragEnd: function _onDragEnd(t) {\n      var e = this._map,\n          i = e.options,\n          n = +new Date() - this._lastTime,\n          s = !i.inertia || n > i.inertiaThreshold || !this._positions[0];\n      if (e.fire("dragend", t), s) e.fire("moveend");else {\n        var a = this._lastPos.subtract(this._positions[0]),\n            r = (this._lastTime + n - this._times[0]) / 1e3,\n            h = i.easeLinearity,\n            l = a.multiplyBy(h / r),\n            u = l.distanceTo([0, 0]),\n            c = Math.min(i.inertiaMaxSpeed, u),\n            d = l.multiplyBy(c / u),\n            p = c / (i.inertiaDeceleration * h),\n            _ = d.multiplyBy(-p / 2).round();\n\n        _.x && _.y ? (_ = e._limitOffset(_, e.options.maxBounds), o.Util.requestAnimFrame(function () {\n          e.panBy(_, {\n            duration: p,\n            easeLinearity: h,\n            noMoveStart: !0\n          });\n        })) : e.fire("moveend");\n      }\n    }\n  }), o.Map.addInitHook("addHandler", "dragging", o.Map.Drag), o.Map.mergeOptions({\n    doubleClickZoom: !0\n  }), o.Map.DoubleClickZoom = o.Handler.extend({\n    addHooks: function addHooks() {\n      this._map.on("dblclick", this._onDoubleClick, this);\n    },\n    removeHooks: function removeHooks() {\n      this._map.off("dblclick", this._onDoubleClick, this);\n    },\n    _onDoubleClick: function _onDoubleClick(t) {\n      var e = this._map,\n          i = e.getZoom() + (t.originalEvent.shiftKey ? -1 : 1);\n      "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i);\n    }\n  }), o.Map.addInitHook("addHandler", "doubleClickZoom", o.Map.DoubleClickZoom), o.Map.mergeOptions({\n    scrollWheelZoom: !0\n  }), o.Map.ScrollWheelZoom = o.Handler.extend({\n    addHooks: function addHooks() {\n      o.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), o.DomEvent.on(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault), this._delta = 0;\n    },\n    removeHooks: function removeHooks() {\n      o.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll), o.DomEvent.off(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault);\n    },\n    _onWheelScroll: function _onWheelScroll(t) {\n      var e = o.DomEvent.getWheelDelta(t);\n      this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date());\n      var i = Math.max(40 - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer), this._timer = setTimeout(o.bind(this._performZoom, this), i), o.DomEvent.preventDefault(t), o.DomEvent.stopPropagation(t);\n    },\n    _performZoom: function _performZoom() {\n      var t = this._map,\n          e = this._delta,\n          i = t.getZoom();\n      e = e > 0 ? Math.ceil(e) : Math.floor(e), e = Math.max(Math.min(e, 4), -4), e = t._limitZoom(i + e) - i, this._delta = 0, this._startTime = null, e && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + e) : t.setZoomAround(this._lastMousePos, i + e));\n    }\n  }), o.Map.addInitHook("addHandler", "scrollWheelZoom", o.Map.ScrollWheelZoom), o.extend(o.DomEvent, {\n    _touchstart: o.Browser.msPointer ? "MSPointerDown" : o.Browser.pointer ? "pointerdown" : "touchstart",\n    _touchend: o.Browser.msPointer ? "MSPointerUp" : o.Browser.pointer ? "pointerup" : "touchend",\n    addDoubleTapListener: function addDoubleTapListener(t, i, n) {\n      function s(t) {\n        var e;\n\n        if (o.Browser.pointer ? (_.push(t.pointerId), e = _.length) : e = t.touches.length, !(e > 1)) {\n          var i = Date.now(),\n              n = i - (r || i);\n          h = t.touches ? t.touches[0] : t, l = n > 0 && u >= n, r = i;\n        }\n      }\n\n      function a(t) {\n        if (o.Browser.pointer) {\n          var e = _.indexOf(t.pointerId);\n\n          if (-1 === e) return;\n\n          _.splice(e, 1);\n        }\n\n        if (l) {\n          if (o.Browser.pointer) {\n            var n,\n                s = {};\n\n            for (var a in h) {\n              n = h[a], "function" == typeof n ? s[a] = n.bind(h) : s[a] = n;\n            }\n\n            h = s;\n          }\n\n          h.type = "dblclick", i(h), r = null;\n        }\n      }\n\n      var r,\n          h,\n          l = !1,\n          u = 250,\n          c = "_leaflet_",\n          d = this._touchstart,\n          p = this._touchend,\n          _ = [];\n      t[c + d + n] = s, t[c + p + n] = a;\n      var m = o.Browser.pointer ? e.documentElement : t;\n      return t.addEventListener(d, s, !1), m.addEventListener(p, a, !1), o.Browser.pointer && m.addEventListener(o.DomEvent.POINTER_CANCEL, a, !1), this;\n    },\n    removeDoubleTapListener: function removeDoubleTapListener(t, i) {\n      var n = "_leaflet_";\n      return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1), (o.Browser.pointer ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1), o.Browser.pointer && e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL, t[n + this._touchend + i], !1), this;\n    }\n  }), o.extend(o.DomEvent, {\n    POINTER_DOWN: o.Browser.msPointer ? "MSPointerDown" : "pointerdown",\n    POINTER_MOVE: o.Browser.msPointer ? "MSPointerMove" : "pointermove",\n    POINTER_UP: o.Browser.msPointer ? "MSPointerUp" : "pointerup",\n    POINTER_CANCEL: o.Browser.msPointer ? "MSPointerCancel" : "pointercancel",\n    _pointers: [],\n    _pointerDocumentListener: !1,\n    addPointerListener: function addPointerListener(t, e, i, n) {\n      switch (e) {\n        case "touchstart":\n          return this.addPointerListenerStart(t, e, i, n);\n\n        case "touchend":\n          return this.addPointerListenerEnd(t, e, i, n);\n\n        case "touchmove":\n          return this.addPointerListenerMove(t, e, i, n);\n\n        default:\n          throw "Unknown touch event type";\n      }\n    },\n    addPointerListenerStart: function addPointerListenerStart(t, i, n, s) {\n      var a = "_leaflet_",\n          r = this._pointers,\n          h = function h(t) {\n        "mouse" !== t.pointerType && t.pointerType !== t.MSPOINTER_TYPE_MOUSE && o.DomEvent.preventDefault(t);\n\n        for (var e = !1, i = 0; i < r.length; i++) {\n          if (r[i].pointerId === t.pointerId) {\n            e = !0;\n            break;\n          }\n        }\n\n        e || r.push(t), t.touches = r.slice(), t.changedTouches = [t], n(t);\n      };\n\n      if (t[a + "touchstart" + s] = h, t.addEventListener(this.POINTER_DOWN, h, !1), !this._pointerDocumentListener) {\n        var l = function l(t) {\n          for (var e = 0; e < r.length; e++) {\n            if (r[e].pointerId === t.pointerId) {\n              r.splice(e, 1);\n              break;\n            }\n          }\n        };\n\n        e.documentElement.addEventListener(this.POINTER_UP, l, !1), e.documentElement.addEventListener(this.POINTER_CANCEL, l, !1), this._pointerDocumentListener = !0;\n      }\n\n      return this;\n    },\n    addPointerListenerMove: function addPointerListenerMove(t, e, i, n) {\n      function o(t) {\n        if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) {\n          for (var e = 0; e < a.length; e++) {\n            if (a[e].pointerId === t.pointerId) {\n              a[e] = t;\n              break;\n            }\n          }\n\n          t.touches = a.slice(), t.changedTouches = [t], i(t);\n        }\n      }\n\n      var s = "_leaflet_",\n          a = this._pointers;\n      return t[s + "touchmove" + n] = o, t.addEventListener(this.POINTER_MOVE, o, !1), this;\n    },\n    addPointerListenerEnd: function addPointerListenerEnd(t, e, i, n) {\n      var o = "_leaflet_",\n          s = this._pointers,\n          a = function a(t) {\n        for (var e = 0; e < s.length; e++) {\n          if (s[e].pointerId === t.pointerId) {\n            s.splice(e, 1);\n            break;\n          }\n        }\n\n        t.touches = s.slice(), t.changedTouches = [t], i(t);\n      };\n\n      return t[o + "touchend" + n] = a, t.addEventListener(this.POINTER_UP, a, !1), t.addEventListener(this.POINTER_CANCEL, a, !1), this;\n    },\n    removePointerListener: function removePointerListener(t, e, i) {\n      var n = "_leaflet_",\n          o = t[n + e + i];\n\n      switch (e) {\n        case "touchstart":\n          t.removeEventListener(this.POINTER_DOWN, o, !1);\n          break;\n\n        case "touchmove":\n          t.removeEventListener(this.POINTER_MOVE, o, !1);\n          break;\n\n        case "touchend":\n          t.removeEventListener(this.POINTER_UP, o, !1), t.removeEventListener(this.POINTER_CANCEL, o, !1);\n      }\n\n      return this;\n    }\n  }), o.Map.mergeOptions({\n    touchZoom: o.Browser.touch && !o.Browser.android23,\n    bounceAtZoomLimits: !0\n  }), o.Map.TouchZoom = o.Handler.extend({\n    addHooks: function addHooks() {\n      o.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);\n    },\n    removeHooks: function removeHooks() {\n      o.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);\n    },\n    _onTouchStart: function _onTouchStart(t) {\n      var i = this._map;\n\n      if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {\n        var n = i.mouseEventToLayerPoint(t.touches[0]),\n            s = i.mouseEventToLayerPoint(t.touches[1]),\n            a = i._getCenterLayerPoint();\n\n        this._startCenter = n.add(s)._divideBy(2), this._startDist = n.distanceTo(s), this._moved = !1, this._zooming = !0, this._centerOffset = a.subtract(this._startCenter), i._panAnim && i._panAnim.stop(), o.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this), o.DomEvent.preventDefault(t);\n      }\n    },\n    _onTouchMove: function _onTouchMove(t) {\n      var e = this._map;\n\n      if (t.touches && 2 === t.touches.length && this._zooming) {\n        var i = e.mouseEventToLayerPoint(t.touches[0]),\n            n = e.mouseEventToLayerPoint(t.touches[1]);\n        this._scale = i.distanceTo(n) / this._startDist, this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && (e.options.bounceAtZoomLimits || !(e.getZoom() === e.getMinZoom() && this._scale < 1 || e.getZoom() === e.getMaxZoom() && this._scale > 1)) && (this._moved || (o.DomUtil.addClass(e._mapPane, "leaflet-touching"), e.fire("movestart").fire("zoomstart"), this._moved = !0), o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), o.DomEvent.preventDefault(t));\n      }\n    },\n    _updateOnMove: function _updateOnMove() {\n      var t = this._map,\n          e = this._getScaleOrigin(),\n          i = t.layerPointToLatLng(e),\n          n = t.getScaleZoom(this._scale);\n\n      t._animateZoom(i, n, this._startCenter, this._scale, this._delta, !1, !0);\n    },\n    _onTouchEnd: function _onTouchEnd() {\n      if (!this._moved || !this._zooming) return void (this._zooming = !1);\n      var t = this._map;\n      this._zooming = !1, o.DomUtil.removeClass(t._mapPane, "leaflet-touching"), o.Util.cancelAnimFrame(this._animRequest), o.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);\n\n      var i = this._getScaleOrigin(),\n          n = t.layerPointToLatLng(i),\n          s = t.getZoom(),\n          a = t.getScaleZoom(this._scale) - s,\n          r = a > 0 ? Math.ceil(a) : Math.floor(a),\n          h = t._limitZoom(s + r),\n          l = t.getZoomScale(h) / this._scale;\n\n      t._animateZoom(n, h, i, l);\n    },\n    _getScaleOrigin: function _getScaleOrigin() {\n      var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\n      return this._startCenter.add(t);\n    }\n  }), o.Map.addInitHook("addHandler", "touchZoom", o.Map.TouchZoom), o.Map.mergeOptions({\n    tap: !0,\n    tapTolerance: 15\n  }), o.Map.Tap = o.Handler.extend({\n    addHooks: function addHooks() {\n      o.DomEvent.on(this._map._container, "touchstart", this._onDown, this);\n    },\n    removeHooks: function removeHooks() {\n      o.DomEvent.off(this._map._container, "touchstart", this._onDown, this);\n    },\n    _onDown: function _onDown(t) {\n      if (t.touches) {\n        if (o.DomEvent.preventDefault(t), this._fireClick = !0, t.touches.length > 1) return this._fireClick = !1, void clearTimeout(this._holdTimeout);\n        var i = t.touches[0],\n            n = i.target;\n        this._startPos = this._newPos = new o.Point(i.clientX, i.clientY), n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active"), this._holdTimeout = setTimeout(o.bind(function () {\n          this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i));\n        }, this), 1e3), o.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this);\n      }\n    },\n    _onUp: function _onUp(t) {\n      if (clearTimeout(this._holdTimeout), o.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this), this._fireClick && t && t.changedTouches) {\n        var i = t.changedTouches[0],\n            n = i.target;\n        n && n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.removeClass(n, "leaflet-active"), this._isTapValid() && this._simulateEvent("click", i);\n      }\n    },\n    _isTapValid: function _isTapValid() {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function _onMove(t) {\n      var e = t.touches[0];\n      this._newPos = new o.Point(e.clientX, e.clientY);\n    },\n    _simulateEvent: function _simulateEvent(i, n) {\n      var o = e.createEvent("MouseEvents");\n      o._simulated = !0, n.target._simulatedClick = !0, o.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(o);\n    }\n  }), o.Browser.touch && !o.Browser.pointer && o.Map.addInitHook("addHandler", "tap", o.Map.Tap), o.Map.mergeOptions({\n    boxZoom: !0\n  }), o.Map.BoxZoom = o.Handler.extend({\n    initialize: function initialize(t) {\n      this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._moved = !1;\n    },\n    addHooks: function addHooks() {\n      o.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);\n    },\n    removeHooks: function removeHooks() {\n      o.DomEvent.off(this._container, "mousedown", this._onMouseDown), this._moved = !1;\n    },\n    moved: function moved() {\n      return this._moved;\n    },\n    _onMouseDown: function _onMouseDown(t) {\n      return this._moved = !1, !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (o.DomUtil.disableTextSelection(), o.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(t), void o.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this));\n    },\n    _onMouseMove: function _onMouseMove(t) {\n      this._moved || (this._box = o.DomUtil.create("div", "leaflet-zoom-box", this._pane), o.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));\n\n      var e = this._startLayerPoint,\n          i = this._box,\n          n = this._map.mouseEventToLayerPoint(t),\n          s = n.subtract(e),\n          a = new o.Point(Math.min(n.x, e.x), Math.min(n.y, e.y));\n\n      o.DomUtil.setPosition(i, a), this._moved = !0, i.style.width = Math.max(0, Math.abs(s.x) - 4) + "px", i.style.height = Math.max(0, Math.abs(s.y) - 4) + "px";\n    },\n    _finish: function _finish() {\n      this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = ""), o.DomUtil.enableTextSelection(), o.DomUtil.enableImageDrag(), o.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown);\n    },\n    _onMouseUp: function _onMouseUp(t) {\n      this._finish();\n\n      var e = this._map,\n          i = e.mouseEventToLayerPoint(t);\n\n      if (!this._startLayerPoint.equals(i)) {\n        var n = new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(i));\n        e.fitBounds(n), e.fire("boxzoomend", {\n          boxZoomBounds: n\n        });\n      }\n    },\n    _onKeyDown: function _onKeyDown(t) {\n      27 === t.keyCode && this._finish();\n    }\n  }), o.Map.addInitHook("addHandler", "boxZoom", o.Map.BoxZoom), o.Map.mergeOptions({\n    keyboard: !0,\n    keyboardPanOffset: 80,\n    keyboardZoomOffset: 1\n  }), o.Map.Keyboard = o.Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 173]\n    },\n    initialize: function initialize(t) {\n      this._map = t, this._setPanOffset(t.options.keyboardPanOffset), this._setZoomOffset(t.options.keyboardZoomOffset);\n    },\n    addHooks: function addHooks() {\n      var t = this._map._container;\n      -1 === t.tabIndex && (t.tabIndex = "0"), o.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this);\n    },\n    removeHooks: function removeHooks() {\n      this._removeHooks();\n\n      var t = this._map._container;\n      o.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this);\n    },\n    _onMouseDown: function _onMouseDown() {\n      if (!this._focused) {\n        var i = e.body,\n            n = e.documentElement,\n            o = i.scrollTop || n.scrollTop,\n            s = i.scrollLeft || n.scrollLeft;\n        this._map._container.focus(), t.scrollTo(s, o);\n      }\n    },\n    _onFocus: function _onFocus() {\n      this._focused = !0, this._map.fire("focus");\n    },\n    _onBlur: function _onBlur() {\n      this._focused = !1, this._map.fire("blur");\n    },\n    _setPanOffset: function _setPanOffset(t) {\n      var e,\n          i,\n          n = this._panKeys = {},\n          o = this.keyCodes;\n\n      for (e = 0, i = o.left.length; i > e; e++) {\n        n[o.left[e]] = [-1 * t, 0];\n      }\n\n      for (e = 0, i = o.right.length; i > e; e++) {\n        n[o.right[e]] = [t, 0];\n      }\n\n      for (e = 0, i = o.down.length; i > e; e++) {\n        n[o.down[e]] = [0, t];\n      }\n\n      for (e = 0, i = o.up.length; i > e; e++) {\n        n[o.up[e]] = [0, -1 * t];\n      }\n    },\n    _setZoomOffset: function _setZoomOffset(t) {\n      var e,\n          i,\n          n = this._zoomKeys = {},\n          o = this.keyCodes;\n\n      for (e = 0, i = o.zoomIn.length; i > e; e++) {\n        n[o.zoomIn[e]] = t;\n      }\n\n      for (e = 0, i = o.zoomOut.length; i > e; e++) {\n        n[o.zoomOut[e]] = -t;\n      }\n    },\n    _addHooks: function _addHooks() {\n      o.DomEvent.on(e, "keydown", this._onKeyDown, this);\n    },\n    _removeHooks: function _removeHooks() {\n      o.DomEvent.off(e, "keydown", this._onKeyDown, this);\n    },\n    _onKeyDown: function _onKeyDown(t) {\n      var e = t.keyCode,\n          i = this._map;\n\n      if (e in this._panKeys) {\n        if (i._panAnim && i._panAnim._inProgress) return;\n        i.panBy(this._panKeys[e]), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds);\n      } else {\n        if (!(e in this._zoomKeys)) return;\n        i.setZoom(i.getZoom() + this._zoomKeys[e]);\n      }\n\n      o.DomEvent.stop(t);\n    }\n  }), o.Map.addInitHook("addHandler", "keyboard", o.Map.Keyboard), o.Handler.MarkerDrag = o.Handler.extend({\n    initialize: function initialize(t) {\n      this._marker = t;\n    },\n    addHooks: function addHooks() {\n      var t = this._marker._icon;\n      this._draggable || (this._draggable = new o.Draggable(t, t)), this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this), this._draggable.enable(), o.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable");\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this), this._draggable.disable(), o.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable");\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _onDragStart: function _onDragStart() {\n      this._marker.closePopup().fire("movestart").fire("dragstart");\n    },\n    _onDrag: function _onDrag() {\n      var t = this._marker,\n          e = t._shadow,\n          i = o.DomUtil.getPosition(t._icon),\n          n = t._map.layerPointToLatLng(i);\n\n      e && o.DomUtil.setPosition(e, i), t._latlng = n, t.fire("move", {\n        latlng: n\n      }).fire("drag");\n    },\n    _onDragEnd: function _onDragEnd(t) {\n      this._marker.fire("moveend").fire("dragend", t);\n    }\n  }), o.Control = o.Class.extend({\n    options: {\n      position: "topright"\n    },\n    initialize: function initialize(t) {\n      o.setOptions(this, t);\n    },\n    getPosition: function getPosition() {\n      return this.options.position;\n    },\n    setPosition: function setPosition(t) {\n      var e = this._map;\n      return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    addTo: function addTo(t) {\n      this._map = t;\n      var e = this._container = this.onAdd(t),\n          i = this.getPosition(),\n          n = t._controlCorners[i];\n      return o.DomUtil.addClass(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this;\n    },\n    removeFrom: function removeFrom(t) {\n      var e = this.getPosition(),\n          i = t._controlCorners[e];\n      return i.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(t), this;\n    },\n    _refocusOnMap: function _refocusOnMap() {\n      this._map && this._map.getContainer().focus();\n    }\n  }), o.control = function (t) {\n    return new o.Control(t);\n  }, o.Map.include({\n    addControl: function addControl(t) {\n      return t.addTo(this), this;\n    },\n    removeControl: function removeControl(t) {\n      return t.removeFrom(this), this;\n    },\n    _initControlPos: function _initControlPos() {\n      function t(t, s) {\n        var a = i + t + " " + i + s;\n        e[t + s] = o.DomUtil.create("div", a, n);\n      }\n\n      var e = this._controlCorners = {},\n          i = "leaflet-",\n          n = this._controlContainer = o.DomUtil.create("div", i + "control-container", this._container);\n      t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right");\n    },\n    _clearControlPos: function _clearControlPos() {\n      this._container.removeChild(this._controlContainer);\n    }\n  }), o.Control.Zoom = o.Control.extend({\n    options: {\n      position: "topleft",\n      zoomInText: "+",\n      zoomInTitle: "Zoom in",\n      zoomOutText: "-",\n      zoomOutTitle: "Zoom out"\n    },\n    onAdd: function onAdd(t) {\n      var e = "leaflet-control-zoom",\n          i = o.DomUtil.create("div", e + " leaflet-bar");\n      return this._map = t, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, e + "-in", i, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, e + "-out", i, this._zoomOut, this), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i;\n    },\n    onRemove: function onRemove(t) {\n      t.off("zoomend zoomlevelschange", this._updateDisabled, this);\n    },\n    _zoomIn: function _zoomIn(t) {\n      this._map.zoomIn(t.shiftKey ? 3 : 1);\n    },\n    _zoomOut: function _zoomOut(t) {\n      this._map.zoomOut(t.shiftKey ? 3 : 1);\n    },\n    _createButton: function _createButton(t, e, i, n, s, a) {\n      var r = o.DomUtil.create("a", i, n);\n      r.innerHTML = t, r.href = "#", r.title = e;\n      var h = o.DomEvent.stopPropagation;\n      return o.DomEvent.on(r, "click", h).on(r, "mousedown", h).on(r, "dblclick", h).on(r, "click", o.DomEvent.preventDefault).on(r, "click", s, a).on(r, "click", this._refocusOnMap, a), r;\n    },\n    _updateDisabled: function _updateDisabled() {\n      var t = this._map,\n          e = "leaflet-disabled";\n      o.DomUtil.removeClass(this._zoomInButton, e), o.DomUtil.removeClass(this._zoomOutButton, e), t._zoom === t.getMinZoom() && o.DomUtil.addClass(this._zoomOutButton, e), t._zoom === t.getMaxZoom() && o.DomUtil.addClass(this._zoomInButton, e);\n    }\n  }), o.Map.mergeOptions({\n    zoomControl: !0\n  }), o.Map.addInitHook(function () {\n    this.options.zoomControl && (this.zoomControl = new o.Control.Zoom(), this.addControl(this.zoomControl));\n  }), o.control.zoom = function (t) {\n    return new o.Control.Zoom(t);\n  }, o.Control.Attribution = o.Control.extend({\n    options: {\n      position: "bottomright",\n      prefix: \'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>\'\n    },\n    initialize: function initialize(t) {\n      o.setOptions(this, t), this._attributions = {};\n    },\n    onAdd: function onAdd(t) {\n      this._container = o.DomUtil.create("div", "leaflet-control-attribution"), o.DomEvent.disableClickPropagation(this._container);\n\n      for (var e in t._layers) {\n        t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());\n      }\n\n      return t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container;\n    },\n    onRemove: function onRemove(t) {\n      t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove);\n    },\n    setPrefix: function setPrefix(t) {\n      return this.options.prefix = t, this._update(), this;\n    },\n    addAttribution: function addAttribution(t) {\n      return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : void 0;\n    },\n    removeAttribution: function removeAttribution(t) {\n      return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : void 0;\n    },\n    _update: function _update() {\n      if (this._map) {\n        var t = [];\n\n        for (var e in this._attributions) {\n          this._attributions[e] && t.push(e);\n        }\n\n        var i = [];\n        this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(" | ");\n      }\n    },\n    _onLayerAdd: function _onLayerAdd(t) {\n      t.layer.getAttribution && this.addAttribution(t.layer.getAttribution());\n    },\n    _onLayerRemove: function _onLayerRemove(t) {\n      t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution());\n    }\n  }), o.Map.mergeOptions({\n    attributionControl: !0\n  }), o.Map.addInitHook(function () {\n    this.options.attributionControl && (this.attributionControl = new o.Control.Attribution().addTo(this));\n  }), o.control.attribution = function (t) {\n    return new o.Control.Attribution(t);\n  }, o.Control.Scale = o.Control.extend({\n    options: {\n      position: "bottomleft",\n      maxWidth: 100,\n      metric: !0,\n      imperial: !0,\n      updateWhenIdle: !1\n    },\n    onAdd: function onAdd(t) {\n      this._map = t;\n      var e = "leaflet-control-scale",\n          i = o.DomUtil.create("div", e),\n          n = this.options;\n      return this._addScales(n, e, i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i;\n    },\n    onRemove: function onRemove(t) {\n      t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);\n    },\n    _addScales: function _addScales(t, e, i) {\n      t.metric && (this._mScale = o.DomUtil.create("div", e + "-line", i)), t.imperial && (this._iScale = o.DomUtil.create("div", e + "-line", i));\n    },\n    _update: function _update() {\n      var t = this._map.getBounds(),\n          e = t.getCenter().lat,\n          i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180),\n          n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180,\n          o = this._map.getSize(),\n          s = this.options,\n          a = 0;\n\n      o.x > 0 && (a = n * (s.maxWidth / o.x)), this._updateScales(s, a);\n    },\n    _updateScales: function _updateScales(t, e) {\n      t.metric && e && this._updateMetric(e), t.imperial && e && this._updateImperial(e);\n    },\n    _updateMetric: function _updateMetric(t) {\n      var e = this._getRoundNum(t);\n\n      this._mScale.style.width = this._getScaleWidth(e / t) + "px", this._mScale.innerHTML = 1e3 > e ? e + " m" : e / 1e3 + " km";\n    },\n    _updateImperial: function _updateImperial(t) {\n      var e,\n          i,\n          n,\n          o = 3.2808399 * t,\n          s = this._iScale;\n      o > 5280 ? (e = o / 5280, i = this._getRoundNum(e), s.style.width = this._getScaleWidth(i / e) + "px", s.innerHTML = i + " mi") : (n = this._getRoundNum(o), s.style.width = this._getScaleWidth(n / o) + "px", s.innerHTML = n + " ft");\n    },\n    _getScaleWidth: function _getScaleWidth(t) {\n      return Math.round(this.options.maxWidth * t) - 10;\n    },\n    _getRoundNum: function _getRoundNum(t) {\n      var e = Math.pow(10, (Math.floor(t) + "").length - 1),\n          i = t / e;\n      return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i;\n    }\n  }), o.control.scale = function (t) {\n    return new o.Control.Scale(t);\n  }, o.Control.Layers = o.Control.extend({\n    options: {\n      collapsed: !0,\n      position: "topright",\n      autoZIndex: !0\n    },\n    initialize: function initialize(t, e, i) {\n      o.setOptions(this, i), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;\n\n      for (var n in t) {\n        this._addLayer(t[n], n);\n      }\n\n      for (n in e) {\n        this._addLayer(e[n], n, !0);\n      }\n    },\n    onAdd: function onAdd(t) {\n      return this._initLayout(), this._update(), t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container;\n    },\n    onRemove: function onRemove(t) {\n      t.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this);\n    },\n    addBaseLayer: function addBaseLayer(t, e) {\n      return this._addLayer(t, e), this._update(), this;\n    },\n    addOverlay: function addOverlay(t, e) {\n      return this._addLayer(t, e, !0), this._update(), this;\n    },\n    removeLayer: function removeLayer(t) {\n      var e = o.stamp(t);\n      return delete this._layers[e], this._update(), this;\n    },\n    _initLayout: function _initLayout() {\n      var t = "leaflet-control-layers",\n          e = this._container = o.DomUtil.create("div", t);\n      e.setAttribute("aria-haspopup", !0), o.Browser.touch ? o.DomEvent.on(e, "click", o.DomEvent.stopPropagation) : o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);\n      var i = this._form = o.DomUtil.create("form", t + "-list");\n\n      if (this.options.collapsed) {\n        o.Browser.android || o.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);\n        var n = this._layersLink = o.DomUtil.create("a", t + "-toggle", e);\n        n.href = "#", n.title = "Layers", o.Browser.touch ? o.DomEvent.on(n, "click", o.DomEvent.stop).on(n, "click", this._expand, this) : o.DomEvent.on(n, "focus", this._expand, this), o.DomEvent.on(i, "click", function () {\n          setTimeout(o.bind(this._onInputClick, this), 0);\n        }, this), this._map.on("click", this._collapse, this);\n      } else this._expand();\n\n      this._baseLayersList = o.DomUtil.create("div", t + "-base", i), this._separator = o.DomUtil.create("div", t + "-separator", i), this._overlaysList = o.DomUtil.create("div", t + "-overlays", i), e.appendChild(i);\n    },\n    _addLayer: function _addLayer(t, e, i) {\n      var n = o.stamp(t);\n      this._layers[n] = {\n        layer: t,\n        name: e,\n        overlay: i\n      }, this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex));\n    },\n    _update: function _update() {\n      if (this._container) {\n        this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";\n        var t,\n            e,\n            i = !1,\n            n = !1;\n\n        for (t in this._layers) {\n          e = this._layers[t], this._addItem(e), n = n || e.overlay, i = i || !e.overlay;\n        }\n\n        this._separator.style.display = n && i ? "" : "none";\n      }\n    },\n    _onLayerChange: function _onLayerChange(t) {\n      var e = this._layers[o.stamp(t.layer)];\n\n      if (e) {\n        this._handlingClick || this._update();\n        var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;\n        i && this._map.fire(i, e);\n      }\n    },\n    _createRadioElement: function _createRadioElement(t, i) {\n      var n = \'<input type="radio" class="leaflet-control-layers-selector" name="\' + t + \'"\';\n      i && (n += \' checked="checked"\'), n += "/>";\n      var o = e.createElement("div");\n      return o.innerHTML = n, o.firstChild;\n    },\n    _addItem: function _addItem(t) {\n      var i,\n          n = e.createElement("label"),\n          s = this._map.hasLayer(t.layer);\n\n      t.overlay ? (i = e.createElement("input"), i.type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked = s) : i = this._createRadioElement("leaflet-base-layers", s), i.layerId = o.stamp(t.layer), o.DomEvent.on(i, "click", this._onInputClick, this);\n      var a = e.createElement("span");\n      a.innerHTML = " " + t.name, n.appendChild(i), n.appendChild(a);\n      var r = t.overlay ? this._overlaysList : this._baseLayersList;\n      return r.appendChild(n), n;\n    },\n    _onInputClick: function _onInputClick() {\n      var t,\n          e,\n          i,\n          n = this._form.getElementsByTagName("input"),\n          o = n.length;\n\n      for (this._handlingClick = !0, t = 0; o > t; t++) {\n        e = n[t], i = this._layers[e.layerId], e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer);\n      }\n\n      this._handlingClick = !1, this._refocusOnMap();\n    },\n    _expand: function _expand() {\n      o.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");\n    },\n    _collapse: function _collapse() {\n      this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");\n    }\n  }), o.control.layers = function (t, e, i) {\n    return new o.Control.Layers(t, e, i);\n  }, o.PosAnimation = o.Class.extend({\n    includes: o.Mixin.Events,\n    run: function run(t, e, i, n) {\n      this.stop(), this._el = t, this._inProgress = !0, this._newPos = e, this.fire("start"), t.style[o.DomUtil.TRANSITION] = "all " + (i || .25) + "s cubic-bezier(0,0," + (n || .5) + ",1)", o.DomEvent.on(t, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), o.DomUtil.setPosition(t, e), o.Util.falseFn(t.offsetWidth), this._stepTimer = setInterval(o.bind(this._onStep, this), 50);\n    },\n    stop: function stop() {\n      this._inProgress && (o.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), o.Util.falseFn(this._el.offsetWidth));\n    },\n    _onStep: function _onStep() {\n      var t = this._getPos();\n\n      return t ? (this._el._leaflet_pos = t, void this.fire("step")) : void this._onTransitionEnd();\n    },\n    _transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n    _getPos: function _getPos() {\n      var e,\n          i,\n          n,\n          s = this._el,\n          a = t.getComputedStyle(s);\n\n      if (o.Browser.any3d) {\n        if (n = a[o.DomUtil.TRANSFORM].match(this._transformRe), !n) return;\n        e = parseFloat(n[1]), i = parseFloat(n[2]);\n      } else e = parseFloat(a.left), i = parseFloat(a.top);\n\n      return new o.Point(e, i, !0);\n    },\n    _onTransitionEnd: function _onTransitionEnd() {\n      o.DomEvent.off(this._el, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[o.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"));\n    }\n  }), o.Map.include({\n    setView: function setView(t, e, n) {\n      if (e = e === i ? this._zoom : this._limitZoom(e), t = this._limitCenter(o.latLng(t), e, this.options.maxBounds), n = n || {}, this._panAnim && this._panAnim.stop(), this._loaded && !n.reset && n !== !0) {\n        n.animate !== i && (n.zoom = o.extend({\n          animate: n.animate\n        }, n.zoom), n.pan = o.extend({\n          animate: n.animate\n        }, n.pan));\n        var s = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);\n        if (s) return clearTimeout(this._sizeTimer), this;\n      }\n\n      return this._resetView(t, e), this;\n    },\n    panBy: function panBy(t, e) {\n      if (t = o.point(t).round(), e = e || {}, !t.x && !t.y) return this;\n\n      if (this._panAnim || (this._panAnim = new o.PosAnimation(), this._panAnim.on({\n        step: this._onPanTransitionStep,\n        end: this._onPanTransitionEnd\n      }, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {\n        o.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");\n\n        var i = this._getMapPanePos().subtract(t);\n\n        this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity);\n      } else this._rawPanBy(t), this.fire("move").fire("moveend");\n\n      return this;\n    },\n    _onPanTransitionStep: function _onPanTransitionStep() {\n      this.fire("move");\n    },\n    _onPanTransitionEnd: function _onPanTransitionEnd() {\n      o.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");\n    },\n    _tryAnimatedPan: function _tryAnimatedPan(t, e) {\n      var i = this._getCenterOffset(t)._floor();\n\n      return (e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e), !0) : !1;\n    }\n  }), o.PosAnimation = o.DomUtil.TRANSITION ? o.PosAnimation : o.PosAnimation.extend({\n    run: function run(t, e, i, n) {\n      this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = o.DomUtil.getPosition(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date(), this.fire("start"), this._animate();\n    },\n    stop: function stop() {\n      this._inProgress && (this._step(), this._complete());\n    },\n    _animate: function _animate() {\n      this._animId = o.Util.requestAnimFrame(this._animate, this), this._step();\n    },\n    _step: function _step() {\n      var t = +new Date() - this._startTime,\n          e = 1e3 * this._duration;\n      e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1), this._complete());\n    },\n    _runFrame: function _runFrame(t) {\n      var e = this._startPos.add(this._offset.multiplyBy(t));\n\n      o.DomUtil.setPosition(this._el, e), this.fire("step");\n    },\n    _complete: function _complete() {\n      o.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end");\n    },\n    _easeOut: function _easeOut(t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  }), o.Map.mergeOptions({\n    zoomAnimation: !0,\n    zoomAnimationThreshold: 4\n  }), o.DomUtil.TRANSITION && o.Map.addInitHook(function () {\n    this._zoomAnimated = this.options.zoomAnimation && o.DomUtil.TRANSITION && o.Browser.any3d && !o.Browser.android23 && !o.Browser.mobileOpera, this._zoomAnimated && o.DomEvent.on(this._mapPane, o.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n  }), o.Map.include(o.DomUtil.TRANSITION ? {\n    _catchTransitionEnd: function _catchTransitionEnd(t) {\n      this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();\n    },\n    _nothingToAnimate: function _nothingToAnimate() {\n      return !this._container.getElementsByClassName("leaflet-zoom-animated").length;\n    },\n    _tryAnimatedZoom: function _tryAnimatedZoom(t, e, i) {\n      if (this._animatingZoom) return !0;\n      if (i = i || {}, !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1;\n\n      var n = this.getZoomScale(e),\n          o = this._getCenterOffset(t)._divideBy(1 - 1 / n),\n          s = this._getCenterLayerPoint()._add(o);\n\n      return i.animate === !0 || this.getSize().contains(o) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(t, e, s, n, null, !0), !0) : !1;\n    },\n    _animateZoom: function _animateZoom(t, e, i, n, s, a, r) {\n      r || (this._animatingZoom = !0), o.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this._animateToCenter = t, this._animateToZoom = e, o.Draggable && (o.Draggable._disabled = !0), o.Util.requestAnimFrame(function () {\n        this.fire("zoomanim", {\n          center: t,\n          zoom: e,\n          origin: i,\n          scale: n,\n          delta: s,\n          backwards: a\n        }), setTimeout(o.bind(this._onZoomTransitionEnd, this), 250);\n      }, this);\n    },\n    _onZoomTransitionEnd: function _onZoomTransitionEnd() {\n      this._animatingZoom && (this._animatingZoom = !1, o.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), o.Util.requestAnimFrame(function () {\n        this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), o.Draggable && (o.Draggable._disabled = !1);\n      }, this));\n    }\n  } : {}), o.TileLayer.include({\n    _animateZoom: function _animateZoom(t) {\n      this._animating || (this._animating = !0, this._prepareBgBuffer());\n      var e = this._bgBuffer,\n          i = o.DomUtil.TRANSFORM,\n          n = t.delta ? o.DomUtil.getTranslateString(t.delta) : e.style[i],\n          s = o.DomUtil.getScaleString(t.scale, t.origin);\n      e.style[i] = t.backwards ? s + " " + n : n + " " + s;\n    },\n    _endZoomAnim: function _endZoomAnim() {\n      var t = this._tileContainer,\n          e = this._bgBuffer;\n      t.style.visibility = "", t.parentNode.appendChild(t), o.Util.falseFn(e.offsetWidth);\n\n      var i = this._map.getZoom();\n\n      (i > this.options.maxZoom || i < this.options.minZoom) && this._clearBgBuffer(), this._animating = !1;\n    },\n    _clearBgBuffer: function _clearBgBuffer() {\n      var t = this._map;\n      !t || t._animatingZoom || t.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[o.DomUtil.TRANSFORM] = "");\n    },\n    _prepareBgBuffer: function _prepareBgBuffer() {\n      var t = this._tileContainer,\n          e = this._bgBuffer,\n          i = this._getLoadedTilesPercentage(e),\n          n = this._getLoadedTilesPercentage(t);\n\n      return e && i > .5 && .5 > n ? (t.style.visibility = "hidden", void this._stopLoadingImages(t)) : (e.style.visibility = "hidden", e.style[o.DomUtil.TRANSFORM] = "", this._tileContainer = e, e = this._bgBuffer = t, this._stopLoadingImages(e), void clearTimeout(this._clearBgBufferTimer));\n    },\n    _getLoadedTilesPercentage: function _getLoadedTilesPercentage(t) {\n      var e,\n          i,\n          n = t.getElementsByTagName("img"),\n          o = 0;\n\n      for (e = 0, i = n.length; i > e; e++) {\n        n[e].complete && o++;\n      }\n\n      return o / i;\n    },\n    _stopLoadingImages: function _stopLoadingImages(t) {\n      var e,\n          i,\n          n,\n          s = Array.prototype.slice.call(t.getElementsByTagName("img"));\n\n      for (e = 0, i = s.length; i > e; e++) {\n        n = s[e], n.complete || (n.onload = o.Util.falseFn, n.onerror = o.Util.falseFn, n.src = o.Util.emptyImageUrl, n.parentNode.removeChild(n));\n      }\n    }\n  }), o.Map.include({\n    _defaultLocateOptions: {\n      watch: !1,\n      setView: !1,\n      maxZoom: 1 / 0,\n      timeout: 1e4,\n      maximumAge: 0,\n      enableHighAccuracy: !1\n    },\n    locate: function locate(t) {\n      if (t = this._locateOptions = o.extend(this._defaultLocateOptions, t), !navigator.geolocation) return this._handleGeolocationError({\n        code: 0,\n        message: "Geolocation not supported."\n      }), this;\n      var e = o.bind(this._handleGeolocationResponse, this),\n          i = o.bind(this._handleGeolocationError, this);\n      return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this;\n    },\n    stopLocate: function stopLocate() {\n      return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;\n    },\n    _handleGeolocationError: function _handleGeolocationError(t) {\n      var e = t.code,\n          i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");\n      this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {\n        code: e,\n        message: "Geolocation error: " + i + "."\n      });\n    },\n    _handleGeolocationResponse: function _handleGeolocationResponse(t) {\n      var e = t.coords.latitude,\n          i = t.coords.longitude,\n          n = new o.LatLng(e, i),\n          s = 180 * t.coords.accuracy / 40075017,\n          a = s / Math.cos(o.LatLng.DEG_TO_RAD * e),\n          r = o.latLngBounds([e - s, i - a], [e + s, i + a]),\n          h = this._locateOptions;\n\n      if (h.setView) {\n        var l = Math.min(this.getBoundsZoom(r), h.maxZoom);\n        this.setView(n, l);\n      }\n\n      var u = {\n        latlng: n,\n        bounds: r,\n        timestamp: t.timestamp\n      };\n\n      for (var c in t.coords) {\n        "number" == typeof t.coords[c] && (u[c] = t.coords[c]);\n      }\n\n      this.fire("locationfound", u);\n    }\n  });\n}(window, document);'},2307:function(n,e,t){t(1226)(t(2308))},2308:function(n,e){n.exports='function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function (n, t) {\n  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : n.Dexie = t();\n}(this, function () {\n  "use strict";\n\n  function n(n, t) {\n    An = n, En = t;\n  }\n\n  function t() {\n    if (In) try {\n      throw t.arguments, new Error();\n    } catch (n) {\n      return n;\n    }\n    return new Error();\n  }\n\n  function e(n, t) {\n    var e = n.stack;\n    return e ? (t = t || 0, 0 === e.indexOf(n.name) && (t += (n.name + n.message).split("\\n").length), e.split("\\n").slice(t).filter(En).map(function (n) {\n      return "\\n" + n;\n    }).join("")) : "";\n  }\n\n  function r() {}\n\n  function i(n) {\n    return n;\n  }\n\n  function o(n, t) {\n    return null == n || n === i ? t : function (e) {\n      return t(n(e));\n    };\n  }\n\n  function u(n, t) {\n    return function () {\n      n.apply(this, arguments), t.apply(this, arguments);\n    };\n  }\n\n  function a(n, t) {\n    return n === r ? t : function () {\n      var e = n.apply(this, arguments);\n      void 0 !== e && (arguments[0] = e);\n      var r = this.onsuccess,\n          i = this.onerror;\n      this.onsuccess = null, this.onerror = null;\n      var o = t.apply(this, arguments);\n      return r && (this.onsuccess = this.onsuccess ? u(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? u(i, this.onerror) : i), void 0 !== o ? o : e;\n    };\n  }\n\n  function c(n, t) {\n    return n === r ? t : function () {\n      n.apply(this, arguments);\n      var e = this.onsuccess,\n          r = this.onerror;\n      this.onsuccess = this.onerror = null, t.apply(this, arguments), e && (this.onsuccess = this.onsuccess ? u(e, this.onsuccess) : e), r && (this.onerror = this.onerror ? u(r, this.onerror) : r);\n    };\n  }\n\n  function s(n, t) {\n    return n === r ? t : function (e) {\n      var r = n.apply(this, arguments);\n      h(e, r);\n      var i = this.onsuccess,\n          o = this.onerror;\n      this.onsuccess = null, this.onerror = null;\n      var a = t.apply(this, arguments);\n      return i && (this.onsuccess = this.onsuccess ? u(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? u(o, this.onerror) : o), void 0 === r ? void 0 === a ? void 0 : a : h(r, a);\n    };\n  }\n\n  function f(n, t) {\n    return n === r ? t : function () {\n      return t.apply(this, arguments) === !1 ? !1 : n.apply(this, arguments);\n    };\n  }\n\n  function l(n, t) {\n    return n === r ? t : function () {\n      var e = n.apply(this, arguments);\n\n      if (e && "function" == typeof e.then) {\n        for (var r = this, i = arguments.length, o = new Array(i); i--;) {\n          o[i] = arguments[i];\n        }\n\n        return e.then(function () {\n          return t.apply(r, o);\n        });\n      }\n\n      return t.apply(this, arguments);\n    };\n  }\n\n  function h(n, t) {\n    return "object" != _typeof(t) ? n : (On(t).forEach(function (e) {\n      n[e] = t[e];\n    }), n);\n  }\n\n  function d(n, t) {\n    return Dn.call(n, t);\n  }\n\n  function v(n, t) {\n    "function" == typeof t && (t = t(Pn(n))), On(t).forEach(function (e) {\n      p(n, e, t[e]);\n    });\n  }\n\n  function p(n, t, e, r) {\n    Object.defineProperty(n, t, h(e && d(e, "get") && "function" == typeof e.get ? {\n      get: e.get,\n      set: e.set,\n      configurable: !0\n    } : {\n      value: e,\n      configurable: !0,\n      writable: !0\n    }, r));\n  }\n\n  function y(n) {\n    return {\n      from: function from(t) {\n        return n.prototype = Object.create(t.prototype), p(n.prototype, "constructor", n), {\n          extend: v.bind(null, n.prototype)\n        };\n      }\n    };\n  }\n\n  function m(n, t) {\n    var e,\n        r = Sn(n, t);\n    return r || (e = Pn(n)) && m(e, t);\n  }\n\n  function g(n, t, e) {\n    return Tn.call(n, t, e);\n  }\n\n  function b(n, t) {\n    return t(n);\n  }\n\n  function _(n) {\n    var t = setTimeout(n, 1e3);\n    clearTimeout(t);\n  }\n\n  function w(n) {\n    if (!n) throw new Ln.Internal("Assertion failed");\n  }\n\n  function k(n) {\n    jn.setImmediate ? setImmediate(n) : setTimeout(n, 0);\n  }\n\n  function x(n, t) {\n    return n.reduce(function (n, e, r) {\n      var i = t(e, r);\n      return i && (n[i[0]] = i[1]), n;\n    }, {});\n  }\n\n  function A(n, t) {\n    return function () {\n      try {\n        n.apply(this, arguments);\n      } catch (e) {\n        t(e);\n      }\n    };\n  }\n\n  function E(n, t, e) {\n    try {\n      n.apply(null, e);\n    } catch (r) {\n      t && t(r);\n    }\n  }\n\n  function I(n, t) {\n    var e = U.reject(n);\n    return t ? e.uncaught(t) : e;\n  }\n\n  function O(n, t) {\n    if (d(n, t)) return n[t];\n    if (!t) return n;\n\n    if ("string" != typeof t) {\n      for (var e = [], r = 0, i = t.length; i > r; ++r) {\n        var o = O(n, t[r]);\n        e.push(o);\n      }\n\n      return e;\n    }\n\n    var u = t.indexOf(".");\n\n    if (-1 !== u) {\n      var a = n[t.substr(0, u)];\n      return void 0 === a ? void 0 : O(a, t.substr(u + 1));\n    }\n  }\n\n  function C(n, t, e) {\n    if (n && void 0 !== t && !("isFrozen" in Object && Object.isFrozen(n))) if ("string" != typeof t && "length" in t) {\n      w("string" != typeof e && "length" in e);\n\n      for (var r = 0, i = t.length; i > r; ++r) {\n        C(n, t[r], e[r]);\n      }\n    } else {\n      var o = t.indexOf(".");\n\n      if (-1 !== o) {\n        var u = t.substr(0, o),\n            a = t.substr(o + 1);\n        if ("" === a) void 0 === e ? delete n[u] : n[u] = e;else {\n          var c = n[u];\n          c || (c = n[u] = {}), C(c, a, e);\n        }\n      } else void 0 === e ? delete n[t] : n[t] = e;\n    }\n  }\n\n  function j(n, t) {\n    "string" == typeof t ? C(n, t, void 0) : "length" in t && [].map.call(t, function (t) {\n      C(n, t, void 0);\n    });\n  }\n\n  function P(n) {\n    var t = {};\n\n    for (var e in n) {\n      d(n, e) && (t[e] = n[e]);\n    }\n\n    return t;\n  }\n\n  function D(n) {\n    if (!n || "object" != _typeof(n)) return n;\n    var t;\n\n    if (Cn(n)) {\n      t = [];\n\n      for (var e = 0, r = n.length; r > e; ++e) {\n        t.push(D(n[e]));\n      }\n    } else if (n instanceof Date) t = new Date(), t.setTime(n.getTime());else {\n      t = n.constructor ? Object.create(n.constructor.prototype) : {};\n\n      for (var i in n) {\n        d(n, i) && (t[i] = D(n[i]));\n      }\n    }\n\n    return t;\n  }\n\n  function S(n, t, e, r) {\n    return e = e || {}, r = r || "", On(n).forEach(function (i) {\n      if (d(t, i)) {\n        var o = n[i],\n            u = t[i];\n        "object" == _typeof(o) && "object" == _typeof(u) && o && u && o.constructor === u.constructor ? S(o, u, e, r + i + ".") : o !== u && (e[r + i] = t[i]);\n      } else e[r + i] = void 0;\n    }), On(t).forEach(function (i) {\n      d(n, i) || (e[r + i] = t[i]);\n    }), e;\n  }\n\n  function T(n) {\n    var t, e, r, i;\n\n    if (1 === arguments.length) {\n      if (Cn(n)) return n.slice();\n      if (this === Mn && "string" == typeof n) return [n];\n\n      if (i = Bn(n)) {\n        for (e = []; r = i.next(), !r.done;) {\n          e.push(r.value);\n        }\n\n        return e;\n      }\n\n      if (null == n) return [n];\n\n      if (t = n.length, "number" == typeof t) {\n        for (e = new Array(t); t--;) {\n          e[t] = n[t];\n        }\n\n        return e;\n      }\n\n      return [n];\n    }\n\n    for (t = arguments.length, e = new Array(t); t--;) {\n      e[t] = arguments[t];\n    }\n\n    return e;\n  }\n\n  function K(n) {\n    return Nn.apply([], n);\n  }\n\n  function B(n, e) {\n    this._e = t(), this.name = n, this.message = e;\n  }\n\n  function M(n, t) {\n    return n + ". Errors: " + t.map(function (n) {\n      return n.toString();\n    }).filter(function (n, t, e) {\n      return e.indexOf(n) === t;\n    }).join("\\n");\n  }\n\n  function N(n, e, r, i) {\n    this._e = t(), this.failures = e, this.failedKeys = i, this.successCount = r;\n  }\n\n  function q(n, e) {\n    this._e = t(), this.name = "BulkError", this.failures = e, this.message = M(n, e);\n  }\n\n  function F(n, t) {\n    if (!n || n instanceof B || n instanceof TypeError || n instanceof SyntaxError || !n.name || !Wn[n.name]) return n;\n    var e = new Wn[n.name](t || n.message, n);\n    return "stack" in n && p(e, "stack", {\n      get: function get() {\n        return this.inner.stack;\n      }\n    }), e;\n  }\n\n  function R(n) {\n    function t(n, t, i) {\n      if ("object" == _typeof(n)) return e(n);\n      t || (t = f), i || (i = r);\n      var a = {\n        subscribers: [],\n        fire: i,\n        subscribe: function subscribe(n) {\n          -1 === a.subscribers.indexOf(n) && (a.subscribers.push(n), a.fire = t(a.fire, n));\n        },\n        unsubscribe: function unsubscribe(n) {\n          a.subscribers = a.subscribers.filter(function (t) {\n            return t !== n;\n          }), a.fire = a.subscribers.reduce(t, i);\n        }\n      };\n      return o[n] = u[n] = a, a;\n    }\n\n    function e(n) {\n      On(n).forEach(function (e) {\n        var r = n[e];\n        if (Cn(r)) t(e, n[e][0], n[e][1]);else {\n          if ("asap" !== r) throw new Ln.InvalidArgument("Invalid event config");\n          var o = t(e, i, function () {\n            for (var n = arguments.length, t = new Array(n); n--;) {\n              t[n] = arguments[n];\n            }\n\n            o.subscribers.forEach(function (n) {\n              k(function () {\n                n.apply(null, t);\n              });\n            });\n          });\n        }\n      });\n    }\n\n    var o = {},\n        u = function u(t, e) {\n      if (e) {\n        for (var r = arguments.length, i = new Array(r - 1); --r;) {\n          i[r - 1] = arguments[r];\n        }\n\n        return o[t].subscribe.apply(null, i), n;\n      }\n\n      return "string" == typeof t ? o[t] : void 0;\n    };\n\n    u.addEventType = t;\n\n    for (var a = 1, c = arguments.length; c > a; ++a) {\n      t(arguments[a]);\n    }\n\n    return u;\n  }\n\n  function U(n) {\n    if ("object" != _typeof(this)) throw new TypeError("Promises must be constructed via new");\n    this._listeners = [], this.onuncatched = r, this._lib = !1;\n    var e = this._PSD = ut;\n\n    if (An && (this._stackHolder = t(), this._prev = null, this._numPrev = 0, Q(this, rt)), "function" != typeof n) {\n      if (n !== Gn) throw new TypeError("Not a function");\n      return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && L(this, this._value));\n    }\n\n    this._state = null, this._value = null, ++e.ref, V(this, n);\n  }\n\n  function z(n, t, e, r) {\n    this.onFulfilled = "function" == typeof n ? n : null, this.onRejected = "function" == typeof t ? t : null, this.resolve = e, this.reject = r, this.psd = ut;\n  }\n\n  function V(n, t) {\n    try {\n      t(function (t) {\n        if (null === n._state) {\n          if (t === n) throw new TypeError("A promise cannot be resolved with itself.");\n          var e = n._lib && $();\n          t && "function" == typeof t.then ? V(n, function (n, e) {\n            t instanceof U ? t._then(n, e) : t.then(n, e);\n          }) : (n._state = !0, n._value = t, W(n)), e && X();\n        }\n      }, L.bind(null, n));\n    } catch (e) {\n      L(n, e);\n    }\n  }\n\n  function L(n, t) {\n    if (et.push(t), null === n._state) {\n      var e = n._lib && $();\n      t = it(t), n._state = !1, n._value = t, An && null !== t && "object" == _typeof(t) && !t._promise && E(function () {\n        var e = m(t, "stack");\n        t._promise = n, p(t, "stack", {\n          get: function get() {\n            return Yn ? e && (e.get ? e.get.apply(t) : e.value) : n.stack;\n          }\n        });\n      }), tn(n), W(n), e && X();\n    }\n  }\n\n  function W(n) {\n    var t = n._listeners;\n    n._listeners = [];\n\n    for (var e = 0, r = t.length; r > e; ++e) {\n      H(n, t[e]);\n    }\n\n    var i = n._PSD;\n    --i.ref || i.finalize(), 0 === ct && (++ct, Xn(function () {\n      0 === --ct && Z();\n    }, []));\n  }\n\n  function H(n, t) {\n    if (null === n._state) return void n._listeners.push(t);\n    var e = n._state ? t.onFulfilled : t.onRejected;\n    if (null === e) return (n._state ? t.resolve : t.reject)(n._value);\n    var r = t.psd;\n    ++r.ref, ++ct, Xn(G, [e, n, t]);\n  }\n\n  function G(n, t, e) {\n    var r = ut,\n        i = e.psd;\n\n    try {\n      i !== r && (ut = i), rt = t;\n      var o,\n          u = t._value;\n      t._state ? o = n(u) : (et.length && (et = []), o = n(u), -1 === et.indexOf(u) && en(t)), e.resolve(o);\n    } catch (a) {\n      e.reject(a);\n    } finally {\n      i !== r && (ut = r), rt = null, 0 === --ct && Z(), --i.ref || i.finalize();\n    }\n  }\n\n  function J(n, t, r) {\n    if (t.length === r) return t;\n    var i = "";\n\n    if (n._state === !1) {\n      var o,\n          u,\n          a = n._value;\n      null != a ? (o = a.name || "Error", u = a.message || a, i = e(a, 0)) : (o = a, u = ""), t.push(o + (u ? ": " + u : "") + i);\n    }\n\n    return An && (i = e(n._stackHolder, 2), i && -1 === t.indexOf(i) && t.push(i), n._prev && J(n._prev, t, r)), t;\n  }\n\n  function Q(n, t) {\n    var e = t ? t._numPrev + 1 : 0;\n    Jn > e && (n._prev = t, n._numPrev = e);\n  }\n\n  function Y() {\n    $() && X();\n  }\n\n  function $() {\n    var n = Zn;\n    return Zn = !1, nt = !1, n;\n  }\n\n  function X() {\n    var n, t, e;\n\n    do {\n      for (; at.length > 0;) {\n        for (n = at, at = [], e = n.length, t = 0; e > t; ++t) {\n          var r = n[t];\n          r[0].apply(null, r[1]);\n        }\n      }\n    } while (at.length > 0);\n\n    Zn = !0, nt = !0;\n  }\n\n  function Z() {\n    var n = tt;\n    tt = [], n.forEach(function (n) {\n      n._PSD.onunhandled.call(null, n._value, n);\n    });\n\n    for (var t = st.slice(0), e = t.length; e;) {\n      t[--e]();\n    }\n  }\n\n  function nn(n) {\n    function t() {\n      n(), st.splice(st.indexOf(t), 1);\n    }\n\n    st.push(t), ++ct, Xn(function () {\n      0 === --ct && Z();\n    }, []);\n  }\n\n  function tn(n) {\n    tt.some(function (t) {\n      return t._value === n._value;\n    }) || tt.push(n);\n  }\n\n  function en(n) {\n    for (var t = tt.length; t;) {\n      if (tt[--t]._value === n._value) return void tt.splice(t, 1);\n    }\n  }\n\n  function rn(n) {\n    console.warn("Unhandled rejection: " + (n.stack || n));\n  }\n\n  function on(n) {\n    return new U(Gn, !1, n);\n  }\n\n  function un(n, t) {\n    var e = ut;\n    return function () {\n      var r = $(),\n          i = ut;\n\n      try {\n        return i !== e && (ut = e), n.apply(this, arguments);\n      } catch (o) {\n        t && t(o);\n      } finally {\n        i !== e && (ut = i), r && X();\n      }\n    };\n  }\n\n  function an(n, t, e, r) {\n    var i = ut,\n        o = Object.create(i);\n    o.parent = i, o.ref = 0, o.global = !1, ++i.ref, o.finalize = function () {\n      --this.parent.ref || this.parent.finalize();\n    };\n    var u = cn(o, n, t, e, r);\n    return 0 === o.ref && o.finalize(), u;\n  }\n\n  function cn(n, t, e, r, i) {\n    var o = ut;\n\n    try {\n      return n !== o && (ut = n), t(e, r, i);\n    } finally {\n      n !== o && (ut = o);\n    }\n  }\n\n  function sn(n, t) {\n    var e;\n\n    try {\n      e = t.onuncatched(n);\n    } catch (r) {}\n\n    if (e !== !1) try {\n      U.on.error.fire(n, t);\n    } catch (r) {}\n  }\n\n  function fn(n, e) {\n    function u() {\n      et.on("versionchange", function (n) {\n        n.newVersion > 0 ? console.warn("Another connection wants to upgrade database \'" + et.name + "\'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database \'" + et.name + "\'. Closing db now to resume the delete request."), et.close();\n      }), et.on("blocked", function (n) {\n        !n.newVersion || n.newVersion < n.oldVersion ? console.warn("Dexie.delete(\'" + et.name + "\') was blocked") : console.warn("Upgrade \'" + et.name + "\' blocked by other connection holding version " + n.oldVersion / 10);\n      });\n    }\n\n    function f(n) {\n      this._cfg = {\n        version: n,\n        storesSource: null,\n        dbschema: {},\n        tables: {},\n        contentUpgrade: null\n      }, this.stores({});\n    }\n\n    function m(n, t, e) {\n      var r = et._createTransaction(tt, Jn, Hn);\n\n      r.create(t), r._completion["catch"](e);\n\n      var i = r._reject.bind(r);\n\n      an(function () {\n        ut.trans = r, 0 === n ? (On(Hn).forEach(function (n) {\n          B(t, n, Hn[n].primKey, Hn[n].indexes);\n        }), U.follow(function () {\n          return et.on.populate.fire(r);\n        })["catch"](i)) : k(n, r, t)["catch"](i);\n      });\n    }\n\n    function k(n, t, e) {\n      function r() {\n        return i.length ? U.resolve(i.shift()(t.idbtrans)).then(r) : U.resolve();\n      }\n\n      var i = [],\n          o = Gn.filter(function (t) {\n        return t._cfg.version === n;\n      })[0];\n      if (!o) throw new Ln.Upgrade("Dexie specification of currently installed DB version is missing");\n      Hn = et._dbSchema = o._cfg.dbschema;\n      var u = !1,\n          a = Gn.filter(function (t) {\n        return t._cfg.version > n;\n      });\n      return a.forEach(function (n) {\n        i.push(function () {\n          var r = Hn,\n              i = n._cfg.dbschema;\n          Tn(r, e), Tn(i, e), Hn = et._dbSchema = i;\n          var o = j(r, i);\n          return o.add.forEach(function (n) {\n            B(e, n[0], n[1].primKey, n[1].indexes);\n          }), o.change.forEach(function (n) {\n            if (n.recreate) throw new Ln.Upgrade("Not yet support for changing primary key");\n            var t = e.objectStore(n.name);\n            n.add.forEach(function (n) {\n              z(t, n);\n            }), n.change.forEach(function (n) {\n              t.deleteIndex(n.name), z(t, n);\n            }), n.del.forEach(function (n) {\n              t.deleteIndex(n);\n            });\n          }), n._cfg.contentUpgrade ? (u = !0, U.follow(function () {\n            n._cfg.contentUpgrade(t);\n          })) : void 0;\n        }), i.push(function (t) {\n          if (!u || !mt) {\n            var e = n._cfg.dbschema;\n            F(e, t);\n          }\n        });\n      }), r().then(function () {\n        M(Hn, e);\n      });\n    }\n\n    function j(n, t) {\n      var e = {\n        del: [],\n        add: [],\n        change: []\n      };\n\n      for (var r in n) {\n        t[r] || e.del.push(r);\n      }\n\n      for (r in t) {\n        var i = n[r],\n            o = t[r];\n\n        if (i) {\n          var u = {\n            name: r,\n            def: o,\n            recreate: !1,\n            del: [],\n            add: [],\n            change: []\n          };\n          if (i.primKey.src !== o.primKey.src) u.recreate = !0, e.change.push(u);else {\n            var a = i.idxByName,\n                c = o.idxByName;\n\n            for (var s in a) {\n              c[s] || u.del.push(s);\n            }\n\n            for (s in c) {\n              var f = a[s],\n                  l = c[s];\n              f ? f.src !== l.src && u.change.push(l) : u.add.push(l);\n            }\n\n            (u.del.length > 0 || u.add.length > 0 || u.change.length > 0) && e.change.push(u);\n          }\n        } else e.add.push([r, o]);\n      }\n\n      return e;\n    }\n\n    function B(n, t, e, r) {\n      var i = n.db.createObjectStore(t, e.keyPath ? {\n        keyPath: e.keyPath,\n        autoIncrement: e.auto\n      } : {\n        autoIncrement: e.auto\n      });\n      return r.forEach(function (n) {\n        z(i, n);\n      }), i;\n    }\n\n    function M(n, t) {\n      On(n).forEach(function (e) {\n        t.db.objectStoreNames.contains(e) || B(t, e, n[e].primKey, n[e].indexes);\n      });\n    }\n\n    function F(n, t) {\n      for (var e = 0; e < t.db.objectStoreNames.length; ++e) {\n        var r = t.db.objectStoreNames[e];\n        null == n[r] && t.db.deleteObjectStore(r);\n      }\n    }\n\n    function z(n, t) {\n      n.createIndex(t.name, t.keyPath, {\n        unique: t.unique,\n        multiEntry: t.multi\n      });\n    }\n\n    function V(n) {\n      return et.on.error.fire(n);\n    }\n\n    function L(n, t, e) {\n      if (Zn || ut.letThrough) {\n        var i = et._createTransaction(n, t, Hn);\n\n        return i._promise(n, function (n, t) {\n          an(function () {\n            ut.trans = i, e(n, t, i);\n          });\n        }).then(function (n) {\n          return i._completion.then(function () {\n            return n;\n          });\n        });\n      }\n\n      if (!Xn) {\n        if (!zn) return I(new Ln.DatabaseClosed(), V);\n        et.open()["catch"](r);\n      }\n\n      return rt.then(function () {\n        return L(n, t, e);\n      });\n    }\n\n    function W(n, t, e) {\n      this.name = n, this.schema = t, this.hook = Qn[n] ? Qn[n].hook : R(null, {\n        creating: [a, r],\n        reading: [o, i],\n        updating: [s, r],\n        deleting: [c, r]\n      }), this._collClass = e || $;\n    }\n\n    function H(n, t, e) {\n      W.call(this, n, t, e || Z);\n    }\n\n    function G(n, t, e) {\n      return (e ? yn : pn)(function (e) {\n        n.push(e), t && t();\n      });\n    }\n\n    function J(n, t, e, r, i) {\n      return new U(function (o, u) {\n        var a = e.length,\n            c = a - 1;\n        if (0 === a) return o();\n\n        if (r) {\n          var s,\n              f = yn(u),\n              l = vn(null);\n          E(function () {\n            for (var r = 0; a > r; ++r) {\n              s = {\n                onsuccess: null,\n                onerror: null\n              };\n              var u = e[r];\n              i.call(s, u[0], u[1], t);\n              var h = n["delete"](u[0]);\n              h._hookCtx = s, h.onerror = f, r === c ? h.onsuccess = vn(o) : h.onsuccess = l;\n            }\n          }, function (n) {\n            throw s.onerror && s.onerror(n), n;\n          });\n        } else for (var h = 0; a > h; ++h) {\n          var d = n["delete"](e[h]);\n          d.onerror = un(pn(u)), h === c && (d.onsuccess = un(function () {\n            return o();\n          }));\n        }\n      }).uncaught(V);\n    }\n\n    function Q(n, t, e, r) {\n      var i = this;\n      this.db = et, this.mode = n, this.storeNames = t, this.idbtrans = null, this.on = R(this, "complete", "error", "abort"), this.parent = r || null, this.active = !0, this._tables = null, this._reculock = 0, this._blockedFuncs = [], this._psd = null, this._dbschema = e, this._resolve = null, this._reject = null, this._completion = new U(function (n, t) {\n        i._resolve = n, i._reject = t;\n      }).uncaught(V), this._completion.then(function () {\n        i.on.complete.fire();\n      }, function (n) {\n        return i.on.error.fire(n), i.parent ? i.parent._reject(n) : i.active && i.idbtrans && i.idbtrans.abort(), i.active = !1, I(n);\n      });\n    }\n\n    function Y(n, t, e) {\n      this._ctx = {\n        table: n,\n        index: ":id" === t ? null : t,\n        collClass: n._collClass,\n        or: e\n      };\n    }\n\n    function $(n, t) {\n      var e = null,\n          r = null;\n      if (t) try {\n        e = t();\n      } catch (i) {\n        r = i;\n      }\n      var o = n._ctx,\n          u = o.table;\n      this._ctx = {\n        table: u,\n        index: o.index,\n        isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name,\n        range: e,\n        keysOnly: !1,\n        dir: "next",\n        unique: "",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: !0,\n        isMatch: null,\n        offset: 0,\n        limit: 1 / 0,\n        error: r,\n        or: o.or,\n        valueMapper: u.hook.reading.fire\n      };\n    }\n\n    function X(n, t) {\n      return !(n.filter || n.algorithm || n.or) && (t ? n.justLimit : !n.replayFilter);\n    }\n\n    function Z() {\n      $.apply(this, arguments);\n    }\n\n    function nn(n, t) {\n      return n._cfg.version - t._cfg.version;\n    }\n\n    function tn(n, t, e, r) {\n      t.forEach(function (t) {\n        var i = et._tableFactory(e, r[t]);\n\n        n.forEach(function (n) {\n          t in n || (n[t] = i);\n        });\n      });\n    }\n\n    function en(n) {\n      n.forEach(function (n) {\n        for (var t in n) {\n          n[t] instanceof W && delete n[t];\n        }\n      });\n    }\n\n    function rn(n, t, e, r, i, o) {\n      var u = o ? function (n, t, r) {\n        return e(o(n), t, r);\n      } : e,\n          a = un(u, i);\n      n.onerror || (n.onerror = pn(i)), t ? n.onsuccess = A(function () {\n        var e = n.result;\n\n        if (e) {\n          var o = function o() {\n            e["continue"]();\n          };\n\n          t(e, function (n) {\n            o = n;\n          }, r, i) && a(e.value, e, function (n) {\n            o = n;\n          }), o();\n        } else r();\n      }, i) : n.onsuccess = A(function () {\n        var t = n.result;\n\n        if (t) {\n          var e = function e() {\n            t["continue"]();\n          };\n\n          a(t.value, t, function (n) {\n            e = n;\n          }), e();\n        } else r();\n      }, i);\n    }\n\n    function on(n) {\n      var t = [];\n      return n.split(",").forEach(function (n) {\n        n = n.trim();\n        var e = n.replace(/([&*]|\\+\\+)/g, ""),\n            r = /^\\[/.test(e) ? e.match(/^\\[(.*)\\]$/)[1].split("+") : e;\n        t.push(new _n(e, r || null, /\\&/.test(n), /\\*/.test(n), /\\+\\+/.test(n), Cn(r), /\\./.test(n)));\n      }), t;\n    }\n\n    function cn(n, t) {\n      return Vn.cmp(n, t);\n    }\n\n    function sn(n, t) {\n      return cn(n, t) < 0 ? n : t;\n    }\n\n    function ln(n, t) {\n      return cn(n, t) > 0 ? n : t;\n    }\n\n    function En(n, t) {\n      return Vn.cmp(n, t);\n    }\n\n    function In(n, t) {\n      return Vn.cmp(t, n);\n    }\n\n    function jn(n, t) {\n      return t > n ? -1 : n === t ? 0 : 1;\n    }\n\n    function Pn(n, t) {\n      return n > t ? -1 : n === t ? 0 : 1;\n    }\n\n    function Dn(n, t) {\n      return n ? t ? function () {\n        return n.apply(this, arguments) && t.apply(this, arguments);\n      } : n : t;\n    }\n\n    function Sn() {\n      if (et.verno = Yn.version / 10, et._dbSchema = Hn = {}, Jn = g(Yn.objectStoreNames, 0), 0 !== Jn.length) {\n        var n = Yn.transaction(kn(Jn), "readonly");\n        Jn.forEach(function (t) {\n          for (var e = n.objectStore(t), r = e.keyPath, i = r && "string" == typeof r && -1 !== r.indexOf("."), o = new _n(r, r || "", !1, !1, !!e.autoIncrement, r && "string" != typeof r, i), u = [], a = 0; a < e.indexNames.length; ++a) {\n            var c = e.index(e.indexNames[a]);\n            r = c.keyPath, i = r && "string" == typeof r && -1 !== r.indexOf(".");\n            var s = new _n(c.name, r, !!c.unique, !!c.multiEntry, !1, r && "string" != typeof r, i);\n            u.push(s);\n          }\n\n          Hn[t] = new wn(t, o, u, {});\n        }), tn([Qn, Q.prototype], On(Hn), tt, Hn);\n      }\n    }\n\n    function Tn(n, t) {\n      for (var e = t.db.objectStoreNames, r = 0; r < e.length; ++r) {\n        var i = e[r],\n            o = t.objectStore(i);\n        qn = "getAll" in o;\n\n        for (var u = 0; u < o.indexNames.length; ++u) {\n          var a = o.indexNames[u],\n              c = o.index(a).keyPath,\n              s = "string" == typeof c ? c : "[" + g(c).join("+") + "]";\n\n          if (n[i]) {\n            var f = n[i].idxByName[s];\n            f && (f.name = a);\n          }\n        }\n      }\n    }\n\n    function Kn(n) {\n      et.on("blocked").fire(n), pt.filter(function (n) {\n        return n.name === et.name && n !== et && !n._vcFired;\n      }).map(function (t) {\n        return t.on("versionchange").fire(n);\n      });\n    }\n\n    var Bn,\n        Nn,\n        qn,\n        Fn = fn.dependencies,\n        Rn = h({\n      addons: fn.addons,\n      autoOpen: !0,\n      indexedDB: Fn.indexedDB,\n      IDBKeyRange: Fn.IDBKeyRange\n    }, e),\n        Un = Rn.addons,\n        zn = Rn.autoOpen,\n        Vn = Rn.indexedDB,\n        Wn = Rn.IDBKeyRange,\n        Hn = this._dbSchema = {},\n        Gn = [],\n        Jn = [],\n        Qn = {},\n        Yn = null,\n        $n = null,\n        Xn = !1,\n        Zn = !1,\n        nt = "readonly",\n        tt = "readwrite",\n        et = this,\n        rt = new U(function (n) {\n      Bn = n;\n    }),\n        it = new U(function (n, t) {\n      Nn = t;\n    }),\n        ot = !0,\n        at = !!xn(Vn);\n    this.version = function (n) {\n      if (Yn || Xn) throw new Ln.Schema("Cannot add version when database is open");\n      this.verno = Math.max(this.verno, n);\n      var t = Gn.filter(function (t) {\n        return t._cfg.version === n;\n      })[0];\n      return t ? t : (t = new f(n), Gn.push(t), Gn.sort(nn), t);\n    }, h(f.prototype, {\n      stores: function stores(n) {\n        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, n) : n;\n        var t = {};\n        Gn.forEach(function (n) {\n          h(t, n._cfg.storesSource);\n        });\n        var e = this._cfg.dbschema = {};\n        return this._parseStoresSpec(t, e), Hn = et._dbSchema = e, en([Qn, et, Q.prototype]), tn([Qn, et, Q.prototype, this._cfg.tables], On(e), tt, e), Jn = On(e), this;\n      },\n      upgrade: function upgrade(n) {\n        var t = this;\n        return _t(function () {\n          n(et._createTransaction(tt, On(t._cfg.dbschema), t._cfg.dbschema));\n        }), this._cfg.contentUpgrade = n, this;\n      },\n      _parseStoresSpec: function _parseStoresSpec(n, t) {\n        On(n).forEach(function (e) {\n          if (null !== n[e]) {\n            var r = {},\n                i = on(n[e]),\n                o = i.shift();\n            if (o.multi) throw new Ln.Schema("Primary key cannot be multi-valued");\n            o.keyPath && C(r, o.keyPath, o.auto ? 0 : o.keyPath), i.forEach(function (n) {\n              if (n.auto) throw new Ln.Schema("Only primary key can be marked as autoIncrement (++)");\n              if (!n.keyPath) throw new Ln.Schema("Index must have a name and cannot be an empty string");\n              C(r, n.keyPath, n.compound ? n.keyPath.map(function () {\n                return "";\n              }) : "");\n            }), t[e] = new wn(e, o, i, r);\n          }\n        });\n      }\n    }), this._allTables = Qn, this._tableFactory = function (n, t) {\n      return n === nt ? new W(t.name, t, $) : new H(t.name, t);\n    }, this._createTransaction = function (n, t, e, r) {\n      return new Q(n, t, e, r);\n    }, this._whenReady = function (n) {\n      return new U(wt || Zn || ut.letThrough ? n : function (t, e) {\n        if (!Xn) {\n          if (!zn) return void e(new Ln.DatabaseClosed());\n          et.open()["catch"](r);\n        }\n\n        rt.then(function () {\n          n(t, e);\n        });\n      }).uncaught(V);\n    }, this.verno = 0, this.open = function () {\n      if (Xn || Yn) return rt.then(function () {\n        return $n ? I($n, V) : et;\n      });\n      An && (it._stackHolder = t()), Xn = !0, $n = null, Zn = !1;\n      var e = Bn,\n          r = null;\n      return U.race([it, new U(function (t, e) {\n        if (_(function () {\n          return t();\n        }), Gn.length > 0 && (ot = !1), !Vn) throw new Ln.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL (not locally). If using old Safari versions, make sure to include indexedDB polyfill.");\n        var i = ot ? Vn.open(n) : Vn.open(n, Math.round(10 * et.verno));\n        if (!i) throw new Ln.MissingAPI("IndexedDB API not available");\n        i.onerror = un(pn(e)), i.onblocked = un(Kn), i.onupgradeneeded = un(function (t) {\n          if (r = i.transaction, ot && !et._allowEmptyDB) {\n            i.onerror = mn, r.abort(), i.result.close();\n            var o = Vn.deleteDatabase(n);\n            o.onsuccess = o.onerror = un(function () {\n              e(new Ln.NoSuchDatabase("Database " + n + " doesnt exist"));\n            });\n          } else {\n            r.onerror = un(pn(e));\n            var u = t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion;\n            m(u / 10, r, e, i);\n          }\n        }, e), i.onsuccess = un(function () {\n          if (r = null, Yn = i.result, pt.push(et), ot) Sn();else if (Yn.objectStoreNames.length > 0) try {\n            Tn(Hn, Yn.transaction(kn(Yn.objectStoreNames), nt));\n          } catch (e) {}\n          Yn.onversionchange = un(function (n) {\n            et._vcFired = !0, et.on("versionchange").fire(n);\n          }), at || gn(function (t) {\n            return -1 === t.indexOf(n) ? t.push(n) : void 0;\n          }), t();\n        }, e);\n      })]).then(function () {\n        return fn.vip(et.on.ready.fire);\n      }).then(function () {\n        return Xn = !1, et;\n      })["catch"](function (n) {\n        try {\n          r && r.abort();\n        } catch (t) {}\n\n        return Xn = !1, et.close(), $n = n, I($n, V);\n      })["finally"](function () {\n        Zn = !0, e();\n      });\n    }, this.close = function () {\n      var n = pt.indexOf(et);\n\n      if (n >= 0 && pt.splice(n, 1), Yn) {\n        try {\n          Yn.close();\n        } catch (t) {}\n\n        Yn = null;\n      }\n\n      zn = !1, $n = new Ln.DatabaseClosed(), Xn && Nn($n), rt = new U(function (n) {\n        Bn = n;\n      }), it = new U(function (n, t) {\n        Nn = t;\n      });\n    }, this["delete"] = function () {\n      var t = arguments.length > 0;\n      return new U(function (e, r) {\n        function i() {\n          et.close();\n          var t = Vn.deleteDatabase(n);\n          t.onsuccess = un(function () {\n            at || gn(function (t) {\n              var e = t.indexOf(n);\n              return e >= 0 ? t.splice(e, 1) : void 0;\n            }), e();\n          }), t.onerror = un(pn(r)), t.onblocked = Kn;\n        }\n\n        if (t) throw new Ln.InvalidArgument("Arguments not allowed in db.delete()");\n        Xn ? rt.then(i) : i();\n      }).uncaught(V);\n    }, this.backendDB = function () {\n      return Yn;\n    }, this.isOpen = function () {\n      return null !== Yn;\n    }, this.hasFailed = function () {\n      return null !== $n;\n    }, this.dynamicallyOpened = function () {\n      return ot;\n    }, this.name = n, p(this, "tables", {\n      get: function get() {\n        return On(Qn).map(function (n) {\n          return Qn[n];\n        });\n      }\n    }), this.on = R(this, "error", "populate", "blocked", "versionchange", {\n      ready: [l, r]\n    }), this.on.ready.subscribe = b(this.on.ready.subscribe, function (n) {\n      return function (t, e) {\n        fn.vip(function () {\n          Zn ? (U.resolve().then(t), e && n(t)) : (n(t), e || n(function r() {\n            et.on.ready.unsubscribe(t), et.on.ready.unsubscribe(r);\n          }));\n        });\n      };\n    }), _t(function () {\n      et.on("populate").fire(et._createTransaction(tt, Jn, Hn)), et.on("error").fire(new Error());\n    }), this.transaction = function (n, t, e) {\n      function r(t) {\n        var r = ut;\n        t(U.resolve().then(function () {\n          return an(function () {\n            ut.transless = ut.transless || r;\n\n            var t = et._createTransaction(n, s, Hn, a);\n\n            ut.trans = t, a ? t.idbtrans = a.idbtrans : t.create();\n            var i = s.map(function (n) {\n              return t.tables[n];\n            });\n            i.push(t);\n            var o;\n            return U.follow(function () {\n              if (o = e.apply(t, i)) if ("function" == typeof o.next && "function" == typeof o["throw"]) o = bn(o);else if ("function" == typeof o.then && !d(o, "_PSD")) throw new Ln.IncompatiblePromise("Incompatible Promise returned from transaction scope (read more at http://tinyurl.com/znyqjqc). Transaction scope: " + e.toString());\n            }).uncaught(V).then(function () {\n              return a && t._resolve(), t._completion;\n            }).then(function () {\n              return o;\n            })["catch"](function (n) {\n              return t._reject(n), I(n);\n            });\n          });\n        }));\n      }\n\n      var i = arguments.length;\n      if (2 > i) throw new Ln.InvalidArgument("Too few arguments");\n\n      for (var o = new Array(i - 1); --i;) {\n        o[i - 1] = arguments[i];\n      }\n\n      e = o.pop();\n      var u = K(o),\n          a = ut.trans;\n      a && a.db === et && -1 === n.indexOf("!") || (a = null);\n      var c = -1 !== n.indexOf("?");\n      n = n.replace("!", "").replace("?", "");\n\n      try {\n        var s = u.map(function (n) {\n          var t = n instanceof W ? n.name : n;\n          if ("string" != typeof t) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");\n          return t;\n        });\n        if ("r" == n || n == nt) n = nt;else {\n          if ("rw" != n && n != tt) throw new Ln.InvalidArgument("Invalid transaction mode: " + n);\n          n = tt;\n        }\n\n        if (a) {\n          if (a.mode === nt && n === tt) {\n            if (!c) throw new Ln.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");\n            a = null;\n          }\n\n          a && s.forEach(function (n) {\n            if (!d(a.tables, n)) {\n              if (!c) throw new Ln.SubTransaction("Table " + n + " not included in parent transaction.");\n              a = null;\n            }\n          });\n        }\n      } catch (f) {\n        return a ? a._promise(null, function (n, t) {\n          t(f);\n        }) : I(f, V);\n      }\n\n      return a ? a._promise(n, r, "lock") : et._whenReady(r);\n    }, this.table = function (n) {\n      if (wt && ot) return new H(n);\n      if (!d(Qn, n)) throw new Ln.InvalidTable("Table " + n + " does not exist");\n      return Qn[n];\n    }, v(W.prototype, {\n      _trans: function _trans(n, t, e) {\n        var r = ut.trans;\n        return r && r.db === et ? r._promise(n, t, e) : L(n, [this.name], t);\n      },\n      _idbstore: function _idbstore(n, t, e) {\n        function r(n, e, r) {\n          t(n, e, r.idbtrans.objectStore(o), r);\n        }\n\n        if (wt) return new U(t);\n        var i = ut.trans,\n            o = this.name;\n        return i && i.db === et ? i._promise(n, r, e) : L(n, [this.name], r);\n      },\n      get: function get(n, t) {\n        var e = this;\n        return this._idbstore(nt, function (t, r, i) {\n          wt && t(e.schema.instanceTemplate);\n          var o = i.get(n);\n          o.onerror = pn(r), o.onsuccess = function () {\n            t(e.hook.reading.fire(o.result));\n          };\n        }).then(t);\n      },\n      where: function where(n) {\n        return new Y(this, n);\n      },\n      count: function count(n) {\n        return this.toCollection().count(n);\n      },\n      offset: function offset(n) {\n        return this.toCollection().offset(n);\n      },\n      limit: function limit(n) {\n        return this.toCollection().limit(n);\n      },\n      reverse: function reverse() {\n        return this.toCollection().reverse();\n      },\n      filter: function filter(n) {\n        return this.toCollection().and(n);\n      },\n      each: function each(n) {\n        return this.toCollection().each(n);\n      },\n      toArray: function toArray(n) {\n        return this.toCollection().toArray(n);\n      },\n      orderBy: function orderBy(n) {\n        return new this._collClass(new Y(this, n));\n      },\n      toCollection: function toCollection() {\n        return new this._collClass(new Y(this));\n      },\n      mapToClass: function mapToClass(n, t) {\n        this.schema.mappedClass = n;\n        var e = Object.create(n.prototype);\n        t && hn(e, t), this.schema.instanceTemplate = e;\n\n        var r = function r(t) {\n          if (!t) return t;\n          var e = Object.create(n.prototype);\n\n          for (var r in t) {\n            d(t, r) && (e[r] = t[r]);\n          }\n\n          return e;\n        };\n\n        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), n;\n      },\n      defineClass: function defineClass(n) {\n        return this.mapToClass(fn.defineClass(n), n);\n      }\n    }), y(H).from(W).extend({\n      bulkDelete: function bulkDelete(n) {\n        return this.hook.deleting.fire === r ? this._idbstore(tt, function (t, e, i, o) {\n          t(J(i, o, n, !1, r));\n        }) : this.where(":id").anyOf(n)["delete"]().then(function () {});\n      },\n      bulkPut: function bulkPut(n, t) {\n        var e = this;\n        return this._idbstore(tt, function (i, o, u) {\n          if (!u.keyPath && !e.schema.primKey.auto && !t) throw new Ln.InvalidArgument("bulkPut() with non-inbound keys requires keys array in second argument");\n          if (u.keyPath && t) throw new Ln.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");\n          if (t && t.length !== n.length) throw new Ln.InvalidArgument("Arguments objects and keys must have the same length");\n          if (0 === n.length) return i();\n\n          var a,\n              c,\n              s = function s(n) {\n            0 === f.length ? i(n) : o(new q(e.name + ".bulkPut(): " + f.length + " of " + l + " operations failed", f));\n          },\n              f = [],\n              l = n.length,\n              h = e;\n\n          if (e.hook.creating.fire === r && e.hook.updating.fire === r) {\n            c = G(f);\n\n            for (var d = 0, v = n.length; v > d; ++d) {\n              a = t ? u.put(n[d], t[d]) : u.put(n[d]), a.onerror = c;\n            }\n\n            a.onerror = G(f, s), a.onsuccess = dn(s);\n          } else {\n            var p = t || u.keyPath && n.map(function (n) {\n              return O(n, u.keyPath);\n            }),\n                y = p && x(p, function (t, e) {\n              return null != t && [t, n[e]];\n            }),\n                m = p ? h.where(":id").anyOf(p.filter(function (n) {\n              return null != n;\n            })).modify(function () {\n              this.value = y[this.primKey], y[this.primKey] = null;\n            })["catch"](N, function (n) {\n              f = n.failures;\n            }).then(function () {\n              for (var e = [], r = t && [], i = p.length - 1; i >= 0; --i) {\n                var o = p[i];\n                (null == o || y[o]) && (e.push(n[i]), t && r.push(o), null != o && (y[o] = null));\n              }\n\n              return e.reverse(), t && r.reverse(), h.bulkAdd(e, r);\n            }).then(function (n) {\n              var t = p[p.length - 1];\n              return null != t ? t : n;\n            }) : h.bulkAdd(n);\n            m.then(s)["catch"](q, function (n) {\n              f = f.concat(n.failures), s();\n            })["catch"](o);\n          }\n        }, "locked");\n      },\n      bulkAdd: function bulkAdd(n, t) {\n        var e = this,\n            i = this.hook.creating.fire;\n        return this._idbstore(tt, function (o, u, a, c) {\n          function s(n) {\n            0 === d.length ? o(n) : u(new q(e.name + ".bulkAdd(): " + d.length + " of " + v + " operations failed", d));\n          }\n\n          if (!a.keyPath && !e.schema.primKey.auto && !t) throw new Ln.InvalidArgument("bulkAdd() with non-inbound keys requires keys array in second argument");\n          if (a.keyPath && t) throw new Ln.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");\n          if (t && t.length !== n.length) throw new Ln.InvalidArgument("Arguments objects and keys must have the same length");\n          if (0 === n.length) return o();\n          var f,\n              l,\n              h,\n              d = [],\n              v = n.length;\n\n          if (i !== r) {\n            var p,\n                y = a.keyPath;\n            l = G(d, null, !0), h = vn(null), E(function () {\n              for (var e = 0, r = n.length; r > e; ++e) {\n                p = {\n                  onerror: null,\n                  onsuccess: null\n                };\n                var o = t && t[e],\n                    u = n[e],\n                    s = t ? o : y ? O(u, y) : void 0,\n                    d = i.call(p, s, u, c);\n                null == s && null != d && (y ? (u = D(u), C(u, y, d)) : o = d), f = null != o ? a.add(u, o) : a.add(u), f._hookCtx = p, r - 1 > e && (f.onerror = l, p.onsuccess && (f.onsuccess = h));\n              }\n            }, function (n) {\n              throw p.onerror && p.onerror(n), n;\n            }), f.onerror = G(d, s, !0), f.onsuccess = vn(s);\n          } else {\n            l = G(d);\n\n            for (var m = 0, g = n.length; g > m; ++m) {\n              f = t ? a.add(n[m], t[m]) : a.add(n[m]), f.onerror = l;\n            }\n\n            f.onerror = G(d, s), f.onsuccess = dn(s);\n          }\n        });\n      },\n      add: function add(n, t) {\n        var e = this.hook.creating.fire;\n        return this._idbstore(tt, function (i, o, u, a) {\n          var c = {\n            onsuccess: null,\n            onerror: null\n          };\n\n          if (e !== r) {\n            var s = null != t ? t : u.keyPath ? O(n, u.keyPath) : void 0,\n                f = e.call(c, s, n, a);\n            null == s && null != f && (u.keyPath ? C(n, u.keyPath, f) : t = f);\n          }\n\n          try {\n            var l = null != t ? u.add(n, t) : u.add(n);\n            l._hookCtx = c, l.onerror = yn(o), l.onsuccess = vn(function (t) {\n              var e = u.keyPath;\n              e && C(n, e, t), i(t);\n            });\n          } catch (h) {\n            throw c.onerror && c.onerror(h), h;\n          }\n        });\n      },\n      put: function put(n, t) {\n        var e = this,\n            i = this.hook.creating.fire,\n            o = this.hook.updating.fire;\n        return i !== r || o !== r ? this._trans(tt, function (r, i, o) {\n          var u = void 0 !== t ? t : e.schema.primKey.keyPath && O(n, e.schema.primKey.keyPath);\n          null == u ? o.tables[e.name].add(n).then(r, i) : (o._lock(), n = D(n), o.tables[e.name].where(":id").equals(u).modify(function () {\n            this.value = n;\n          }).then(function (r) {\n            return 0 === r ? o.tables[e.name].add(n, t) : u;\n          })["finally"](function () {\n            o._unlock();\n          }).then(r, i));\n        }) : this._idbstore(tt, function (e, r, i) {\n          var o = void 0 !== t ? i.put(n, t) : i.put(n);\n          o.onerror = pn(r), o.onsuccess = function (t) {\n            var r = i.keyPath;\n            r && C(n, r, t.target.result), e(o.result);\n          };\n        });\n      },\n      "delete": function _delete(n) {\n        return this.hook.deleting.subscribers.length ? this.where(":id").equals(n)["delete"]() : this._idbstore(tt, function (t, e, r) {\n          var i = r["delete"](n);\n          i.onerror = pn(e), i.onsuccess = function () {\n            t(i.result);\n          };\n        });\n      },\n      clear: function clear() {\n        return this.hook.deleting.subscribers.length ? this.toCollection()["delete"]() : this._idbstore(tt, function (n, t, e) {\n          var r = e.clear();\n          r.onerror = pn(t), r.onsuccess = function () {\n            n(r.result);\n          };\n        });\n      },\n      update: function update(n, t) {\n        if ("object" != _typeof(t) || Cn(t)) throw new Ln.InvalidArgument("Modifications must be an object.");\n        if ("object" != _typeof(n) || Cn(n)) return this.where(":id").equals(n).modify(t);\n        On(t).forEach(function (e) {\n          C(n, e, t[e]);\n        });\n        var e = O(n, this.schema.primKey.keyPath);\n        return void 0 === e ? I(new Ln.InvalidArgument("Given object does not contain its primary key"), V) : this.where(":id").equals(e).modify(t);\n      }\n    }), v(Q.prototype, {\n      _lock: function _lock() {\n        return w(!ut.global), ++this._reculock, 1 !== this._reculock || ut.global || (ut.lockOwnerFor = this), this;\n      },\n      _unlock: function _unlock() {\n        if (w(!ut.global), 0 === --this._reculock) for (ut.global || (ut.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {\n          var n = this._blockedFuncs.shift();\n\n          try {\n            n();\n          } catch (t) {}\n        }\n        return this;\n      },\n      _locked: function _locked() {\n        return this._reculock && ut.lockOwnerFor !== this;\n      },\n      create: function create(n) {\n        var t = this;\n        if (w(!this.idbtrans), !n && !Yn) switch ($n && $n.name) {\n          case "DatabaseClosedError":\n            throw new Ln.DatabaseClosed($n);\n\n          case "MissingAPIError":\n            throw new Ln.MissingAPI($n.message, $n);\n\n          default:\n            throw new Ln.OpenFailed($n);\n        }\n        if (!this.active) throw new Ln.TransactionInactive();\n        return w(null === this._completion._state), n = this.idbtrans = n || Yn.transaction(kn(this.storeNames), this.mode), n.onerror = un(function (e) {\n          mn(e), t._reject(n.error);\n        }), n.onabort = un(function (n) {\n          mn(n), t.active && t._reject(new Ln.Abort()), t.active = !1, t.on("abort").fire(n);\n        }), n.oncomplete = un(function () {\n          t.active = !1, t._resolve();\n        }), this;\n      },\n      _promise: function _promise(n, t, e) {\n        var r = this;\n        return an(function () {\n          var i;\n          return r._locked() ? i = new U(function (i, o) {\n            r._blockedFuncs.push(function () {\n              r._promise(n, t, e).then(i, o);\n            });\n          }) : (i = r.active ? new U(function (i, o) {\n            if (n === tt && r.mode !== tt) throw new Ln.ReadOnly("Transaction is readonly");\n            !r.idbtrans && n && r.create(), e && r._lock(), t(i, o, r);\n          }) : I(new Ln.TransactionInactive()), r.active && e && i["finally"](function () {\n            r._unlock();\n          })), i._lib = !0, i.uncaught(V);\n        });\n      },\n      abort: function abort() {\n        this.active && this._reject(new Ln.Abort()), this.active = !1;\n      },\n      tables: {\n        get: function get() {\n          return this._tables ? this._tables : this._tables = x(this.storeNames, function (n) {\n            return [n, Qn[n]];\n          });\n        }\n      },\n      complete: function complete(n) {\n        return this.on("complete", n);\n      },\n      error: function error(n) {\n        return this.on("error", n);\n      },\n      table: function table(n) {\n        if (-1 === this.storeNames.indexOf(n)) throw new Ln.InvalidTable("Table " + n + " not in transaction");\n        return Qn[n];\n      }\n    }), v(Y.prototype, function () {\n      function n(n, t, e) {\n        var r = n instanceof Y ? new n._ctx.collClass(n) : n;\n        return r._ctx.error = e ? new e(t) : new TypeError(t), r;\n      }\n\n      function t(n) {\n        return new n._ctx.collClass(n, function () {\n          return Wn.only("");\n        }).limit(0);\n      }\n\n      function e(n) {\n        return "next" === n ? function (n) {\n          return n.toUpperCase();\n        } : function (n) {\n          return n.toLowerCase();\n        };\n      }\n\n      function r(n) {\n        return "next" === n ? function (n) {\n          return n.toLowerCase();\n        } : function (n) {\n          return n.toUpperCase();\n        };\n      }\n\n      function i(n, t, e, r, i, o) {\n        for (var u = Math.min(n.length, r.length), a = -1, c = 0; u > c; ++c) {\n          var s = t[c];\n          if (s !== r[c]) return i(n[c], e[c]) < 0 ? n.substr(0, c) + e[c] + e.substr(c + 1) : i(n[c], r[c]) < 0 ? n.substr(0, c) + r[c] + e.substr(c + 1) : a >= 0 ? n.substr(0, a) + t[a] + e.substr(a + 1) : null;\n          i(n[c], s) < 0 && (a = c);\n        }\n\n        return u < r.length && "next" === o ? n + e.substr(n.length) : u < n.length && "prev" === o ? n.substr(0, e.length) : 0 > a ? null : n.substr(0, a) + r[a] + e.substr(a + 1);\n      }\n\n      function o(t, o, u, a) {\n        function c(n) {\n          s = e(n), f = r(n), l = "next" === n ? jn : Pn;\n          var t = u.map(function (n) {\n            return {\n              lower: f(n),\n              upper: s(n)\n            };\n          }).sort(function (n, t) {\n            return l(n.lower, t.lower);\n          });\n          h = t.map(function (n) {\n            return n.upper;\n          }), d = t.map(function (n) {\n            return n.lower;\n          }), v = n, p = "next" === n ? "" : a;\n        }\n\n        var s,\n            f,\n            l,\n            h,\n            d,\n            v,\n            p,\n            y = u.length;\n        if (!u.every(function (n) {\n          return "string" == typeof n;\n        })) return n(t, vt);\n        c("next");\n        var m = new t._ctx.collClass(t, function () {\n          return Wn.bound(h[0], d[y - 1] + a);\n        });\n\n        m._ondirectionchange = function (n) {\n          c(n);\n        };\n\n        var g = 0;\n        return m._addAlgorithm(function (n, t, e) {\n          var r = n.key;\n          if ("string" != typeof r) return !1;\n          var u = f(r);\n          if (o(u, d, g)) return !0;\n\n          for (var a = null, c = g; y > c; ++c) {\n            var s = i(r, u, h[c], d[c], l, v);\n            null === s && null === a ? g = c + 1 : (null === a || l(a, s) > 0) && (a = s);\n          }\n\n          return t(null !== a ? function () {\n            n["continue"](a + p);\n          } : e), !1;\n        }), m;\n      }\n\n      return {\n        between: function between(e, r, i, o) {\n          i = i !== !1, o = o === !0;\n\n          try {\n            return cn(e, r) > 0 || 0 === cn(e, r) && (i || o) && (!i || !o) ? t(this) : new this._ctx.collClass(this, function () {\n              return Wn.bound(e, r, !i, !o);\n            });\n          } catch (u) {\n            return n(this, dt);\n          }\n        },\n        equals: function equals(n) {\n          return new this._ctx.collClass(this, function () {\n            return Wn.only(n);\n          });\n        },\n        above: function above(n) {\n          return new this._ctx.collClass(this, function () {\n            return Wn.lowerBound(n, !0);\n          });\n        },\n        aboveOrEqual: function aboveOrEqual(n) {\n          return new this._ctx.collClass(this, function () {\n            return Wn.lowerBound(n);\n          });\n        },\n        below: function below(n) {\n          return new this._ctx.collClass(this, function () {\n            return Wn.upperBound(n, !0);\n          });\n        },\n        belowOrEqual: function belowOrEqual(n) {\n          return new this._ctx.collClass(this, function () {\n            return Wn.upperBound(n);\n          });\n        },\n        startsWith: function startsWith(t) {\n          return "string" != typeof t ? n(this, vt) : this.between(t, t + lt, !0, !0);\n        },\n        startsWithIgnoreCase: function startsWithIgnoreCase(n) {\n          return "" === n ? this.startsWith(n) : o(this, function (n, t) {\n            return 0 === n.indexOf(t[0]);\n          }, [n], lt);\n        },\n        equalsIgnoreCase: function equalsIgnoreCase(n) {\n          return o(this, function (n, t) {\n            return n === t[0];\n          }, [n], "");\n        },\n        anyOfIgnoreCase: function anyOfIgnoreCase() {\n          var n = T.apply(Mn, arguments);\n          return 0 === n.length ? t(this) : o(this, function (n, t) {\n            return -1 !== t.indexOf(n);\n          }, n, "");\n        },\n        startsWithAnyOfIgnoreCase: function startsWithAnyOfIgnoreCase() {\n          var n = T.apply(Mn, arguments);\n          return 0 === n.length ? t(this) : o(this, function (n, t) {\n            return t.some(function (t) {\n              return 0 === n.indexOf(t);\n            });\n          }, n, lt);\n        },\n        anyOf: function anyOf() {\n          var e = T.apply(Mn, arguments),\n              r = En;\n\n          try {\n            e.sort(r);\n          } catch (i) {\n            return n(this, dt);\n          }\n\n          if (0 === e.length) return t(this);\n          var o = new this._ctx.collClass(this, function () {\n            return Wn.bound(e[0], e[e.length - 1]);\n          });\n\n          o._ondirectionchange = function (n) {\n            r = "next" === n ? En : In, e.sort(r);\n          };\n\n          var u = 0;\n          return o._addAlgorithm(function (n, t, i) {\n            for (var o = n.key; r(o, e[u]) > 0;) {\n              if (++u, u === e.length) return t(i), !1;\n            }\n\n            return 0 === r(o, e[u]) ? !0 : (t(function () {\n              n["continue"](e[u]);\n            }), !1);\n          }), o;\n        },\n        notEqual: function notEqual(n) {\n          return this.inAnyRange([[-(1 / 0), n], [n, ht]], {\n            includeLowers: !1,\n            includeUppers: !1\n          });\n        },\n        noneOf: function noneOf() {\n          var t = T.apply(Mn, arguments);\n          if (0 === t.length) return new this._ctx.collClass(this);\n\n          try {\n            t.sort(En);\n          } catch (e) {\n            return n(this, dt);\n          }\n\n          var r = t.reduce(function (n, t) {\n            return n ? n.concat([[n[n.length - 1][1], t]]) : [[-(1 / 0), t]];\n          }, null);\n          return r.push([t[t.length - 1], ht]), this.inAnyRange(r, {\n            includeLowers: !1,\n            includeUppers: !1\n          });\n        },\n        inAnyRange: function inAnyRange(e, r) {\n          function i(n, t) {\n            for (var e = 0, r = n.length; r > e; ++e) {\n              var i = n[e];\n\n              if (cn(t[0], i[1]) < 0 && cn(t[1], i[0]) > 0) {\n                i[0] = sn(i[0], t[0]), i[1] = ln(i[1], t[1]);\n                break;\n              }\n            }\n\n            return e === r && n.push(t), n;\n          }\n\n          function o(n, t) {\n            return l(n[0], t[0]);\n          }\n\n          function u(n) {\n            return !v(n) && !p(n);\n          }\n\n          var a = this._ctx;\n          if (0 === e.length) return t(this);\n          if (!e.every(function (n) {\n            return void 0 !== n[0] && void 0 !== n[1] && En(n[0], n[1]) <= 0;\n          })) return n(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Ln.InvalidArgument);\n          var c,\n              s = !r || r.includeLowers !== !1,\n              f = r && r.includeUppers === !0,\n              l = En;\n\n          try {\n            c = e.reduce(i, []), c.sort(o);\n          } catch (h) {\n            return n(this, dt);\n          }\n\n          var d = 0,\n              v = f ? function (n) {\n            return En(n, c[d][1]) > 0;\n          } : function (n) {\n            return En(n, c[d][1]) >= 0;\n          },\n              p = s ? function (n) {\n            return In(n, c[d][0]) > 0;\n          } : function (n) {\n            return In(n, c[d][0]) >= 0;\n          },\n              y = v,\n              m = new a.collClass(this, function () {\n            return Wn.bound(c[0][0], c[c.length - 1][1], !s, !f);\n          });\n          return m._ondirectionchange = function (n) {\n            "next" === n ? (y = v, l = En) : (y = p, l = In), c.sort(o);\n          }, m._addAlgorithm(function (n, t, e) {\n            for (var r = n.key; y(r);) {\n              if (++d, d === c.length) return t(e), !1;\n            }\n\n            return u(r) ? !0 : 0 === cn(r, c[d][1]) || 0 === cn(r, c[d][0]) ? !1 : (t(function () {\n              l === En ? n["continue"](c[d][0]) : n["continue"](c[d][1]);\n            }), !1);\n          }), m;\n        },\n        startsWithAnyOf: function startsWithAnyOf() {\n          var e = T.apply(Mn, arguments);\n          return e.every(function (n) {\n            return "string" == typeof n;\n          }) ? 0 === e.length ? t(this) : this.inAnyRange(e.map(function (n) {\n            return [n, n + lt];\n          })) : n(this, "startsWithAnyOf() only works with strings");\n        }\n      };\n    }), v($.prototype, function () {\n      function n(n, t) {\n        n.filter = Dn(n.filter, t);\n      }\n\n      function t(n, t, e) {\n        var r = n.replayFilter;\n        n.replayFilter = r ? function () {\n          return Dn(r(), t());\n        } : t, n.justLimit = e && !r;\n      }\n\n      function e(n, t) {\n        n.isMatch = Dn(n.isMatch, t);\n      }\n\n      function r(n, t) {\n        if (n.isPrimKey) return t;\n        var e = n.table.schema.idxByName[n.index];\n        if (!e) throw new Ln.Schema("KeyPath " + n.index + " on object store " + t.name + " is not indexed");\n        return t.index(e.name);\n      }\n\n      function o(n, t) {\n        var e = r(n, t);\n        return n.keysOnly && "openKeyCursor" in e ? e.openKeyCursor(n.range || null, n.dir + n.unique) : e.openCursor(n.range || null, n.dir + n.unique);\n      }\n\n      function u(n, t, e, r, i) {\n        var u = n.replayFilter ? Dn(n.filter, n.replayFilter()) : n.filter;\n        n.or ? function () {\n          function a() {\n            2 === ++f && e();\n          }\n\n          function c(n, e, i) {\n            if (!u || u(e, i, a, r)) {\n              var o = e.primaryKey.toString();\n              d(s, o) || (s[o] = !0, t(n, e, i));\n            }\n          }\n\n          var s = {},\n              f = 0;\n          n.or._iterate(c, a, r, i), rn(o(n, i), n.algorithm, c, a, r, !n.keysOnly && n.valueMapper);\n        }() : rn(o(n, i), Dn(n.algorithm, u), t, e, r, !n.keysOnly && n.valueMapper);\n      }\n\n      function a(n) {\n        return n.table.schema.instanceTemplate;\n      }\n\n      return {\n        _read: function _read(n, t) {\n          var e = this._ctx;\n          return e.error ? e.table._trans(null, function (n, t) {\n            t(e.error);\n          }) : e.table._idbstore(nt, n).then(t);\n        },\n        _write: function _write(n) {\n          var t = this._ctx;\n          return t.error ? t.table._trans(null, function (n, e) {\n            e(t.error);\n          }) : t.table._idbstore(tt, n, "locked");\n        },\n        _addAlgorithm: function _addAlgorithm(n) {\n          var t = this._ctx;\n          t.algorithm = Dn(t.algorithm, n);\n        },\n        _iterate: function _iterate(n, t, e, r) {\n          return u(this._ctx, n, t, e, r);\n        },\n        clone: function clone(n) {\n          var t = Object.create(this.constructor.prototype),\n              e = Object.create(this._ctx);\n          return n && h(e, n), t._ctx = e, t;\n        },\n        raw: function raw() {\n          return this._ctx.valueMapper = null, this;\n        },\n        each: function each(n) {\n          var t = this._ctx;\n\n          if (wt) {\n            var e = a(t),\n                r = t.table.schema.primKey.keyPath,\n                i = O(e, t.index ? t.table.schema.idxByName[t.index].keyPath : r),\n                o = O(e, r);\n            n(e, {\n              key: i,\n              primaryKey: o\n            });\n          }\n\n          return this._read(function (e, r, i) {\n            u(t, n, e, r, i);\n          });\n        },\n        count: function count(n) {\n          if (wt) return U.resolve(0).then(n);\n          var t = this._ctx;\n          if (X(t, !0)) return this._read(function (n, e, i) {\n            var o = r(t, i),\n                u = t.range ? o.count(t.range) : o.count();\n            u.onerror = pn(e), u.onsuccess = function (e) {\n              n(Math.min(e.target.result, t.limit));\n            };\n          }, n);\n          var e = 0;\n          return this._read(function (n, r, i) {\n            u(t, function () {\n              return ++e, !1;\n            }, function () {\n              n(e);\n            }, r, i);\n          }, n);\n        },\n        sortBy: function sortBy(n, t) {\n          function e(n, t) {\n            return t ? e(n[i[t]], t - 1) : n[o];\n          }\n\n          function r(n, t) {\n            var r = e(n, u),\n                i = e(t, u);\n            return i > r ? -a : r > i ? a : 0;\n          }\n\n          var i = n.split(".").reverse(),\n              o = i[0],\n              u = i.length - 1,\n              a = "next" === this._ctx.dir ? 1 : -1;\n          return this.toArray(function (n) {\n            return n.sort(r);\n          }).then(t);\n        },\n        toArray: function toArray(n) {\n          var t = this._ctx;\n          return this._read(function (n, e, o) {\n            if (wt && n([a(t)]), qn && "next" === t.dir && X(t, !0) && t.limit > 0) {\n              var c = t.table.hook.reading.fire,\n                  s = r(t, o),\n                  f = t.limit < 1 / 0 ? s.getAll(t.range, t.limit) : s.getAll(t.range);\n              f.onerror = pn(e), f.onsuccess = c === i ? dn(n) : un(dn(function (t) {\n                n(t.map(c));\n              }));\n            } else {\n              var l = [];\n              u(t, function (n) {\n                l.push(n);\n              }, function () {\n                n(l);\n              }, e, o);\n            }\n          }, n);\n        },\n        offset: function offset(n) {\n          var e = this._ctx;\n          return 0 >= n ? this : (e.offset += n, X(e) ? t(e, function () {\n            var t = n;\n            return function (n, e) {\n              return 0 === t ? !0 : 1 === t ? (--t, !1) : (e(function () {\n                n.advance(t), t = 0;\n              }), !1);\n            };\n          }) : t(e, function () {\n            var t = n;\n            return function () {\n              return --t < 0;\n            };\n          }), this);\n        },\n        limit: function limit(n) {\n          return this._ctx.limit = Math.min(this._ctx.limit, n), t(this._ctx, function () {\n            var t = n;\n            return function (n, e, r) {\n              return --t <= 0 && e(r), t >= 0;\n            };\n          }, !0), this;\n        },\n        until: function until(t, e) {\n          var r = this._ctx;\n          return wt && t(a(r)), n(this._ctx, function (n, r, i) {\n            return t(n.value) ? (r(i), e) : !0;\n          }), this;\n        },\n        first: function first(n) {\n          return this.limit(1).toArray(function (n) {\n            return n[0];\n          }).then(n);\n        },\n        last: function last(n) {\n          return this.reverse().first(n);\n        },\n        filter: function filter(t) {\n          return wt && t(a(this._ctx)), n(this._ctx, function (n) {\n            return t(n.value);\n          }), e(this._ctx, t), this;\n        },\n        and: function and(n) {\n          return this.filter(n);\n        },\n        or: function or(n) {\n          return new Y(this._ctx.table, n, this);\n        },\n        reverse: function reverse() {\n          return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n        },\n        desc: function desc() {\n          return this.reverse();\n        },\n        eachKey: function eachKey(n) {\n          var t = this._ctx;\n          return t.keysOnly = !t.isMatch, this.each(function (t, e) {\n            n(e.key, e);\n          });\n        },\n        eachUniqueKey: function eachUniqueKey(n) {\n          return this._ctx.unique = "unique", this.eachKey(n);\n        },\n        eachPrimaryKey: function eachPrimaryKey(n) {\n          var t = this._ctx;\n          return t.keysOnly = !t.isMatch, this.each(function (t, e) {\n            n(e.primaryKey, e);\n          });\n        },\n        keys: function keys(n) {\n          var t = this._ctx;\n          t.keysOnly = !t.isMatch;\n          var e = [];\n          return this.each(function (n, t) {\n            e.push(t.key);\n          }).then(function () {\n            return e;\n          }).then(n);\n        },\n        primaryKeys: function primaryKeys(n) {\n          var t = this._ctx;\n          if (qn && "next" === t.dir && X(t, !0) && t.limit > 0) return this._read(function (n, e, i) {\n            var o = r(t, i),\n                u = t.limit < 1 / 0 ? o.getAllKeys(t.range, t.limit) : o.getAllKeys(t.range);\n            u.onerror = pn(e), u.onsuccess = dn(n);\n          }).then(n);\n          t.keysOnly = !t.isMatch;\n          var e = [];\n          return this.each(function (n, t) {\n            e.push(t.primaryKey);\n          }).then(function () {\n            return e;\n          }).then(n);\n        },\n        uniqueKeys: function uniqueKeys(n) {\n          return this._ctx.unique = "unique", this.keys(n);\n        },\n        firstKey: function firstKey(n) {\n          return this.limit(1).keys(function (n) {\n            return n[0];\n          }).then(n);\n        },\n        lastKey: function lastKey(n) {\n          return this.reverse().firstKey(n);\n        },\n        distinct: function distinct() {\n          var t = this._ctx,\n              e = t.index && t.table.schema.idxByName[t.index];\n          if (!e || !e.multi) return this;\n          var r = {};\n          return n(this._ctx, function (n) {\n            var t = n.primaryKey.toString(),\n                e = d(r, t);\n            return r[t] = !0, !e;\n          }), this;\n        }\n      };\n    }), y(Z).from($).extend({\n      modify: function modify(n) {\n        var t = this,\n            e = this._ctx,\n            i = e.table.hook,\n            o = i.updating.fire,\n            u = i.deleting.fire;\n        return wt && "function" == typeof n && n.call({\n          value: e.table.schema.instanceTemplate\n        }, e.table.schema.instanceTemplate), this._write(function (e, i, a, c) {\n          function s(n, t) {\n            function e(n) {\n              return w.push(n), k.push(r.primKey), l(), !0;\n            }\n\n            x = t.primaryKey;\n            var r = {\n              primKey: t.primaryKey,\n              value: n,\n              onsuccess: null,\n              onerror: null\n            };\n\n            if (v.call(r, n, r) !== !1) {\n              var i = !d(r, "value");\n              ++g, E(function () {\n                var n = i ? t["delete"]() : t.update(r.value);\n                n._hookCtx = r, n.onerror = yn(e), n.onsuccess = vn(function () {\n                  ++b, l();\n                });\n              }, e);\n            } else r.onsuccess && r.onsuccess(r.value);\n          }\n\n          function f(n) {\n            return n && (w.push(n), k.push(x)), i(new N("Error modifying one or more objects", w, b, k));\n          }\n\n          function l() {\n            _ && b + w.length === g && (w.length > 0 ? f() : e(b));\n          }\n\n          var v;\n          if ("function" == typeof n) v = o === r && u === r ? n : function (t) {\n            var e = D(t);\n            if (n.call(this, t, this) === !1) return !1;\n\n            if (d(this, "value")) {\n              var r = S(e, this.value),\n                  i = o.call(this, r, this.primKey, e, c);\n              i && (t = this.value, On(i).forEach(function (n) {\n                C(t, n, i[n]);\n              }));\n            } else u.call(this, this.primKey, t, c);\n          };else if (o === r) {\n            var p = On(n),\n                y = p.length;\n\n            v = function v(t) {\n              for (var e = !1, r = 0; y > r; ++r) {\n                var i = p[r],\n                    o = n[i];\n                O(t, i) !== o && (C(t, i, o), e = !0);\n              }\n\n              return e;\n            };\n          } else {\n            var m = n;\n            n = P(m), v = function v(t) {\n              var e = !1,\n                  r = o.call(this, n, this.primKey, D(t), c);\n              return r && h(n, r), On(n).forEach(function (r) {\n                var i = n[r];\n                O(t, r) !== i && (C(t, r, i), e = !0);\n              }), r && (n = P(m)), e;\n            };\n          }\n\n          var g = 0,\n              b = 0,\n              _ = !1,\n              w = [],\n              k = [],\n              x = null;\n\n          t.clone().raw()._iterate(s, function () {\n            _ = !0, l();\n          }, f, a);\n        });\n      },\n      "delete": function _delete() {\n        var n = this,\n            t = this._ctx,\n            e = t.range,\n            i = t.table.hook.deleting.fire,\n            o = i !== r;\n        if (!o && X(t) && (t.isPrimKey && !gt || !e)) return this._write(function (n, t, r) {\n          var i = pn(t),\n              o = e ? r.count(e) : r.count();\n          o.onerror = i, o.onsuccess = function () {\n            var u = o.result;\n            E(function () {\n              var t = e ? r["delete"](e) : r.clear();\n              t.onerror = i, t.onsuccess = function () {\n                return n(u);\n              };\n            }, function (n) {\n              return t(n);\n            });\n          };\n        });\n        var u = o ? 2e3 : 1e4;\n        return this._write(function (e, r, a, c) {\n          var s = 0,\n              f = n.clone({\n            keysOnly: !t.isMatch && !o\n          }).distinct().limit(u).raw(),\n              l = [],\n              h = function h() {\n            return f.each(o ? function (n, t) {\n              l.push([t.primaryKey, t.value]);\n            } : function (n, t) {\n              l.push(t.primaryKey);\n            }).then(function () {\n              return o ? l.sort(function (n, t) {\n                return En(n[0], t[0]);\n              }) : l.sort(En), J(a, c, l, o, i);\n            }).then(function () {\n              var n = l.length;\n              return s += n, l = [], u > n ? s : h();\n            });\n          };\n\n          e(h());\n        });\n      }\n    }), h(this, {\n      Collection: $,\n      Table: W,\n      Transaction: Q,\n      Version: f,\n      WhereClause: Y,\n      WriteableCollection: Z,\n      WriteableTable: H\n    }), u(), Un.forEach(function (n) {\n      n(et);\n    });\n  }\n\n  function ln(n) {\n    if ("function" == typeof n) return new n();\n    if (Cn(n)) return [ln(n[0])];\n\n    if (n && "object" == _typeof(n)) {\n      var t = {};\n      return hn(t, n), t;\n    }\n\n    return n;\n  }\n\n  function hn(n, t) {\n    return On(t).forEach(function (e) {\n      var r = ln(t[e]);\n      n[e] = r;\n    }), n;\n  }\n\n  function dn(n) {\n    return function (t) {\n      n(t.target.result);\n    };\n  }\n\n  function vn(n) {\n    return un(function (t) {\n      var e = t.target,\n          r = e.result,\n          i = e._hookCtx,\n          o = i && i.onsuccess;\n      o && o(r), n && n(r);\n    }, n);\n  }\n\n  function pn(n) {\n    return function (t) {\n      return mn(t), n(t.target.error), !1;\n    };\n  }\n\n  function yn(n) {\n    return un(function (t) {\n      var e = t.target,\n          r = e.error,\n          i = e._hookCtx,\n          o = i && i.onerror;\n      return o && o(r), mn(t), n(r), !1;\n    });\n  }\n\n  function mn(n) {\n    n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();\n  }\n\n  function gn(n) {\n    var t,\n        e = fn.dependencies.localStorage;\n    if (!e) return n([]);\n\n    try {\n      t = JSON.parse(e.getItem("Dexie.DatabaseNames") || "[]");\n    } catch (r) {\n      t = [];\n    }\n\n    n(t) && e.setItem("Dexie.DatabaseNames", JSON.stringify(t));\n  }\n\n  function bn(n) {\n    function t(n) {\n      return function (t) {\n        var e = n(t),\n            r = e.value;\n        return e.done ? r : r && "function" == typeof r.then ? r.then(i, o) : Cn(r) ? U.all(r).then(i, o) : i(r);\n      };\n    }\n\n    var e = function e(t) {\n      return n.next(t);\n    },\n        r = function r(t) {\n      return n["throw"](t);\n    },\n        i = t(e),\n        o = t(r);\n\n    return t(e)();\n  }\n\n  function _n(n, t, e, r, i, o, u) {\n    this.name = n, this.keyPath = t, this.unique = e, this.multi = r, this.auto = i, this.compound = o, this.dotted = u;\n    var a = "string" == typeof t ? t : t && "[" + [].join.call(t, "+") + "]";\n    this.src = (e ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + a;\n  }\n\n  function wn(n, t, e, r) {\n    this.name = n, this.primKey = t || new _n(), this.indexes = e || [new _n()], this.instanceTemplate = r, this.mappedClass = null, this.idxByName = x(e, function (n) {\n      return [n.name, n];\n    });\n  }\n\n  function kn(n) {\n    return 1 === n.length ? n[0] : n;\n  }\n\n  function xn(n) {\n    var t = n && (n.getDatabaseNames || n.webkitGetDatabaseNames);\n    return t && t.bind(n);\n  }\n\n  var An = "undefined" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href),\n      En = function En() {\n    return !0;\n  },\n      In = !new Error("").stack,\n      On = Object.keys,\n      Cn = Array.isArray,\n      jn = "undefined" != typeof self ? self : "undefined" != typeof window ? window : global,\n      Pn = Object.getPrototypeOf,\n      Dn = {}.hasOwnProperty,\n      Sn = Object.getOwnPropertyDescriptor,\n      Tn = [].slice,\n      Kn = "undefined" != typeof Symbol && Symbol.iterator,\n      Bn = Kn ? function (n) {\n    var t;\n    return null != n && (t = n[Kn]) && t.apply(n);\n  } : function () {\n    return null;\n  },\n      Mn = {},\n      Nn = [].concat,\n      qn = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "IncompatiblePromise"],\n      Fn = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"],\n      Rn = qn.concat(Fn),\n      Un = {\n    VersionChanged: "Database version changed by other database connection",\n    DatabaseClosed: "Database has been closed",\n    Abort: "Transaction aborted",\n    TransactionInactive: "Transaction has already completed or failed"\n  };\n\n  y(B).from(Error).extend({\n    stack: {\n      get: function get() {\n        return this._stack || (this._stack = this.name + ": " + this.message + e(this._e, 2));\n      }\n    },\n    toString: function toString() {\n      return this.name + ": " + this.message;\n    }\n  }), y(N).from(B), y(q).from(B);\n  var zn = Rn.reduce(function (n, t) {\n    return n[t] = t + "Error", n;\n  }, {}),\n      Vn = B,\n      Ln = Rn.reduce(function (n, e) {\n    function r(n, r) {\n      this._e = t(), this.name = i, n ? "string" == typeof n ? (this.message = n, this.inner = r || null) : "object" == _typeof(n) && (this.message = n.name + " " + n.message, this.inner = n) : (this.message = Un[e] || i, this.inner = null);\n    }\n\n    var i = e + "Error";\n    return y(r).from(Vn), n[e] = r, n;\n  }, {});\n  Ln.Syntax = SyntaxError, Ln.Type = TypeError, Ln.Range = RangeError;\n  var Wn = Fn.reduce(function (n, t) {\n    return n[t + "Error"] = Ln[t], n;\n  }, {}),\n      Hn = Rn.reduce(function (n, t) {\n    return -1 === ["Syntax", "Type", "Range"].indexOf(t) && (n[t + "Error"] = Ln[t]), n;\n  }, {});\n  Hn.ModifyError = N, Hn.DexieError = B, Hn.BulkError = q;\n\n  var Gn = {},\n      Jn = 100,\n      Qn = 20,\n      Yn = !1,\n      $n = jn.setImmediate ? setImmediate.bind(null, Y) : jn.MutationObserver ? function () {\n    var n = document.createElement("div");\n    new MutationObserver(function () {\n      Y(), n = null;\n    }).observe(n, {\n      attributes: !0\n    }), n.setAttribute("i", "1");\n  } : function () {\n    setTimeout(Y, 0);\n  },\n      Xn = function Xn(n, t) {\n    at.push([n, t]), nt && ($n(), nt = !1);\n  },\n      Zn = !0,\n      nt = !0,\n      tt = [],\n      et = [],\n      rt = null,\n      it = i,\n      ot = {\n    global: !0,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: sn,\n    finalize: function finalize() {\n      this.unhandleds.forEach(function (n) {\n        try {\n          sn(n[0], n[1]);\n        } catch (t) {}\n      });\n    }\n  },\n      ut = ot,\n      at = [],\n      ct = 0,\n      st = [];\n\n  v(U.prototype, {\n    then: function then(n, t) {\n      var e = this,\n          r = new U(function (r, i) {\n        H(e, new z(n, t, r, i));\n      });\n      return An && (!this._prev || null === this._state) && Q(r, this), r;\n    },\n    _then: function _then(n, t) {\n      H(this, new z(null, null, n, t));\n    },\n    "catch": function _catch(n) {\n      if (1 === arguments.length) return this.then(null, n);\n      var t = arguments[0],\n          e = arguments[1];\n      return "function" == typeof t ? this.then(null, function (n) {\n        return n instanceof t ? e(n) : on(n);\n      }) : this.then(null, function (n) {\n        return n && n.name === t ? e(n) : on(n);\n      });\n    },\n    "finally": function _finally(n) {\n      return this.then(function (t) {\n        return n(), t;\n      }, function (t) {\n        return n(), on(t);\n      });\n    },\n    uncaught: function uncaught(n) {\n      var t = this;\n      return this.onuncatched = f(this.onuncatched, n), this._state === !1 && -1 === tt.indexOf(this) && tt.some(function (n, e, r) {\n        return n._value === t._value && (r[e] = t);\n      }), this;\n    },\n    stack: {\n      get: function get() {\n        if (this._stack) return this._stack;\n\n        try {\n          Yn = !0;\n          var n = J(this, [], Qn),\n              t = n.join("\\nFrom previous: ");\n          return null !== this._state && (this._stack = t), t;\n        } finally {\n          Yn = !1;\n        }\n      }\n    }\n  }), v(U, {\n    all: function all() {\n      var n = T.apply(null, arguments);\n      return new U(function (t, e) {\n        0 === n.length && t([]);\n        var r = n.length;\n        n.forEach(function (i, o) {\n          return U.resolve(i).then(function (e) {\n            n[o] = e, --r || t(n);\n          }, e);\n        });\n      });\n    },\n    resolve: function resolve(n) {\n      return n && "function" == typeof n.then ? n : new U(Gn, !0, n);\n    },\n    reject: on,\n    race: function race() {\n      var n = T.apply(null, arguments);\n      return new U(function (t, e) {\n        n.map(function (n) {\n          return U.resolve(n).then(t, e);\n        });\n      });\n    },\n    PSD: {\n      get: function get() {\n        return ut;\n      },\n      set: function set(n) {\n        return ut = n;\n      }\n    },\n    newPSD: an,\n    usePSD: cn,\n    scheduler: {\n      get: function get() {\n        return Xn;\n      },\n      set: function set(n) {\n        Xn = n;\n      }\n    },\n    rejectionMapper: {\n      get: function get() {\n        return it;\n      },\n      set: function set(n) {\n        it = n;\n      }\n    },\n    follow: function follow(n) {\n      return new U(function (t, e) {\n        return an(function (t, e) {\n          var r = ut;\n          r.unhandleds = [], r.onunhandled = e, r.finalize = u(function () {\n            var n = this;\n            nn(function () {\n              0 === n.unhandleds.length ? t() : e(n.unhandleds[0]);\n            });\n          }, r.finalize), n();\n        }, t, e);\n      });\n    },\n    on: R(null, {\n      error: [f, rn]\n    })\n  }), _(function () {\n    Xn = function Xn(n, t) {\n      setTimeout(function () {\n        n.apply(null, t);\n      }, 0);\n    };\n  });\n\n  var ft = "1.4.2",\n      lt = String.fromCharCode(65535),\n      ht = function () {\n    try {\n      return IDBKeyRange.only([[]]), [[]];\n    } catch (n) {\n      return lt;\n    }\n  }(),\n      dt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",\n      vt = "String expected.",\n      pt = [],\n      yt = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),\n      mt = yt,\n      gt = yt,\n      bt = function bt(n) {\n    return !/(dexie\\.js|dexie\\.min\\.js)/.test(n);\n  };\n\n  n(An, bt);\n\n  var _t = function _t() {},\n      wt = !1,\n      kt = jn.idbModules && jn.idbModules.shimIndexedDB ? jn.idbModules : {};\n\n  return v(fn, Hn), v(fn, {\n    "delete": function _delete(n) {\n      var t = new fn(n),\n          e = t["delete"]();\n      return e.onblocked = function (n) {\n        return t.on("blocked", n), this;\n      }, e;\n    },\n    exists: function exists(n) {\n      return new fn(n).open().then(function (n) {\n        return n.close(), !0;\n      })["catch"](fn.NoSuchDatabaseError, function () {\n        return !1;\n      });\n    },\n    getDatabaseNames: function getDatabaseNames(n) {\n      return new U(function (n, t) {\n        var e = xn(indexedDB);\n\n        if (e) {\n          var r = e();\n          r.onsuccess = function (t) {\n            n(g(t.target.result, 0));\n          }, r.onerror = pn(t);\n        } else gn(function (t) {\n          return n(t), !1;\n        });\n      }).then(n);\n    },\n    defineClass: function defineClass(n) {\n      function t(t) {\n        t ? h(this, t) : wt && hn(this, n);\n      }\n\n      return t;\n    },\n    applyStructure: hn,\n    ignoreTransaction: function ignoreTransaction(n) {\n      return ut.trans ? cn(ut.transless, n) : n();\n    },\n    vip: function vip(n) {\n      return an(function () {\n        return ut.letThrough = !0, n();\n      });\n    },\n    async: function async(n) {\n      return function () {\n        try {\n          var t = bn(n.apply(this, arguments));\n          return t && "function" == typeof t.then ? t : U.resolve(t);\n        } catch (e) {\n          return I(e);\n        }\n      };\n    },\n    spawn: function spawn(n, t, e) {\n      try {\n        var r = bn(n.apply(e, t || []));\n        return r && "function" == typeof r.then ? r : U.resolve(r);\n      } catch (i) {\n        return I(i);\n      }\n    },\n    currentTransaction: {\n      get: function get() {\n        return ut.trans || null;\n      }\n    },\n    Promise: U,\n    debug: {\n      get: function get() {\n        return An;\n      },\n      set: function set(t) {\n        n(t, "dexie" === t ? function () {\n          return !0;\n        } : bt);\n      }\n    },\n    derive: y,\n    extend: h,\n    props: v,\n    override: b,\n    Events: R,\n    events: R,\n    getByKeyPath: O,\n    setByKeyPath: C,\n    delByKeyPath: j,\n    shallowClone: P,\n    deepClone: D,\n    getObjectDiff: S,\n    asap: k,\n    maxKey: ht,\n    addons: [],\n    connections: pt,\n    MultiModifyError: Ln.Modify,\n    errnames: zn,\n    IndexSpec: _n,\n    TableSchema: wn,\n    dependencies: {\n      indexedDB: kt.shimIndexedDB || jn.indexedDB || jn.mozIndexedDB || jn.webkitIndexedDB || jn.msIndexedDB,\n      IDBKeyRange: kt.IDBKeyRange || jn.IDBKeyRange || jn.webkitIDBKeyRange\n    },\n    semVer: ft,\n    version: ft.split(".").map(function (n) {\n      return parseInt(n);\n    }).reduce(function (n, t, e) {\n      return n + t / Math.pow(10, 2 * e);\n    }),\n    fakeAutoComplete: _t,\n    "default": fn\n  }), E(function () {\n    fn.dependencies.localStorage = null != ("undefined" != typeof chrome && null !== chrome ? chrome.storage : void 0) ? null : jn.localStorage;\n  }), U.rejectionMapper = F, _(function () {\n    fn.fakeAutoComplete = _t = _, fn.fake = wt = !0;\n  }), fn;\n});'},2309:function(n,e,t){t(1226)(t(2310))},2310:function(n,e){n.exports="/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(function (window, document) {\n  // Exits early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n    return;\n  }\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observering a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n\n\n  var registry = [];\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://wicg.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @constructor\n   */\n\n  function IntersectionObserverEntry(entry) {\n    this.time = entry.time;\n    this.rootBounds = entry.rootBounds;\n    this.boundingClientRect = entry.boundingClientRect;\n    this.intersectionRect = entry.intersectionRect;\n    this.target = entry.target; // Calculates the intersection ratio. Sets it to 0 if the target area is 0.\n\n    var targetRect = this.boundingClientRect;\n    var targetArea = targetRect.width * targetRect.height;\n    var intersectionRect = this.intersectionRect;\n    var intersectionArea = intersectionRect.width * intersectionRect.height;\n    this.intersectionRatio = targetArea ? intersectionArea / targetArea : 0;\n  }\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://wicg.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @constructor\n   */\n\n\n  function IntersectionObserver(callback, opt_options) {\n    var options = opt_options || {};\n\n    if (typeof callback != 'function') {\n      throw new Error('callback must be a function');\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element');\n    } // Binds and throttles `this._checkForIntersections`.\n\n\n    this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT); // Private properties.\n\n    this._callback = callback;\n    this._observationTargets = [];\n    this._queuedEntries = [];\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin); // Public properties.\n\n    this.thresholds = this._initThresholds(options.threshold);\n    this.root = options.root || null;\n    this.rootMargin = this._rootMarginValues.map(function (margin) {\n      return margin.value + margin.unit;\n    }).join(' ');\n  }\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n\n\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n\n  IntersectionObserver.prototype.POLL_INTERVAL = null;\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n\n  IntersectionObserver.prototype.observe = function (target) {\n    // If the target is already being observed, do nothing.\n    if (this._observationTargets.some(function (item) {\n      return item.element == target;\n    })) {\n      return;\n    }\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element');\n    }\n\n    this._registerInstance();\n\n    this._observationTargets.push({\n      element: target,\n      entry: null\n    });\n\n    this._monitorIntersections();\n  };\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n\n\n  IntersectionObserver.prototype.unobserve = function (target) {\n    this._observationTargets = this._observationTargets.filter(function (item) {\n      return item.element != target;\n    });\n\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections();\n\n      this._unregisterInstance();\n    }\n  };\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n\n\n  IntersectionObserver.prototype.disconnect = function () {\n    this._observationTargets = [];\n\n    this._unmonitorIntersections();\n\n    this._unregisterInstance();\n  };\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n\n\n  IntersectionObserver.prototype.takeRecords = function () {\n    var records = this._queuedEntries.slice();\n\n    this._queuedEntries = [];\n    return records;\n  };\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n\n\n  IntersectionObserver.prototype._initThresholds = function (opt_threshold) {\n    var threshold = opt_threshold || [0];\n    if (!isArray(threshold)) threshold = [threshold];\n    return threshold.sort().filter(function (t, i, a) {\n      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively');\n      }\n\n      return t !== a[i - 1];\n    });\n  };\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n\n\n  IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {\n    var marginString = opt_rootMargin || '0px';\n    var margins = marginString.split(/\\s+/).map(function (margin) {\n      var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent');\n      }\n\n      return {\n        value: parseFloat(parts[1]),\n        unit: parts[2]\n      };\n    }); // Handles shorthand.\n\n    margins[1] = margins[1] || margins[0];\n    margins[2] = margins[2] || margins[0];\n    margins[3] = margins[3] || margins[1];\n    return margins;\n  };\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibilty state is visible.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._monitorIntersections = function () {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true;\n\n      this._checkForIntersections(); // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n\n\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);\n      } else {\n        addEvent(window, 'resize', this._checkForIntersections, true);\n        addEvent(document, 'scroll', this._checkForIntersections, true);\n\n        if ('MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections);\n\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n          });\n        }\n      }\n    }\n  };\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._unmonitorIntersections = function () {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false;\n      clearInterval(this._monitoringInterval);\n      this._monitoringInterval = null;\n      removeEvent(window, 'resize', this._checkForIntersections, true);\n      removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this._domObserver) {\n        this._domObserver.disconnect();\n\n        this._domObserver = null;\n      }\n    }\n  };\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._checkForIntersections = function () {\n    var rootIsInDom = this._rootIsInDom();\n\n    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n    this._observationTargets.forEach(function (item) {\n      var target = item.element;\n      var targetRect = getBoundingClientRect(target);\n\n      var rootContainsTarget = this._rootContainsTarget(target);\n\n      var oldEntry = item.entry;\n      var newEntry = item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: rootIsInDom && rootContainsTarget ? this._computeTargetAndRootIntersection(target, rootRect) : getEmptyRect()\n      });\n\n      if (rootIsInDom && rootContainsTarget) {\n        // If the new entry intersection ratio has crossed any of the\n        // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry);\n        }\n      } else {\n        // If the root is not in the DOM or target is not contained within\n        // root but the previous entry for this target had an intersection,\n        // add a new record indicating removal.\n        if (oldEntry && hasIntersection(oldEntry.intersectionRect)) {\n          this._queuedEntries.push(newEntry);\n        }\n      }\n    }.bind(this));\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this);\n    }\n  };\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://wicg.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {Object} The final intersection rect object.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, rootRect) {\n    var targetRect = getBoundingClientRect(target);\n    var intersectionRect = targetRect;\n    var parent = target.parentNode;\n    var atRoot = false;\n\n    while (!atRoot) {\n      var parentRect = null; // If we're at the root element, set parentRect to the already\n      // calculated rootRect.\n\n      if (parent == this.root || parent.nodeType != 1) {\n        atRoot = true;\n        parentRect = rootRect;\n      } // Otherwise check to see if the parent element hides overflow,\n      // and if so update parentRect.\n      else {\n          var style = window.getComputedStyle(parent);\n\n          if (style.overflow != 'visible') {\n            parentRect = getBoundingClientRect(parent);\n          }\n        } // If either of the above conditionals set a new parentRect,\n      // calculate new intersection data.\n\n\n      if (parentRect) {\n        intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n        if (!hasIntersection(intersectionRect)) break;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return intersectionRect;\n  };\n  /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._getRootRect = function () {\n    var rootRect;\n\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root);\n    } else {\n      // Use <html>/<body> instead of window since scroll bars affect size.\n      var html = document.documentElement;\n      var body = document.body;\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight\n      };\n    }\n\n    return this._expandRectByRootMargin(rootRect);\n  };\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {\n    var margins = this._rootMarginValues.map(function (margin, i) {\n      return margin.unit == 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;\n    });\n\n    var newRect = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3]\n    };\n    newRect.width = newRect.right - newRect.left;\n    newRect.height = newRect.bottom - newRect.top;\n    return newRect;\n  };\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._hasCrossedThreshold = function (oldEntry, newEntry) {\n    // To make comparing easier, a entry that has a ratio of 0\n    // but does not actually intersect is given a value of -1\n    var oldRatio = oldEntry && hasIntersection(oldEntry.intersectionRect) ? oldEntry.intersectionRatio || 0 : -1;\n    var newRatio = hasIntersection(newEntry.intersectionRect) ? newEntry.intersectionRatio || 0 : -1; // Ignore unchanged ratios\n\n    if (oldRatio === newRatio) return;\n\n    for (var i = 0; i < this.thresholds.length; i++) {\n      var threshold = this.thresholds[i]; // Return true if an entry matches a threshold or if the new ratio\n      // and the old ratio are on the opposite sides of a threshold.\n\n      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {\n        return true;\n      }\n    }\n  };\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._rootIsInDom = function () {\n    return !this.root || contains(document, this.root);\n  };\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._rootContainsTarget = function (target) {\n    return contains(this.root || document, target);\n  };\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._registerInstance = function () {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this);\n    }\n  };\n  /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._unregisterInstance = function () {\n    registry = registry.filter(function (instance) {\n      return instance !== this;\n    }.bind(this));\n  };\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n\n\n  function now() {\n    return window.performance && performance.now && performance.now();\n  }\n  /**\n   * Throttles a function and delays its executiong, so it's only called at most\n   * once within a given time period.\n   * @param {Function} fn The function to throttle.\n   * @param {number} timeout The amount of time that must pass before the\n   *     function can be called again.\n   * @return {Function} The throttled function.\n   */\n\n\n  function throttle(fn, timeout) {\n    var timer = null;\n    return function () {\n      if (!timer) {\n        timer = setTimeout(function () {\n          fn();\n          timer = null;\n        }, timeout);\n      }\n    };\n  }\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n\n\n  function addEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.addEventListener == 'function') {\n      node.addEventListener(event, fn, opt_useCapture || false);\n    } else if (typeof node.attachEvent == 'function') {\n      node.attachEvent(event, fn);\n    }\n  }\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n\n\n  function removeEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.removeEventListener == 'function') {\n      node.addEventListener(event, fn, opt_useCapture || false);\n    } else if (typeof node.detatchEvent == 'function') {\n      node.detatchEvent(event, fn);\n    }\n  }\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {Object} The intersection rect.\n   */\n\n\n  function computeRectIntersection(rect1, rect2) {\n    var top = Math.max(rect1.top, rect2.top);\n    var bottom = Math.min(rect1.bottom, rect2.bottom);\n    var left = Math.max(rect1.left, rect2.left);\n    var right = Math.min(rect1.right, rect2.right);\n    var width = right - left;\n    var height = bottom - top; // Returns the intersection or an emptry rect if no intersection is found.\n\n    return width < 0 || height < 0 ? getEmptyRect() : {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      width: width,\n      height: height\n    };\n  }\n  /**\n   * Returns true if an rect was passed and any of its properties are not zero.\n   * TODO(philipwalton): the current native implementation sets the\n   * intersectionRect value of a change entry to (0, 0, 0, 0) when no\n   * intersection is detected. This may change in the future:\n   * https://github.com/WICG/IntersectionObserver/issues/142\n   * @param {Object} rect The intersection rect to check.\n   * @return {boolean} True if an intersection exists, false otherwise.\n   */\n\n\n  function hasIntersection(rect) {\n    return rect.top > 0 || rect.bottom > 0 || rect.left > 0 || rect.right > 0;\n  }\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n\n\n  function getBoundingClientRect(el) {\n    var rect = el.getBoundingClientRect();\n    if (!rect) return; // Older IE\n\n    if (!rect.width || !rect.height) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    }\n\n    return rect;\n  }\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n\n\n  function getEmptyRect() {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  /**\n   * Determines if a root elements contains a target element as a descendant.\n   * @param {Element} root The root element.\n   * @param {Element} target The target to check.\n   * @return {boolean} True if the target is a descendant of root.\n   */\n\n\n  function contains(root, target) {\n    var parent = target.parentNode;\n\n    while (parent) {\n      if (root == parent) return true;\n      parent = parent.parentNode;\n    }\n  }\n  /**\n   * Determins if a value is a JavaScript array.\n   * @param {*} value Any JavaScript value.\n   * @return {boolean} True if the passed value is an array.\n   */\n\n\n  function isArray(value) {\n    return Object.prototype.toString.call(value) == '[object Array]';\n  } // Exposes the constructors globally.\n\n\n  window.IntersectionObserver = IntersectionObserver;\n  window.IntersectionObserverEntry = IntersectionObserverEntry;\n})(window, document);"},2311:function(n,e,t){t(1226)(t(2312))},2312:function(n,e){n.exports='(function () {\n  var a, b, c;\n  c = window, c.Strava || (c.Strava = {}), (a = c.Strava).Analytics || (a.Analytics = {}), (b = c.Strava.Analytics).Models || (b.Models = {});\n}).call(this), function () {\n  Strava.Analytics.Models.ClientEvent = function () {\n    function a(a, b, c) {\n      this.trackableId = a, this.eventAction = b, this.createdAt = null != c ? c : new Date().getTime();\n    }\n\n    return a.Action = {\n      UNKNOWN: 0,\n      CLICK: 1,\n      SCREEN_ENTER: 2,\n      SCREEN_EXIT: 3,\n      KUDO: 4,\n      COMMENT: 5\n    }, a.TargetType = {\n      SELF: 0,\n      LINK: 1,\n      PHOTO: 2,\n      OWNER_AVATAR: 3,\n      OWNER_NAME: 4,\n      MAP: 5,\n      COMMENT_LIST: 6,\n      SHARE: 7,\n      JOIN: 21,\n      PREMIUM_PERK: 22,\n      PARTNER_LINK: 27,\n      ZENDESK_ARTICLE: 37,\n      PARTNER_TAG: 44,\n      PARTNER_TAG_EXPANDED: 45\n    }, a.newScreenEnter = function (a) {\n      return new Strava.Analytics.Models.ClientEvent(a, Strava.Analytics.Models.ClientEvent.Action.SCREEN_ENTER);\n    }, a.newScreenExit = function (a) {\n      return new Strava.Analytics.Models.ClientEvent(a, Strava.Analytics.Models.ClientEvent.Action.SCREEN_EXIT);\n    }, a.newClick = function (a) {\n      return new Strava.Analytics.Models.ClientEvent(a, Strava.Analytics.Models.ClientEvent.Action.CLICK);\n    }, a.newKudo = function (a) {\n      return new Strava.Analytics.Models.ClientEvent(a, Strava.Analytics.Models.ClientEvent.Action.KUDO);\n    }, a.newComment = function (a) {\n      return new Strava.Analytics.Models.ClientEvent(a, Strava.Analytics.Models.ClientEvent.Action.COMMENT);\n    }, a.prototype.setClientUrl = function (a) {\n      return this.clientUrl = a, this;\n    }, a.prototype.setTargetType = function (a) {\n      return this.targetType = a, this;\n    }, a.prototype.setTargetUrl = function (a) {\n      return this.targetUrl = a, this;\n    }, a.prototype.toJson = function () {\n      var a, b;\n      return a = {\n        action: this.eventAction,\n        trackable_id: this.trackableId,\n        timestamp_ms: this.createdAt\n      }, null != this.clientUrl && (a.client_state_details = {\n        url: this.clientUrl\n      }), b = {}, null != this.targetType && (b.type = this.targetType), null != this.targetUrl && (b.url = this.targetUrl), 0 !== Object.keys(b).length && (a.target_details = b), a;\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.Models.ClientEventBatch = function () {\n    function a(a, b, c, d, e) {\n      this.status = null != a ? a : Strava.Analytics.Models.ClientEventBatch.Status.UP_FOR_GRABS, this.tries = null != b ? b : 0, this.nextTry = null != c ? c : new Date(0).getTime(), this.uid = null != d ? d : Strava.Analytics.Models.ClientEventBatch.newUuid(), this.createdAt = null != e ? e : new Date().getTime();\n    }\n\n    return a.Status = {\n      UP_FOR_GRABS: "UP_FOR_GRABS",\n      SYNCING: "SYNCING",\n      FAILED: "FAILED",\n      TO_BE_DELETED: "TO_BE_DELETED"\n    }, a.LIFETIME = 1728e5, a.MAX_TRIES = 177, a.newUuid = function () {\n      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (a) {\n        var b, c;\n        return b = 16 * Math.random() | 0, c = "x" === a ? b : 3 & b | 8, c.toString(16);\n      });\n    }, a.backoffAfter = function (a) {\n      var b;\n      return b = a > 10 ? 10 : a, 1e3 * Math.pow(2, b);\n    }, a.prototype.markForDeletion = function () {\n      return this.status = Strava.Analytics.Models.ClientEventBatch.Status.TO_BE_DELETED;\n    }, a.prototype.markAsFailed = function () {\n      return this.status = Strava.Analytics.Models.ClientEventBatch.Status.FAILED;\n    }, a.prototype.needsRetry = function () {\n      return this.tries += 1, this.tries >= Strava.Analytics.Models.ClientEventBatch.MAX_TRIES ? this.status = Strava.Analytics.Models.ClientEventBatch.Status.TO_BE_DELETED : (this.status = Strava.Analytics.Models.ClientEventBatch.Status.UP_FOR_GRABS, this.nextTry = new Date().getTime() + Strava.Analytics.Models.ClientEventBatch.backoffAfter(this.tries));\n    }, a.prototype.toJson = function (a) {\n      return {\n        uid: this.uid,\n        client_events: a.map(function (a) {\n          return a.toJson();\n        })\n      };\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.ClientEventsRepository = function () {\n    function a(a, b) {\n      this.table = a, this.database = b;\n    }\n\n    return a.prototype.inBatch = function (a) {\n      return this.table.where("batchId").equals(a).toArray();\n    }, a.prototype.batchless = function () {\n      return this.table.filter(function (a) {\n        return void 0 === a.batchId;\n      }).toArray();\n    }, a.prototype.load = function (a) {\n      return this.table.get(a);\n    }, a.prototype.save = function (a) {\n      return this.table.put(a).then(function (b) {\n        return a.id = b, a;\n      });\n    }, a.prototype.saveAll = function (a) {\n      return this.database.transaction("rw", this.table, function (b) {\n        return function () {\n          return Dexie.Promise.all(a.map(function (a) {\n            return b.save(a);\n          }));\n        };\n      }(this));\n    }, a.prototype.deleteInBatch = function (a) {\n      return this.table.where("batchId").equals(a)["delete"]();\n    }, a.prototype.deleteOlderThan = function (a) {\n      return this.table.where("createdAt").below(a)["delete"]();\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.ClientEventBatchesRepository = function () {\n    function a(a, b) {\n      this.table = a, this.database = b;\n    }\n\n    return a.prototype.save = function (a) {\n      return this.table.put(a).then(function (b) {\n        return a.id = b, a;\n      });\n    }, a.prototype.saveAll = function (a) {\n      return this.database.transaction("rw", this.table, function (b) {\n        return function () {\n          return Dexie.Promise.all(a.map(function (a) {\n            return b.save(a);\n          }));\n        };\n      }(this));\n    }, a.prototype.load = function (a) {\n      return this.table.get(a);\n    }, a.prototype.retriableBefore = function (a) {\n      return this.table.where("status").equals(Strava.Analytics.Models.ClientEventBatch.Status.UP_FOR_GRABS).and(function (b) {\n        return b.nextTry <= a;\n      }).sortBy("nextTry");\n    }, a.prototype.upForDeletion = function () {\n      return this.table.where("status").equals(Strava.Analytics.Models.ClientEventBatch.Status.TO_BE_DELETED).or("status").equals(Strava.Analytics.Models.ClientEventBatch.Status.FAILED).toArray();\n    }, a.prototype["delete"] = function (a) {\n      return this.table["delete"](a.id).then(function (b) {\n        return a;\n      });\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.SchedulingPredicate = function () {\n    function a(a) {\n      this.predicateFactory = a, this.predicate = this.predicateFactory.newPredicate();\n    }\n\n    return a.alwaysTrue = function () {\n      var a;\n      return a = {\n        newPredicate: function newPredicate() {\n          return {\n            apply: function apply(a) {\n              return !0;\n            }\n          };\n        }\n      }, new Strava.Analytics.SchedulingPredicate(a);\n    }, a.alwaysFalse = function () {\n      var a;\n      return a = {\n        newPredicate: function newPredicate() {\n          return {\n            apply: function apply(a) {\n              return !1;\n            }\n          };\n        }\n      }, new Strava.Analytics.SchedulingPredicate(a);\n    }, a.newAccumulatingPredicate = function (a) {\n      var b;\n      return b = {\n        newPredicate: function newPredicate() {\n          var b;\n          return b = 0, {\n            apply: function apply(c) {\n              return ++b >= a;\n            }\n          };\n        }\n      }, new Strava.Analytics.SchedulingPredicate(b);\n    }, a.prototype.shouldProcess = function (a) {\n      return !!this.predicate.apply(a) && (this.reset(), !0);\n    }, a.prototype.reset = function () {\n      return this.predicate = this.predicateFactory.newPredicate();\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.RunLoop = function () {\n    function a(a, b, c, d, e) {\n      this.processor = a, this.period = b, this.name = c, this.errorHandler = d, this.schedulingPredicate = null != e ? e : Strava.Analytics.SchedulingPredicate.alwaysTrue(), this.running = !1;\n    }\n\n    return a.prototype.run = function () {\n      return this.processor()["catch"](this.errorHandler)["finally"](function (a) {\n        return function () {\n          return a.setTimer();\n        };\n      }(this));\n    }, a.prototype.suspend = function () {\n      return this.running && (this.timer = clearInterval(this.timer)), this.running = !1;\n    }, a.prototype.setTimer = function () {\n      this.running || (this.timer = setInterval(function (a) {\n        return function () {\n          return a.timerFire();\n        };\n      }(this), this.period)), this.running = !0;\n    }, a.prototype.offer = function (a) {\n      if (this.running && this.schedulingPredicate.shouldProcess(a)) return this.suspend(), this.run();\n    }, a.prototype.timerFire = function () {\n      return this.schedulingPredicate.reset(), this.processor()["catch"](this.errorHandler);\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.GarbageCollector = function () {\n    function a(a, b, c) {\n      this.clientEventsRepository = a, this.clientEventBatchesRepository = b, this.database = c;\n    }\n\n    return a.GARBAGE_COLLECTION_PERIODICITY_MS = 3e4, a.newRunLoop = function (a, b, c, d) {\n      var e;\n      return e = new Strava.Analytics.GarbageCollector(a, b, c), new Strava.Analytics.RunLoop(function () {\n        return e.collectGarbage();\n      }, Strava.Analytics.GarbageCollector.GARBAGE_COLLECTION_PERIODICITY_MS, "gc", d, Strava.Analytics.SchedulingPredicate.alwaysFalse());\n    }, a.prototype.collectGarbage = function () {\n      var a;\n      return a = new Date().getTime() - Strava.Analytics.Models.ClientEventBatch.LIFETIME, this.database.transaction("rw", this.clientEventsRepository.table, this.clientEventBatchesRepository.table, function (b) {\n        return function () {\n          return b.deleteCompletedAndFailedBatches().then(function (c) {\n            return b.clientEventsRepository.deleteOlderThan(a);\n          });\n        };\n      }(this));\n    }, a.prototype.deleteCompletedAndFailedBatches = function () {\n      return this.clientEventBatchesRepository.upForDeletion().then(function (a) {\n        return function (b) {\n          var c;\n          return c = b.map(function (b) {\n            return a.clientEventsRepository.deleteInBatch(b.id).then(function () {\n              return a.clientEventBatchesRepository["delete"](b).then(function () {\n                return b.id;\n              });\n            });\n          }), Dexie.Promise.all(c);\n        };\n      }(this));\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.RemoteLogger = function () {\n    function a(a, b, c) {\n      this.clientEventsRepository = a, this.clientEventBatchesRepository = b, this.requestHeaders = c.request_headers || {};\n    }\n\n    return a.REMOTE_ENDPOINT = "/logging/v2/events", a.TIMEOUT = 3, a.TOO_MANY_REQUESTS_STATUS = 429, a.LOG_PERIODICITY_MS = 15e3, a.newRunLoop = function (a, b, c, d, e) {\n      var f;\n      return f = new Strava.Analytics.RemoteLogger(a, b, c), new Strava.Analytics.RunLoop(function () {\n        return f.logPendingBatches().then(function (a) {\n          return a.forEach(function (a) {\n            return d.offer(a);\n          }), a;\n        });\n      }, Strava.Analytics.RemoteLogger.LOG_PERIODICITY_MS, "sync", e, Strava.Analytics.SchedulingPredicate.alwaysTrue());\n    }, a.prototype.logPendingBatches = function () {\n      return this.clientEventBatchesRepository.retriableBefore(new Date().getTime()).then(function (a) {\n        return function (b) {\n          return b.forEach(function (a) {\n            return a.status = Strava.Analytics.Models.ClientEventBatch.SYNCING;\n          }), a.clientEventBatchesRepository.saveAll(b).then(function (b) {\n            return b = b.map(function (b) {\n              return a.clientEventsRepository.inBatch(b.id).then(function (c) {\n                return a.logBatch(b, c).then(function (b) {\n                  return a.clientEventBatchesRepository.save(b);\n                });\n              });\n            }), Dexie.Promise.all(b);\n          });\n        };\n      }(this));\n    }, a.prototype.logBatch = function (a, b) {\n      return new Dexie.Promise(function (c) {\n        return function (d, e) {\n          var f, g, h, i;\n          i = new XMLHttpRequest(), i.onreadystatechange = function () {\n            var b, c;\n\n            if (i.DONE === i.readyState) {\n              switch (b = i.status, c = Math.floor(b / 100)) {\n                case 2:\n                  a.markForDeletion();\n                  break;\n\n                case 4:\n                  b === Strava.Analytics.RemoteLogger.TOO_MANY_REQUESTS_STATUS ? a.needsRetry() : a.markAsFailed();\n                  break;\n\n                default:\n                  a.needsRetry();\n              }\n\n              return d(a);\n            }\n          }, i.open("POST", "" + Strava.Analytics.RemoteLogger.REMOTE_ENDPOINT, !0), i.setRequestHeader("Content-Type", "application/json"), h = c.requestHeaders;\n\n          for (f in h) {\n            g = h[f], i.setRequestHeader(f, g);\n          }\n\n          return i.send(JSON.stringify(a.toJson(b)));\n        };\n      }(this));\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.Batcher = function () {\n    function a(a, b, c) {\n      this.clientEventsRepository = a, this.clientEventBatchesRepository = b, this.database = c;\n    }\n\n    return a.MAXIMUM_BATCH_SIZE = 10, a.BATCH_PERIODICITY_MS = 1e4, a.newRunLoop = function (a, b, c, d, e) {\n      var f, g;\n      return f = new Strava.Analytics.Batcher(a, b, c), g = Strava.Analytics.SchedulingPredicate.newAccumulatingPredicate(Strava.Analytics.Batcher.MAXIMUM_BATCH_SIZE), new Strava.Analytics.RunLoop(function () {\n        return f.batchEvents().then(function (a) {\n          return a.forEach(function (a) {\n            return d.offer(a);\n          }), a;\n        });\n      }, Strava.Analytics.Batcher.BATCH_PERIODICITY_MS, "batch", e, g);\n    }, a.prototype.batchEvents = function () {\n      return this.database.transaction("rw", this.clientEventsRepository.table, this.clientEventBatchesRepository.table, function (a) {\n        return function () {\n          return a.clientEventsRepository.batchless().then(function (b) {\n            var c, d, e;\n\n            if (0 !== b.length) {\n              for (d = new Array(); 0 !== b.length;) {\n                e = b.splice(0, Strava.Analytics.Batcher.MAXIMUM_BATCH_SIZE), d.push(e);\n              }\n\n              return c = d.map(function (b) {\n                var c;\n                return c = new Strava.Analytics.Models.ClientEventBatch(), a.clientEventBatchesRepository.save(c).then(function (c) {\n                  return b.forEach(function (a) {\n                    return a.batchId = c.id;\n                  }), a.clientEventsRepository.saveAll(b).then(function () {\n                    return c;\n                  });\n                });\n              }), Dexie.Promise.all(c);\n            }\n\n            return new Array();\n          });\n        };\n      }(this));\n    }, a;\n  }();\n}.call(this), function () {\n  Strava.Analytics.Tracker = function () {\n    function a() {}\n\n    return a.prototype.trackScreenEnter = function (a) {\n      return this.track(Strava.Analytics.Models.ClientEvent.newScreenEnter(a));\n    }, a.prototype.trackScreenExit = function (a) {\n      return this.track(Strava.Analytics.Models.ClientEvent.newScreenExit(a));\n    }, a.prototype.trackClick = function (a) {\n      return this.track(Strava.Analytics.Models.ClientEvent.newClick(a));\n    }, a.prototype.trackKudo = function (a) {\n      return this.track(Strava.Analytics.Models.ClientEvent.newKudo(a));\n    }, a.prototype.trackComment = function (a) {\n      return this.track(Strava.Analytics.Models.ClientEvent.newComment(a));\n    }, a;\n  }();\n}.call(this), function () {\n  var a = function a(_a, c) {\n    function d() {\n      this.constructor = _a;\n    }\n\n    for (var e in c) {\n      b.call(c, e) && (_a[e] = c[e]);\n    }\n\n    return d.prototype = c.prototype, _a.prototype = new d(), _a.__super__ = c.prototype, _a;\n  },\n      b = {}.hasOwnProperty;\n\n  Strava.Analytics.DirectTracker = function (b) {\n    function c(a) {\n      null == a && (a = {}), this.requestHeaders = a.request_headers || {};\n    }\n\n    return a(c, b), c.LOGGING_ENDPOINT = "/logging/v2/events", c.prototype.track = function (a) {\n      var b, c, d, e, f;\n      b = new Strava.Analytics.Models.ClientEventBatch(), f = new XMLHttpRequest(), f.open("POST", "" + Strava.Analytics.RemoteLogger.REMOTE_ENDPOINT, !0), f.setRequestHeader("Content-Type", "application/json"), e = this.requestHeaders;\n\n      for (c in e) {\n        d = e[c], f.setRequestHeader(c, d);\n      }\n\n      return f.send(JSON.stringify(b.toJson([a])));\n    }, c;\n  }(Strava.Analytics.Tracker);\n}.call(this), function () {\n  var a = function a(_a2, c) {\n    function d() {\n      this.constructor = _a2;\n    }\n\n    for (var e in c) {\n      b.call(c, e) && (_a2[e] = c[e]);\n    }\n\n    return d.prototype = c.prototype, _a2.prototype = new d(), _a2.__super__ = c.prototype, _a2;\n  },\n      b = {}.hasOwnProperty;\n\n  Strava.Analytics.PersistingTracker = function (b) {\n    function c(a, b, c) {\n      this.clientEventsRepository = a, this.batcherRunLoop = b, this.errorHandler = c;\n    }\n\n    return a(c, b), c.prototype.track = function (a) {\n      return this.clientEventsRepository.save(a).then(function (a) {\n        return function (b) {\n          return a.batcherRunLoop.offer(b), b;\n        };\n      }(this))["catch"](this.errorHandler);\n    }, c;\n  }(Strava.Analytics.Tracker);\n}.call(this), function () {\n  Strava.Analytics.DATABASE_VERSION = 1, Strava.Analytics.DATABASE_NAME = "Analytics", Strava.Analytics.openDatabase = function (a) {\n    return a.open();\n  }, Strava.Analytics.mapModels = function (a) {\n    return a.clientEvents.mapToClass(Strava.Analytics.Models.ClientEvent), a.clientEventBatches.mapToClass(Strava.Analytics.Models.ClientEventBatch), a;\n  }, Strava.Analytics.initializeSchema = function (a) {\n    var b;\n    return b = new Dexie(a), b.version(Strava.Analytics.DATABASE_VERSION).stores({\n      clientEvents: "++id, trackableId, eventType, clientUrl, targetType, batchId, createdAt",\n      clientEventBatches: "++id, uid, status, tries, nextTry, createdAt"\n    }), Dexie.Promise.resolve(b);\n  }, Strava.Analytics.initializeDatabase = function (a, b, c) {\n    return null == b && (b = Strava.Analytics.openDatabase), null == c && (c = Strava.Analytics.mapModels), Strava.Analytics.initializeSchema(a).then(b).then(c);\n  }, Strava.Analytics.persistencePredicate = function () {\n    return window.indexedDB;\n  }, Strava.Analytics.defaultDatabaseInitializationErrorHandler = function (a) {}, Strava.Analytics.defaultDatabaseTransactionErrorHandler = function (a) {}, Strava.Analytics.initialize = function (a, b, c) {\n    var d, e, f, g, h, i, j;\n    return null == b && (b = {}), null == c && (c = Strava.Analytics.initializeDatabase), h = b.remote_logger || {}, d = b.database || {}, e = d.initialization_error_handler || Strava.Analytics.defaultDatabaseInitializationErrorHandler, f = d.transaction_error_handler || Strava.Analytics.defaultDatabaseTransactionErrorHandler, i = null, j = null, g = b.persistence_predicate || Strava.Analytics.persistencePredicate, j = g() ? c(Strava.Analytics.DATABASE_NAME + "_" + a).then(function (a) {\n      var b, c, d, e, g;\n      return d = new Strava.Analytics.ClientEventsRepository(a.clientEvents, a), c = new Strava.Analytics.ClientEventBatchesRepository(a.clientEventBatches, a), e = Strava.Analytics.GarbageCollector.newRunLoop(d, c, a, f), g = Strava.Analytics.RemoteLogger.newRunLoop(d, c, h, e, f), b = Strava.Analytics.Batcher.newRunLoop(d, c, a, g, f), e.run(), g.run(), b.run(), new Strava.Analytics.PersistingTracker(d, b, f);\n    })["catch"](function (a) {\n      return e(a), new Strava.Analytics.DirectTracker(h);\n    }) : Dexie.Promise.resolve(new Strava.Analytics.DirectTracker(h));\n  };\n}.call(this);'},2313:function(n,e,t){t(1226)(t(2314))},2314:function(n,e){n.exports="function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function e(t, n, r) {\n  function s(o, u) {\n    if (!n[o]) {\n      if (!t[o]) {\n        var a = typeof require == \"function\" && require;\n        if (!u && a) return a(o, !0);\n        if (i) return i(o, !0);\n        var f = new Error(\"Cannot find module '\" + o + \"'\");\n        throw f.code = \"MODULE_NOT_FOUND\", f;\n      }\n\n      var l = n[o] = {\n        exports: {}\n      };\n      t[o][0].call(l.exports, function (e) {\n        var n = t[o][1][e];\n        return s(n ? n : e);\n      }, l, l.exports, e, t, n, r);\n    }\n\n    return n[o].exports;\n  }\n\n  var i = typeof require == \"function\" && require;\n\n  for (var o = 0; o < r.length; o++) {\n    s(r[o]);\n  }\n\n  return s;\n})({\n  1: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    module.exports = {\n      VERSION: '1.0.0',\n      DEV_ID: 'i5iSjo',\n      VERSION_PARAM: '&_av',\n      USAGE_PARAM: '&_au',\n      NULL_DIMENSION: '(not set)'\n    };\n  }, {}],\n  2: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    /* eslint no-console: [\"error\", {allow: [\"error\"]}] */\n    // Imports dependencies.\n    var provide = require('../provide');\n    /**\n     * Warns users that this functionality is deprecated as of version 1.0\n     * @deprecated\n     * @constructor\n     */\n\n\n    function Autotrack() {\n      console.error('Warning! Requiring the `autotrack` plugin no longer ' + 'requires ' + ' all sub-plugins by default.\\n' + 'See https://goo.gl/XsXPg5 for details.');\n    }\n\n    provide('autotrack', Autotrack);\n  }, {\n    \"../provide\": 12\n  }],\n  3: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var parseUrl = require('dom-utils/lib/parse-url');\n\n    var constants = require('../constants');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n    /**\n     * Registers clean URL tracking on a tracker object. The clean URL tracker\n     * removes query parameters from the page value reported to Google Analytics.\n     * It also helps to prevent tracking similar URLs, e.g. sometimes ending a URL\n     * with a slash and sometimes not.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function CleanUrlTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.CLEAN_URL_TRACKER);\n      this.opts = assign({\n        stripQuery: false,\n        queryDimensionIndex: null,\n        indexFilename: null,\n        trailingSlash: null\n      }, opts);\n      this.tracker = tracker;\n      this.overrideTrackerBuildHitTask();\n    }\n    /**\n     * Cleans the URL based on the preferences set in the configuration options.\n     * @param {Object} model An analytics.js Model object.\n     */\n\n\n    CleanUrlTracker.prototype.cleanUrlTask = function (model) {\n      var location = model.get('location');\n      var page = model.get('page');\n      var url = parseUrl(page || location);\n      var oldPath = url.pathname;\n      var newPath = oldPath; // If an index filename was provided, remove it if it appears at the end\n      // of the URL.\n\n      if (this.opts.indexFilename) {\n        var parts = newPath.split('/');\n\n        if (this.opts.indexFilename == parts[parts.length - 1]) {\n          parts[parts.length - 1] = '';\n          newPath = parts.join('/');\n        }\n      } // Ensure the URL ends with or doesn't end with slash based on the\n      // `trailingSlash` option. Note that filename URLs should never contain\n      // a trailing slash.\n\n\n      if (this.opts.trailingSlash == 'remove') {\n        newPath = newPath.replace(/\\/+$/, '');\n      } else if (this.opts.trailingSlash == 'add') {\n        var isFilename = /\\.\\w+$/.test(newPath);\n\n        if (!isFilename && newPath.substr(-1) != '/') {\n          newPath = newPath + '/';\n        }\n      } // If a query dimensions index was provided, set the query string portion\n      // of the URL on that dimension. If no query string exists on the URL use\n      // the NULL_DIMENSION.\n\n\n      if (this.opts.stripQuery && this.opts.queryDimensionIndex) {\n        model.set('dimension' + this.opts.queryDimensionIndex, url.query || constants.NULL_DIMENSION);\n      }\n\n      model.set('page', newPath + (!this.opts.stripQuery ? url.search : ''));\n    };\n    /**\n     * Overrides the tracker's `buildHitTask` to check for proper URL formatting\n     * on every hit (not just the initial pageview).\n     */\n\n\n    CleanUrlTracker.prototype.overrideTrackerBuildHitTask = function () {\n      this.originalTrackerBuildHitTask = this.tracker.get('buildHitTask');\n      this.tracker.set('buildHitTask', function (model) {\n        this.cleanUrlTask(model);\n        this.originalTrackerBuildHitTask(model);\n      }.bind(this));\n    };\n    /**\n     * Restores all overridden tasks and methods.\n     */\n\n\n    CleanUrlTracker.prototype.remove = function () {\n      this.tracker.set('sendHitTask', this.originalTrackerSendHitTask);\n    };\n\n    provide('cleanUrlTracker', CleanUrlTracker);\n  }, {\n    \"../constants\": 1,\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"dom-utils/lib/parse-url\": 22,\n    \"object-assign\": 23\n  }],\n  4: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var delegate = require('dom-utils/lib/delegate');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var getAttributeFields = require('../utilities').getAttributeFields;\n    /**\n     * Registers declarative event tracking.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function EventTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.EVENT_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.addEventListener) return;\n      this.opts = assign({\n        events: ['click'],\n        fieldsObj: {},\n        attributePrefix: 'ga-',\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker; // Binds methods.\n\n      this.handleEvents = this.handleEvents.bind(this);\n      var selector = '[' + this.opts.attributePrefix + 'on]'; // Creates a mapping of events to their delegates\n\n      this.delegates = {};\n      this.opts.events.forEach(function (event) {\n        this.delegates[event] = delegate(document, event, selector, this.handleEvents, {\n          composed: true,\n          useCapture: true\n        });\n      }.bind(this));\n    }\n    /**\n     * Handles all clicks on elements with event attributes.\n     * @param {Event} event The DOM click event.\n     * @param {Element} element The delegated DOM element target.\n     */\n\n\n    EventTracker.prototype.handleEvents = function (event, element) {\n      var prefix = this.opts.attributePrefix; // Ensures the event type matches the one specified on the element.\n\n      if (event.type != element.getAttribute(prefix + 'on')) return;\n      var targetTagName = event.target.tagName;\n      var isCurrentTarget = event.target == element;\n      var defaultFields = {\n        transport: 'beacon',\n        targetTagName: targetTagName,\n        isCurrentTarget: isCurrentTarget\n      };\n      var attributeFields = getAttributeFields(element, prefix);\n      var userFields = assign({}, this.opts.fieldsObj, attributeFields);\n      var hitType = attributeFields.hitType || 'event';\n      this.tracker.send(hitType, createFieldsObj(defaultFields, userFields, this.tracker, this.opts.hitFilter, element));\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    EventTracker.prototype.remove = function () {\n      Object.keys(this.delegates).forEach(function (key) {\n        this.delegates[key].destroy();\n      }.bind(this));\n    };\n\n    provide('eventTracker', EventTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"dom-utils/lib/delegate\": 18,\n    \"object-assign\": 23\n  }],\n  5: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var domReady = require('../utilities').domReady;\n\n    var getAttributeFields = require('../utilities').getAttributeFields;\n    /**\n     * Registers impression tracking.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function ImpressionTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.IMPRESSION_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!(window.IntersectionObserver && window.MutationObserver)) return;\n      this.opts = assign({\n        elements: [],\n        rootMargin: '0px',\n        fieldsObj: {},\n        attributePrefix: 'ga-',\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker; // Binds methods.\n\n      this.handleDomMutations = this.handleDomMutations.bind(this);\n      this.walkNodeTree = this.walkNodeTree.bind(this);\n      this.handleIntersectionChanges = this.handleIntersectionChanges.bind(this);\n      this.startObserving = this.startObserving.bind(this);\n      this.observeElement = this.observeElement.bind(this);\n      this.handleDomElementRemoved = this.handleDomElementRemoved.bind(this);\n      var data = this.deriveDataFromConfigOptions(); // The primary list of elements to observe. Each item contains the\n      // element ID, threshold, and whether it's currently in-view.\n\n      this.items = data.items; // A hash map of elements contained in the items array.\n\n      this.elementMap = data.elementMap; // A sorted list of threshold values contained in the items array.\n\n      this.threshold = data.threshold;\n      this.intersectionObserver = this.initIntersectionObserver();\n      this.mutationObserver = this.initMutationObserver(); // Once the DOM is ready, start observing for changes.\n\n      domReady(this.startObserving);\n    }\n    /**\n     * Loops through each element in the `elements` configuration option and\n     * creates a map of element IDs currently being observed, a list of \"items\"\n     * (which contains each element's `threshold` and `trackFirstImpressionOnly`\n     * property), and a list of `threshold` values to pass to the\n     * `IntersectionObserver` instance.\n     * @return {Object} An object with the properties `items`, `elementMap`\n     *     and `threshold`.\n     */\n\n\n    ImpressionTracker.prototype.deriveDataFromConfigOptions = function () {\n      var items = [];\n      var threshold = []; // A map of element IDs in the `items` array to DOM elements in the document.\n      // The presence of a key indicates that the element ID is in the `items`\n      // array, and the presence of an element value indicates that the element\n      // is in the DOM.\n\n      var elementMap = {};\n      this.opts.elements.forEach(function (item) {\n        // The item can be just a string if it's OK with all the defaults.\n        if (typeof item == 'string') item = {\n          id: item\n        };\n        items.push(item = assign({\n          threshold: 0,\n          trackFirstImpressionOnly: true\n        }, item));\n        elementMap[item.id] = null;\n        threshold.push(item.threshold);\n      });\n      return {\n        items: items,\n        elementMap: elementMap,\n        threshold: threshold\n      };\n    };\n    /**\n     * Initializes a new `MutationObsever` instance and registers the callback.\n     * @return {MutationObserver} The new MutationObserver instance.\n     */\n\n\n    ImpressionTracker.prototype.initMutationObserver = function () {\n      return new MutationObserver(this.handleDomMutations);\n    };\n    /**\n     * Initializes a new `IntersectionObsever` instance with the appropriate\n     * options and registers the callback.\n     * @return {IntersectionObserver} The newly created instance.\n     */\n\n\n    ImpressionTracker.prototype.initIntersectionObserver = function () {\n      return new IntersectionObserver(this.handleIntersectionChanges, {\n        rootMargin: this.opts.rootMargin,\n        threshold: this.threshold\n      });\n    };\n    /**\n     * Starts observing each eleemnt to intersections as well as the entire DOM\n     * for node changes.\n     */\n\n\n    ImpressionTracker.prototype.startObserving = function () {\n      // Start observing elements for intersections.\n      Object.keys(this.elementMap).forEach(this.observeElement); // Start observing the DOM for added and removed elements.\n\n      this.mutationObserver.observe(document.body, {\n        childList: true,\n        subtree: true\n      }); // TODO(philipwalton): Remove temporary hack to force a new frame\n      // immediately after adding observers.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=612323\n\n      requestAnimationFrame(function () {});\n    };\n    /**\n     * Adds an element to the `elementMap` map and registers it for observation\n     * on `this.intersectionObserver`.\n     * @param {string} id The ID of the element to observe.\n     */\n\n\n    ImpressionTracker.prototype.observeElement = function (id) {\n      var element = this.elementMap[id] || (this.elementMap[id] = document.getElementById(id));\n      if (element) this.intersectionObserver.observe(element);\n    };\n    /**\n     * Handles nodes being added or removed from the DOM. This function is passed\n     * as the callback to `this.mutationObserver`.\n     * @param {Array} mutations A list of `MutationRecord` instances\n     */\n\n\n    ImpressionTracker.prototype.handleDomMutations = function (mutations) {\n      for (var i = 0, mutation; mutation = mutations[i]; i++) {\n        // Handles removed elements.\n        for (var k = 0, removedEl; removedEl = mutation.removedNodes[k]; k++) {\n          this.walkNodeTree(removedEl, this.handleDomElementRemoved);\n        } // Handles added elements.\n\n\n        for (var j = 0, addedEl; addedEl = mutation.addedNodes[j]; j++) {\n          this.walkNodeTree(addedEl, this.observeElement);\n        }\n      }\n    };\n    /**\n     * Iterates through all descendents of a DOM node and invokes the passed\n     * callback if any of them match an elememt in `elementMap`.\n     * @param {Node} node The DOM node to walk.\n     * @param {Function} callback A function to be invoked if a match is found.\n     */\n\n\n    ImpressionTracker.prototype.walkNodeTree = function (node, callback) {\n      if (node.nodeType == 1 && node.id in this.elementMap) {\n        callback(node.id);\n      }\n\n      for (var i = 0, child; child = node.childNodes[i]; i++) {\n        this.walkNodeTree(child, callback);\n      }\n    };\n    /**\n     * Handles intersection changes. This function is passed as the callback to\n     * `this.intersectionObserver`\n     * @param {Array} records A list of `IntersectionObserverEntry` records.\n     */\n\n\n    ImpressionTracker.prototype.handleIntersectionChanges = function (records) {\n      for (var i = 0, record; record = records[i]; i++) {\n        for (var j = 0, item; item = this.items[j]; j++) {\n          if (record.target.id !== item.id) continue;\n\n          if (isTargetVisible(item.threshold, record)) {\n            this.handleImpression(item.id, true);\n\n            if (item.trackFirstImpressionOnly) {\n              this.items.splice(j, 1);\n              j--;\n              this.possiblyUnobserveElement(item.id);\n            }\n          } else {\n            this.handleImpression(item.id, false);\n          }\n        }\n      } // If all items have been removed, remove the plugin.\n\n\n      if (this.items.length === 0) this.remove();\n    };\n    /**\n     * Sends a hit to Google Analytics with the impression data.\n     * @param {string} id The ID of the element making the impression.\n     */\n\n\n    ImpressionTracker.prototype.handleImpression = function (id, visible) {\n      var element = document.getElementById(id);\n      var defaultFields = {\n        transport: 'beacon',\n        eventCategory: 'Viewport',\n        eventAction: 'impression',\n        eventLabel: id,\n        eventVisible: visible\n      };\n      var userFields = assign({}, this.opts.fieldsObj, getAttributeFields(element, this.opts.attributePrefix));\n      this.tracker.send('event', createFieldsObj(defaultFields, userFields, this.tracker, this.opts.hitFilter, element));\n    };\n    /**\n     * Inspects the `items` array after an item was removed. If the removed\n     * item's element ID is not found in any other item, the element stops being\n     * observed for intersection changes and is removed from `elementMap`.\n     * @param {string} id The element ID to check for possible unobservation.\n     */\n\n\n    ImpressionTracker.prototype.possiblyUnobserveElement = function (id) {\n      if (!this.itemsIncludesId(id)) {\n        this.intersectionObserver.unobserve(this.elementMap[id]);\n        delete this.elementMap[id];\n      }\n    };\n    /**\n     * Handles an element currently being observed for intersections being removed\n     * from the DOM.\n     * @param {string} id The ID of the element that was removed.\n     */\n\n\n    ImpressionTracker.prototype.handleDomElementRemoved = function (id) {\n      this.intersectionObserver.unobserve(this.elementMap[id]);\n      this.elementMap[id] = null;\n    };\n    /**\n     * Scans the `items` array for the presense of an item with the passed ID.\n     * @param {string} id The ID of the element to search for.\n     * @return {boolean} True if the element ID was found in one of the items.\n     */\n\n\n    ImpressionTracker.prototype.itemsIncludesId = function (id) {\n      return this.items.some(function (item) {\n        return id == item.id;\n      });\n    };\n    /**\n     * Removes all listeners and observers.\n     */\n\n\n    ImpressionTracker.prototype.remove = function () {\n      this.mutationObserver.disconnect();\n      this.intersectionObserver.disconnect();\n    };\n\n    provide('impressionTracker', ImpressionTracker);\n    /**\n     * Detects whether or not an intersection record represents a visible target\n     * given a particular threshold.\n     * @param {number} threshold The threshold the target is visible above.\n     * @param {IntersectionObserverEntry} record The most recent record entry.\n     * @return {boolean} True if the target is visible.\n     */\n\n    function isTargetVisible(threshold, record) {\n      if (threshold === 0) {\n        var i = record.intersectionRect;\n        return i.top > 0 || i.bottom > 0 || i.left > 0 || i.right > 0;\n      } else {\n        return record.intersectionRatio >= threshold;\n      }\n    }\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"object-assign\": 23\n  }],\n  6: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var debounce = require('debounce');\n\n    var constants = require('../constants');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var isObject = require('../utilities').isObject;\n\n    var toArray = require('../utilities').toArray;\n    /**\n     * Declares the MediaQueryListener instance cache.\n     */\n\n\n    var mediaMap = {};\n    /**\n     * Registers media query tracking.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n    function MediaQueryTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.MEDIA_QUERY_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.matchMedia) return;\n      this.opts = assign({\n        definitions: null,\n        changeTemplate: this.changeTemplate,\n        changeTimeout: 1000,\n        fieldsObj: {},\n        hitFilter: null\n      }, opts); // Exits early if media query data doesn't exist.\n\n      if (!isObject(this.opts.definitions)) return;\n      this.opts.definitions = toArray(this.opts.definitions);\n      this.tracker = tracker;\n      this.changeListeners = [];\n      this.processMediaQueries();\n    }\n    /**\n     * Loops through each media query definition, sets the custom dimenion data,\n     * and adds the change listeners.\n     */\n\n\n    MediaQueryTracker.prototype.processMediaQueries = function () {\n      this.opts.definitions.forEach(function (definition) {\n        // Only processes definitions with a name and index.\n        if (definition.name && definition.dimensionIndex) {\n          var mediaName = this.getMatchName(definition);\n          this.tracker.set('dimension' + definition.dimensionIndex, mediaName);\n          this.addChangeListeners(definition);\n        }\n      }.bind(this));\n    };\n    /**\n     * Takes a definition object and return the name of the matching media item.\n     * If no match is found, the NULL_DIMENSION value is returned.\n     * @param {Object} definition A set of named media queries associated\n     *     with a single custom dimension.\n     * @return {string} The name of the matched media or NULL_DIMENSION.\n     */\n\n\n    MediaQueryTracker.prototype.getMatchName = function (definition) {\n      var match;\n      definition.items.forEach(function (item) {\n        if (getMediaListener(item.media).matches) {\n          match = item;\n        }\n      });\n      return match ? match.name : constants.NULL_DIMENSION;\n    };\n    /**\n     * Adds change listeners to each media query in the definition list.\n     * Debounces the changes to prevent unnecessary hits from being sent.\n     * @param {Object} definition A set of named media queries associated\n     *     with a single custom dimension\n     */\n\n\n    MediaQueryTracker.prototype.addChangeListeners = function (definition) {\n      definition.items.forEach(function (item) {\n        var mql = getMediaListener(item.media);\n        var fn = debounce(function () {\n          this.handleChanges(definition);\n        }.bind(this), this.opts.changeTimeout);\n        mql.addListener(fn);\n        this.changeListeners.push({\n          mql: mql,\n          fn: fn\n        });\n      }.bind(this));\n    };\n    /**\n     * Handles changes to the matched media. When the new value differs from\n     * the old value, a change event is sent.\n     * @param {Object} definition A set of named media queries associated\n     *     with a single custom dimension\n     */\n\n\n    MediaQueryTracker.prototype.handleChanges = function (definition) {\n      var newValue = this.getMatchName(definition);\n      var oldValue = this.tracker.get('dimension' + definition.dimensionIndex);\n\n      if (newValue !== oldValue) {\n        this.tracker.set('dimension' + definition.dimensionIndex, newValue);\n        var defaultFields = {\n          eventCategory: definition.name,\n          eventAction: 'change',\n          eventLabel: this.opts.changeTemplate(oldValue, newValue)\n        };\n        this.tracker.send('event', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n      }\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    MediaQueryTracker.prototype.remove = function () {\n      for (var i = 0, listener; listener = this.changeListeners[i]; i++) {\n        listener.mql.removeListener(listener.fn);\n      }\n    };\n    /**\n     * Sets the default formatting of the change event label.\n     * This can be overridden by setting the `changeTemplate` option.\n     * @param {string} oldValue The value of the media query prior to the change.\n     * @param {string} newValue The value of the media query after the change.\n     * @return {string} The formatted event label.\n     */\n\n\n    MediaQueryTracker.prototype.changeTemplate = function (oldValue, newValue) {\n      return oldValue + ' => ' + newValue;\n    };\n    /**\n     * Accepts a media query and returns a MediaQueryListener object.\n     * Caches the values to avoid multiple unnecessary instances.\n     * @param {string} media A media query value.\n     * @return {MediaQueryListener} The matched media.\n     */\n\n\n    function getMediaListener(media) {\n      // Returns early if the media is cached.\n      if (mediaMap[media]) return mediaMap[media];\n      mediaMap[media] = window.matchMedia(media);\n      return mediaMap[media];\n    }\n\n    provide('mediaQueryTracker', MediaQueryTracker);\n  }, {\n    \"../constants\": 1,\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"debounce\": 16,\n    \"object-assign\": 23\n  }],\n  7: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var delegate = require('dom-utils/lib/delegate');\n\n    var parseUrl = require('dom-utils/lib/parse-url');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var getAttributeFields = require('../utilities').getAttributeFields;\n\n    var withTimeout = require('../utilities').withTimeout;\n    /**\n     * Registers outbound form tracking.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function OutboundFormTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.OUTBOUND_FORM_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.addEventListener) return;\n      this.opts = assign({\n        formSelector: 'form',\n        shouldTrackOutboundForm: this.shouldTrackOutboundForm,\n        fieldsObj: {},\n        attributePrefix: 'ga-',\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker;\n      this.delegate = delegate(document, 'submit', 'form', this.handleFormSubmits.bind(this), {\n        composed: true,\n        useCapture: true\n      });\n    }\n    /**\n     * Handles all submits on form elements. A form submit is considered outbound\n     * if its action attribute starts with http and does not contain\n     * location.hostname.\n     * When the beacon transport method is not available, the event's default\n     * action is prevented and re-emitted after the hit is sent.\n     * @param {Event} event The DOM submit event.\n     * @param {Element} form The delegated event target.\n     */\n\n\n    OutboundFormTracker.prototype.handleFormSubmits = function (event, form) {\n      var action = parseUrl(form.action).href;\n      var defaultFields = {\n        transport: 'beacon',\n        eventCategory: 'Outbound Form',\n        eventAction: 'submit',\n        eventLabel: action\n      };\n\n      if (this.opts.shouldTrackOutboundForm(form, parseUrl)) {\n        if (!navigator.sendBeacon) {\n          // Stops the submit and waits until the hit is complete (with timeout)\n          // for browsers that don't support beacon.\n          event.preventDefault();\n          defaultFields.hitCallback = withTimeout(function () {\n            form.submit();\n          });\n        }\n\n        var userFields = assign({}, this.opts.fieldsObj, getAttributeFields(form, this.opts.attributePrefix));\n        this.tracker.send('event', createFieldsObj(defaultFields, userFields, this.tracker, this.opts.hitFilter, form));\n      }\n    };\n    /**\n     * Determines whether or not the tracker should send a hit when a form is\n     * submitted. By default, forms with an action attribute that starts with\n     * \"http\" and doesn't contain the current hostname are tracked.\n     * @param {Element} form The form that was submitted.\n     * @param {Function} parseUrl A cross-browser utility method for url parsing.\n     * @return {boolean} Whether or not the form should be tracked.\n     */\n\n\n    OutboundFormTracker.prototype.shouldTrackOutboundForm = function (form, parseUrl) {\n      var url = parseUrl(form.action);\n      return url.hostname != location.hostname && url.protocol.slice(0, 4) == 'http';\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    OutboundFormTracker.prototype.remove = function () {\n      this.delegate.destroy();\n    };\n\n    provide('outboundFormTracker', OutboundFormTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"dom-utils/lib/delegate\": 18,\n    \"dom-utils/lib/parse-url\": 22,\n    \"object-assign\": 23\n  }],\n  8: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var delegate = require('dom-utils/lib/delegate');\n\n    var parseUrl = require('dom-utils/lib/parse-url');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var getAttributeFields = require('../utilities').getAttributeFields;\n    /**\n     * Registers outbound link tracking on a tracker object.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function OutboundLinkTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.OUTBOUND_LINK_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.addEventListener) return;\n      this.opts = assign({\n        events: ['click'],\n        linkSelector: 'a, area',\n        shouldTrackOutboundLink: this.shouldTrackOutboundLink,\n        fieldsObj: {},\n        attributePrefix: 'ga-',\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker; // Binds methods.\n\n      this.handleLinkInteractions = this.handleLinkInteractions.bind(this); // Creates a mapping of events to their delegates\n\n      this.delegates = {};\n      this.opts.events.forEach(function (event) {\n        this.delegates[event] = delegate(document, event, this.opts.linkSelector, this.handleLinkInteractions, {\n          composed: true,\n          useCapture: true\n        });\n      }.bind(this));\n    }\n    /**\n     * Handles all interactions on link elements. A link is considered an outbound\n     * link if its hostname property does not match location.hostname. When the\n     * beacon transport method is not available, the links target is set to\n     * \"_blank\" to ensure the hit can be sent.\n     * @param {Event} event The DOM click event.\n     * @param {Element} link The delegated event target.\n     */\n\n\n    OutboundLinkTracker.prototype.handleLinkInteractions = function (event, link) {\n      if (this.opts.shouldTrackOutboundLink(link, parseUrl)) {\n        // Opens outbound links in a new tab if the browser doesn't support\n        // the beacon transport method.\n        if (!navigator.sendBeacon) {\n          link.target = '_blank';\n        }\n\n        var href = link.getAttribute('href') || link.getAttribute('xlink:href');\n        var url = parseUrl(href);\n        var defaultFields = {\n          transport: 'beacon',\n          eventCategory: 'Outbound Link',\n          eventAction: event.type,\n          eventLabel: url.href\n        };\n        var userFields = assign({}, this.opts.fieldsObj, getAttributeFields(link, this.opts.attributePrefix));\n        this.tracker.send('event', createFieldsObj(defaultFields, userFields, this.tracker, this.opts.hitFilter, link));\n      }\n    };\n    /**\n     * Determines whether or not the tracker should send a hit when a link is\n     * clicked. By default links with a hostname property not equal to the current\n     * hostname are tracked.\n     * @param {Element} link The link that was clicked on.\n     * @param {Function} parseUrl A cross-browser utility method for url parsing.\n     * @return {boolean} Whether or not the link should be tracked.\n     */\n\n\n    OutboundLinkTracker.prototype.shouldTrackOutboundLink = function (link, parseUrl) {\n      var href = link.getAttribute('href') || link.getAttribute('xlink:href');\n      var url = parseUrl(href);\n      return url.hostname != location.hostname && url.protocol.slice(0, 4) == 'http';\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    OutboundLinkTracker.prototype.remove = function () {\n      Object.keys(this.delegates).forEach(function (key) {\n        this.delegates[key].destroy();\n      }.bind(this));\n    };\n\n    provide('outboundLinkTracker', OutboundLinkTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"dom-utils/lib/delegate\": 18,\n    \"dom-utils/lib/parse-url\": 22,\n    \"object-assign\": 23\n  }],\n  9: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var isObject = require('../utilities').isObject;\n\n    var DEFAULT_SESSION_TIMEOUT = 30; // 30 minutes.\n\n    /**\n     * Registers outbound link tracking on tracker object.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n    function PageVisibilityTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.PAGE_VISIBILITY_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.addEventListener) return;\n      this.opts = assign({\n        sessionTimeout: DEFAULT_SESSION_TIMEOUT,\n        changeTemplate: this.changeTemplate,\n        hiddenMetricIndex: null,\n        visibleMetricIndex: null,\n        fieldsObj: {},\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker;\n      this.visibilityState = document.visibilityState; // Consider the plugin creation to be the start of the visibility change\n      // time calculations.\n\n      this.lastVisibilityChangeTime = +new Date(); // Binds methods to `this`.\n\n      this.handleVisibilityStateChange = this.handleVisibilityStateChange.bind(this);\n      this.overrideTrackerSendMethod();\n      this.overrideTrackerSendHitTask();\n      document.addEventListener('visibilitychange', this.handleVisibilityStateChange);\n    }\n    /**\n     * Handles changes to `document.visibilityState`. This method sends events when\n     * the visibility state changes during active sessions (active meaning the\n     * session has not timed out). If the session has timed out, a return to a\n     * visibility state of visible will trigger a new pageview (instead of a\n     * visibility change event). Lastly, this method keeps track of the elapsed\n     * time a document's visibility state was visible and sends that as the event\n     * value for hidden events, allowing you to more accurately derive how long\n     * a user spent active during a session.\n     */\n\n\n    PageVisibilityTracker.prototype.handleVisibilityStateChange = function () {\n      var defaultFields;\n      this.prevVisibilityState = this.visibilityState;\n      this.visibilityState = document.visibilityState;\n\n      if (this.sessionHasTimedOut()) {\n        // Prevents sending 'hidden' state hits when the session has timed out.\n        if (this.visibilityState == 'hidden') return;\n\n        if (this.visibilityState == 'visible') {\n          // If the session has timed out, a transition to \"visible\" should be\n          // considered a new pageview and a new session.\n          defaultFields = {\n            transport: 'beacon'\n          };\n          this.tracker.send('pageview', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n        }\n      } else {\n        // Rounds the time up to the nearest second. If the rounded value is zero\n        // use 1 instead since unset metrics default to 0.\n        var timeDeltaInSeconds = Math.round((new Date() - this.lastVisibilityChangeTime) / 1000) || 1;\n        defaultFields = {\n          transport: 'beacon',\n          eventCategory: 'Page Visibility',\n          eventAction: 'change',\n          eventLabel: this.opts.changeTemplate(this.prevVisibilityState, this.visibilityState),\n          eventValue: timeDeltaInSeconds\n        }; // Changes to hidden are non interaction hits by default\n\n        if (this.visibilityState == 'hidden') defaultFields.nonInteraction = true; // If a custom metric was specified for the current visibility state,\n        // give it the same as the event value.\n\n        var metric = this.opts[this.prevVisibilityState + 'MetricIndex'];\n        if (metric) defaultFields['metric' + metric] = timeDeltaInSeconds;\n        this.tracker.send('event', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n      } // Updates the time the last visibility state change event occurred, so\n      // change events can report the delta.\n\n\n      this.lastVisibilityChangeTime = +new Date();\n    };\n    /**\n     * Returns true if the session has not timed out. A session timeout occurs when\n     * more than `this.opts.sessionTimeout` minutes has elapsed since the\n     * tracker sent the previous hit.\n     * @return {boolean} True if the session has timed out.\n     */\n\n\n    PageVisibilityTracker.prototype.sessionHasTimedOut = function () {\n      var minutesSinceLastHit = (new Date() - this.lastHitTime) / (60 * 1000);\n      return this.opts.sessionTimeout < minutesSinceLastHit;\n    };\n    /**\n     * Overrides the `tracker.send` method to send a pageview hit before the\n     * current hit being sent if the session has timed out and the current hit is\n     * not a pageview itself.\n     */\n\n\n    PageVisibilityTracker.prototype.overrideTrackerSendMethod = function () {\n      this.originalTrackerSendMethod = this.tracker.send;\n\n      this.tracker.send = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var firstArg = args[0];\n        var hitType = isObject(firstArg) ? firstArg.hitType : firstArg;\n        var isPageview = hitType == 'pageview';\n\n        if (!isPageview && this.sessionHasTimedOut()) {\n          var defaultFields = {\n            transport: 'beacon'\n          };\n          this.originalTrackerSendMethod.call(this.tracker, 'pageview', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n        }\n\n        this.originalTrackerSendMethod.apply(this.tracker, args);\n      }.bind(this);\n    };\n    /**\n     * Overrides the tracker's `sendHitTask` to record the time of the previous\n     * hit. This is used to determine whether or not a session has timed out.\n     */\n\n\n    PageVisibilityTracker.prototype.overrideTrackerSendHitTask = function () {\n      this.originalTrackerSendHitTask = this.tracker.get('sendHitTask');\n      this.lastHitTime = +new Date();\n      this.tracker.set('sendHitTask', function (model) {\n        this.originalTrackerSendHitTask(model);\n        this.lastHitTime = +new Date();\n      }.bind(this));\n    };\n    /**\n     * Sets the default formatting of the change event label.\n     * This can be overridden by setting the `changeTemplate` option.\n     * @param {string} oldValue The value of the media query prior to the change.\n     * @param {string} newValue The value of the media query after the change.\n     * @return {string} The formatted event label.\n     */\n\n\n    PageVisibilityTracker.prototype.changeTemplate = function (oldValue, newValue) {\n      return oldValue + ' => ' + newValue;\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    PageVisibilityTracker.prototype.remove = function () {\n      this.tracker.set('sendHitTask', this.originalTrackerSendHitTask);\n      this.tracker.send = this.originalTrackerSendMethod;\n      document.removeEventListener('visibilitychange', this.handleVisibilityStateChange);\n    };\n\n    provide('pageVisibilityTracker', PageVisibilityTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"object-assign\": 23\n  }],\n  10: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    /* global FB, twttr */\n    var assign = require('object-assign');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n    /**\n     * Registers social tracking on tracker object.\n     * Supports both declarative social tracking via HTML attributes as well as\n     * tracking for social events when using official Twitter or Facebook widgets.\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function SocialWidgetTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.SOCIAL_WIDGET_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!window.addEventListener) return;\n      this.opts = assign({\n        fieldsObj: {},\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker; // Binds methods to `this`.\n\n      this.addWidgetListeners = this.addWidgetListeners.bind(this);\n      this.addTwitterEventHandlers = this.addTwitterEventHandlers.bind(this);\n      this.handleTweetEvents = this.handleTweetEvents.bind(this);\n      this.handleFollowEvents = this.handleFollowEvents.bind(this);\n      this.handleLikeEvents = this.handleLikeEvents.bind(this);\n      this.handleUnlikeEvents = this.handleUnlikeEvents.bind(this);\n\n      if (document.readyState != 'complete') {\n        // Adds the widget listeners after the window's `load` event fires.\n        // If loading widgets using the officially recommended snippets, they\n        // will be available at `window.load`. If not users can call the\n        // `addWidgetListeners` method manually.\n        window.addEventListener('load', this.addWidgetListeners);\n      } else {\n        this.addWidgetListeners();\n      }\n    }\n    /**\n     * Invokes the methods to add Facebook and Twitter widget event listeners.\n     * Ensures the respective global namespaces are present before adding.\n     */\n\n\n    SocialWidgetTracker.prototype.addWidgetListeners = function () {\n      if (window.FB) this.addFacebookEventHandlers();\n      if (window.twttr) this.addTwitterEventHandlers();\n    };\n    /**\n     * Adds event handlers for the \"tweet\" and \"follow\" events emitted by the\n     * official tweet and follow buttons. Note: this does not capture tweet or\n     * follow events emitted by other Twitter widgets (tweet, timeline, etc.).\n     */\n\n\n    SocialWidgetTracker.prototype.addTwitterEventHandlers = function () {\n      try {\n        twttr.ready(function () {\n          twttr.events.bind('tweet', this.handleTweetEvents);\n          twttr.events.bind('follow', this.handleFollowEvents);\n        }.bind(this));\n      } catch (err) {}\n    };\n    /**\n     * Removes event handlers for the \"tweet\" and \"follow\" events emitted by the\n     * official tweet and follow buttons.\n     */\n\n\n    SocialWidgetTracker.prototype.removeTwitterEventHandlers = function () {\n      try {\n        twttr.ready(function () {\n          twttr.events.unbind('tweet', this.handleTweetEvents);\n          twttr.events.unbind('follow', this.handleFollowEvents);\n        }.bind(this));\n      } catch (err) {}\n    };\n    /**\n     * Adds event handlers for the \"like\" and \"unlike\" events emitted by the\n     * official Facebook like button.\n     */\n\n\n    SocialWidgetTracker.prototype.addFacebookEventHandlers = function () {\n      try {\n        FB.Event.subscribe('edge.create', this.handleLikeEvents);\n        FB.Event.subscribe('edge.remove', this.handleUnlikeEvents);\n      } catch (err) {}\n    };\n    /**\n     * Removes event handlers for the \"like\" and \"unlike\" events emitted by the\n     * official Facebook like button.\n     */\n\n\n    SocialWidgetTracker.prototype.removeFacebookEventHandlers = function () {\n      try {\n        FB.Event.unsubscribe('edge.create', this.handleLikeEvents);\n        FB.Event.unsubscribe('edge.remove', this.handleUnlikeEvents);\n      } catch (err) {}\n    };\n    /**\n     * Handles `tweet` events emitted by the Twitter JS SDK.\n     * @param {Object} event The Twitter event object passed to the handler.\n     */\n\n\n    SocialWidgetTracker.prototype.handleTweetEvents = function (event) {\n      // Ignores tweets from widgets that aren't the tweet button.\n      if (event.region != 'tweet') return;\n      var url = event.data.url || event.target.getAttribute('data-url') || location.href;\n      var defaultFields = {\n        transport: 'beacon',\n        socialNetwork: 'Twitter',\n        socialAction: 'tweet',\n        socialTarget: url\n      };\n      this.tracker.send('social', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n    };\n    /**\n     * Handles `follow` events emitted by the Twitter JS SDK.\n     * @param {Object} event The Twitter event object passed to the handler.\n     */\n\n\n    SocialWidgetTracker.prototype.handleFollowEvents = function (event) {\n      // Ignore follows from widgets that aren't the follow button.\n      if (event.region != 'follow') return;\n      var screenName = event.data.screen_name || event.target.getAttribute('data-screen-name');\n      var defaultFields = {\n        transport: 'beacon',\n        socialNetwork: 'Twitter',\n        socialAction: 'follow',\n        socialTarget: screenName\n      };\n      this.tracker.send('social', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n    };\n    /**\n     * Handles `like` events emitted by the Facebook JS SDK.\n     * @param {string} url The URL corresponding to the like event.\n     */\n\n\n    SocialWidgetTracker.prototype.handleLikeEvents = function (url) {\n      var defaultFields = {\n        transport: 'beacon',\n        socialNetwork: 'Facebook',\n        socialAction: 'like',\n        socialTarget: url\n      };\n      this.tracker.send('social', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n    };\n    /**\n     * Handles `unlike` events emitted by the Facebook JS SDK.\n     * @param {string} url The URL corresponding to the unlike event.\n     */\n\n\n    SocialWidgetTracker.prototype.handleUnlikeEvents = function (url) {\n      var defaultFields = {\n        transport: 'beacon',\n        socialNetwork: 'Facebook',\n        socialAction: 'unlike',\n        socialTarget: url\n      };\n      this.tracker.send('social', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    SocialWidgetTracker.prototype.remove = function () {\n      window.removeEventListener('load', this.addWidgetListeners);\n      this.removeFacebookEventHandlers();\n      this.removeTwitterEventHandlers();\n    };\n\n    provide('socialWidgetTracker', SocialWidgetTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"object-assign\": 23\n  }],\n  11: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var provide = require('../provide');\n\n    var usage = require('../usage');\n\n    var createFieldsObj = require('../utilities').createFieldsObj;\n\n    var isObject = require('../utilities').isObject;\n    /**\n     * Adds handler for the history API methods\n     * @constructor\n     * @param {Object} tracker Passed internally by analytics.js\n     * @param {?Object} opts Passed by the require command.\n     */\n\n\n    function UrlChangeTracker(tracker, opts) {\n      usage.track(tracker, usage.plugins.URL_CHANGE_TRACKER); // Feature detects to prevent errors in unsupporting browsers.\n\n      if (!history.pushState || !window.addEventListener) return;\n      this.opts = assign({\n        shouldTrackUrlChange: this.shouldTrackUrlChange,\n        fieldsObj: {},\n        hitFilter: null\n      }, opts);\n      this.tracker = tracker; // Sets the initial page field.\n      // Don't set this on the tracker yet so campaign data can be retreived\n      // from the location field.\n\n      this.path = getPath();\n      this.updateTrackerData = this.updateTrackerData.bind(this); // Overrides history.pushState.\n\n      this.originalPushState = history.pushState;\n\n      history.pushState = function (state, title) {\n        // Sets the document title for reference later.\n        // TODO(philipwalton): consider using WeakMap for this to not conflict\n        // with any user-defined property also called \"title\".\n        if (isObject(state) && title) state.title = title;\n        this.originalPushState.apply(history, arguments);\n        this.updateTrackerData();\n      }.bind(this); // Overrides history.repaceState.\n\n\n      this.originalReplaceState = history.replaceState;\n\n      history.replaceState = function (state, title) {\n        // Sets the document title for reference later.\n        // TODO(philipwalton): consider using WeakMap for this to not conflict\n        // with any user-defined property also called \"title\".\n        if (isObject(state) && title) state.title = title;\n        this.originalReplaceState.apply(history, arguments);\n        this.updateTrackerData(false);\n      }.bind(this); // Handles URL changes via user interaction.\n\n\n      window.addEventListener('popstate', this.updateTrackerData);\n    }\n    /**\n     * Updates the page and title fields on the tracker if necessary and\n     * optionally sends a pageview.\n     * @param {boolean} shouldSendPageview Indicates whether the tracker should\n     *     send a pageview after updating the URL.\n     */\n\n\n    UrlChangeTracker.prototype.updateTrackerData = function (shouldSendPageview) {\n      // Sets the default.\n      shouldSendPageview = shouldSendPageview === false ? false : true; // Calls the update logic asychronously to help ensure user callbacks\n      // happen first.\n\n      setTimeout(function () {\n        var oldPath = this.path;\n        var newPath = getPath();\n\n        if (oldPath != newPath && this.opts.shouldTrackUrlChange.call(this, newPath, oldPath)) {\n          this.path = newPath;\n          this.tracker.set({\n            page: newPath,\n            title: isObject(history.state) && history.state.title || document.title\n          });\n\n          if (shouldSendPageview) {\n            var defaultFields = {\n              transport: 'beacon'\n            };\n            this.tracker.send('pageview', createFieldsObj(defaultFields, this.opts.fieldsObj, this.tracker, this.opts.hitFilter));\n          }\n        }\n      }.bind(this), 0);\n    };\n    /**\n     * Determines whether or not the tracker should send a hit with the new page\n     * data. This default implementation can be overrided in the config options.\n     * @param {string} newPath The path prior to the URL change.\n     * @param {string} oldPath The path after the URL change.\n     * @return {boolean} Whether or not the URL change should be tracked.\n     */\n\n\n    UrlChangeTracker.prototype.shouldTrackUrlChange = function (newPath, oldPath) {\n      return newPath && oldPath;\n    };\n    /**\n     * Removes all event listeners and instance properties.\n     */\n\n\n    UrlChangeTracker.prototype.remove = function () {\n      window.removeEventListener('popstate', this.updateTrackerData);\n      history.replaceState = this.originalReplaceState;\n      history.pushState = this.originalPushState;\n      this.tracker = null;\n      this.opts = null;\n      this.path = null;\n      this.updateTrackerData = null;\n      this.originalReplaceState = null;\n      this.originalPushState = null;\n    };\n    /**\n     * @return {string} The path value of the current URL.\n     */\n\n\n    function getPath() {\n      return location.pathname + location.search;\n    }\n\n    provide('urlChangeTracker', UrlChangeTracker);\n  }, {\n    \"../provide\": 12,\n    \"../usage\": 13,\n    \"../utilities\": 14,\n    \"object-assign\": 23\n  }],\n  12: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var constants = require('./constants');\n\n    var utilities = require('./utilities'); // Adds the dev ID to the list of dev IDs if any plugin is used.\n\n\n    (window.gaDevIds = window.gaDevIds || []).push(constants.DEV_ID);\n    /**\n     * Provides a plugin for use with analytics.js, accounting for the possibility\n     * that the global command queue has been renamed or not yet defined.\n     * @param {string} pluginName The plugin name identifier.\n     * @param {Function} pluginConstructor The plugin constructor function.\n     */\n\n    module.exports = function providePlugin(pluginName, pluginConstructor) {\n      var gaAlias = window['GoogleAnalyticsObject'] || 'ga';\n\n      window[gaAlias] = window[gaAlias] || function () {\n        (window[gaAlias]['q'] = window[gaAlias]['q'] || []).push(arguments);\n      }; // Formally provides the plugin for use with analytics.js.\n\n\n      window[gaAlias]('provide', pluginName, pluginConstructor); // Registers the plugin on the global gaplugins object.\n\n      window.gaplugins = window.gaplugins || {};\n      window.gaplugins[utilities.capitalize(pluginName)] = pluginConstructor;\n    };\n  }, {\n    \"./constants\": 1,\n    \"./utilities\": 14\n  }],\n  13: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var constants = require('./constants');\n\n    var plugins = {\n      CLEAN_URL_TRACKER: 1,\n      EVENT_TRACKER: 2,\n      IMPRESSION_TRACKER: 3,\n      MEDIA_QUERY_TRACKER: 4,\n      OUTBOUND_FORM_TRACKER: 5,\n      OUTBOUND_LINK_TRACKER: 6,\n      PAGE_VISIBILITY_TRACKER: 7,\n      SOCIAL_WIDGET_TRACKER: 8,\n      URL_CHANGE_TRACKER: 9\n    };\n    var PLUGIN_COUNT = 9;\n    /**\n     * Converts a hexadecimal string to a binary string.\n     * @param {string} hex A hexadecimal numeric string.\n     * @return {string} a binary numeric string.\n     */\n\n    function convertHexToBin(hex) {\n      return parseInt(hex || '0', 16).toString(2);\n    }\n    /**\n     * Converts a binary string to a hexadecimal string.\n     * @param {string} bin A binary numeric string.\n     * @return {string} a hexadecimal numeric string.\n     */\n\n\n    function convertBinToHex(bin) {\n      return parseInt(bin || '0', 2).toString(16);\n    }\n    /**\n     * Adds leading zeros to a string if it's less than a minimum length.\n     * @param {string} str A string to pad.\n     * @param {number} len The minimum length of the string\n     * @return {string} The padded string.\n     */\n\n\n    function padZeros(str, len) {\n      if (str.length < len) {\n        var toAdd = len - str.length;\n\n        while (toAdd) {\n          str = '0' + str;\n          toAdd--;\n        }\n      }\n\n      return str;\n    }\n    /**\n     * Accepts a binary numeric string and flips the digit from 0 to 1 at the\n     * specified index.\n     * @param {string} str The binary numeric string.\n     * @param {number} index The index to flip the bit.\n     * @return {string} The new binary string with the bit flipped on\n     */\n\n\n    function flipBitOn(str, index) {\n      return str.substr(0, index) + 1 + str.substr(index + 1);\n    }\n    /**\n     * Accepts a tracker and a plugin index and flips the bit at the specified\n     * index on the tracker's usage parameter.\n     * @param {Object} tracker An analytics.js tracker.\n     * @param {number} pluginIndex The index of the plugin in the global list.\n     */\n\n\n    function trackPlugin(tracker, pluginIndex) {\n      var usageHex = tracker.get(constants.USAGE_PARAM);\n      var usageBin = padZeros(convertHexToBin(usageHex), PLUGIN_COUNT); // Flip the bit of the plugin being tracked.\n\n      usageBin = flipBitOn(usageBin, PLUGIN_COUNT - pluginIndex); // Stores the modified usage string back on the tracker.\n\n      tracker.set(constants.USAGE_PARAM, convertBinToHex(usageBin));\n    }\n    /**\n     * Accepts a tracker and adds the current version to the version param.\n     * @param {Object} tracker An analytics.js tracker.\n     */\n\n\n    function trackVersion(tracker) {\n      tracker.set(constants.VERSION_PARAM, constants.VERSION);\n    }\n\n    module.exports = {\n      track: function track(tracker, plugin) {\n        trackVersion(tracker);\n        trackPlugin(tracker, plugin);\n      },\n      plugins: plugins\n    };\n  }, {\n    \"./constants\": 1\n  }],\n  14: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var assign = require('object-assign');\n\n    var getAttributes = require('dom-utils/lib/get-attributes');\n\n    var utilities = {\n      /**\n       * Accepts default and user override fields and an optional tracker, hit\n       * filter, and target element and returns a single object that can be used in\n       * `ga('send', ...)` commands.\n       * @param {Object} defaultFields The default fields to return.\n       * @param {Object} userFields Fields set by the user to override the defaults.\n       * @param {Object} opt_tracker The tracker object to apply the hit filter to.\n       * @param {Function} opt_hitFilter A filter function that gets\n       *     called with the tracker model right before the `buildHitTask`. It can\n       *     be used to modify the model for the current hit only.\n       * @param {Element} opt_target If the hit originated from an interaction\n       *     with a DOM element, hitFilter is invoked with that element as the\n       *     second argument.\n       * @return {Object} The final fields object.\n       */\n      createFieldsObj: function createFieldsObj(defaultFields, userFields, opt_tracker, opt_hitFilter, opt_target) {\n        if (typeof opt_hitFilter == 'function') {\n          var originalBuildHitTask = opt_tracker.get('buildHitTask');\n          return {\n            buildHitTask: function buildHitTask(model) {\n              model.set(defaultFields, null, true);\n              model.set(userFields, null, true);\n              opt_hitFilter(model, opt_target);\n              originalBuildHitTask(model);\n            }\n          };\n        } else {\n          return assign({}, defaultFields, userFields);\n        }\n      },\n\n      /**\n       * Retrieves the attributes from an DOM element and returns a fields object\n       * for all attributes matching the passed prefix string.\n       * @param {Element} element The DOM element to get attributes from.\n       * @param {string} prefix An attribute prefix. Only the attributes matching\n       *     the prefix will be returned on the fields object.\n       * @return {Object} An object of analytics.js fields and values\n       */\n      getAttributeFields: function getAttributeFields(element, prefix) {\n        var attributes = getAttributes(element);\n        var attributeFields = {};\n        Object.keys(attributes).forEach(function (attribute) {\n          // The `on` prefix is used for event handling but isn't a field.\n          if (attribute.indexOf(prefix) === 0 && attribute != prefix + 'on') {\n            var value = attributes[attribute]; // Detects Boolean value strings.\n\n            if (value == 'true') value = true;\n            if (value == 'false') value = false;\n            var field = utilities.camelCase(attribute.slice(prefix.length));\n            attributeFields[field] = value;\n          }\n        });\n        return attributeFields;\n      },\n      domReady: function domReady(callback) {\n        if (document.readyState == 'loading') {\n          document.addEventListener('DOMContentLoaded', function fn() {\n            document.removeEventListener('DOMContentLoaded', fn);\n            callback();\n          });\n        } else {\n          callback();\n        }\n      },\n\n      /**\n       * Accepts a function and returns a wrapped version of the function that is\n       * expected to be called elsewhere in the system. If it's not called\n       * elsewhere after the timeout period, it's called regardless. The wrapper\n       * function also prevents the callback from being called more than once.\n       * @param {Function} callback The function to call.\n       * @param {number} wait How many milliseconds to wait before invoking\n       *     the callback.\n       * @returns {Function} The wrapped version of the passed function.\n       */\n      withTimeout: function withTimeout(callback, wait) {\n        var called = false;\n        setTimeout(callback, wait || 2000);\n        return function () {\n          if (!called) {\n            called = true;\n            callback();\n          }\n        };\n      },\n\n      /**\n       * Accepts a string containing hyphen or underscore word separators and\n       * converts it to camelCase.\n       * @param {string} str The string to camelCase.\n       * @return {string} The camelCased version of the string.\n       */\n      camelCase: function camelCase(str) {\n        return str.replace(/[\\-\\_]+(\\w?)/g, function (match, p1) {\n          return p1.toUpperCase();\n        });\n      },\n\n      /**\n       * Capitalizes the first letter of a string.\n       * @param {string} str The input string.\n       * @return {string} The capitalized string\n       */\n      capitalize: function capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n      },\n\n      /**\n       * Indicates whether the passed variable is a JavaScript object.\n       * @param {*} value The input variable to test.\n       * @return {boolean} Whether or not the test is an object.\n       */\n      isObject: function isObject(value) {\n        return _typeof(value) == 'object' && value !== null;\n      },\n\n      /**\n       * Indicates whether the passed variable is a JavaScript array.\n       * @param {*} value The input variable to test.\n       * @return {boolean} Whether or not the value is an array.\n       */\n      isArray: Array.isArray || function (value) {\n        return Object.prototype.toString.call(value) === '[object Array]';\n      },\n\n      /**\n       * Accepts a value that may or may not be an array. If it is not an array,\n       * it is returned as the first item in a single-item array.\n       * @param {*} value The value to convert to an array if it is not.\n       * @return {Array} The array-ified value.\n       */\n      toArray: function toArray(value) {\n        return utilities.isArray(value) ? value : [value];\n      }\n    };\n    module.exports = utilities;\n  }, {\n    \"dom-utils/lib/get-attributes\": 19,\n    \"object-assign\": 23\n  }],\n  15: [function (require, module, exports) {\n    module.exports = Date.now || now;\n\n    function now() {\n      return new Date().getTime();\n    }\n  }, {}],\n  16: [function (require, module, exports) {\n    /**\n     * Module dependencies.\n     */\n    var now = require('date-now');\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     *\n     * @source underscore.js\n     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n     * @param {Function} function to wrap\n     * @param {Number} timeout in ms (`100`)\n     * @param {Boolean} whether to execute at the beginning (`false`)\n     * @api public\n     */\n\n\n    module.exports = function debounce(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      if (null == wait) wait = 100;\n\n      function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n\n          if (!immediate) {\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n          }\n        }\n      }\n\n      ;\n      return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n\n        if (callNow) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n\n        return result;\n      };\n    };\n  }, {\n    \"date-now\": 15\n  }],\n  17: [function (require, module, exports) {\n    var matches = require('./matches');\n\n    var parents = require('./parents');\n    /**\n     * Gets the closest parent element that matches the passed selector.\n     * @param {Element} element The element whose parents to check.\n     * @param {string} selector The CSS selector to match against.\n     * @param {boolean} shouldCheckSelf True if the selector should test against\n     *     the passed element itself.\n     * @return {?Element} The matching element or undefined.\n     */\n\n\n    module.exports = function closest(element, selector, shouldCheckSelf) {\n      if (!(element && element.nodeType == 1 && selector)) return;\n      var parentElements = (shouldCheckSelf ? [element] : []).concat(parents(element));\n\n      for (var i = 0, parent; parent = parentElements[i]; i++) {\n        if (matches(parent, selector)) return parent;\n      }\n    };\n  }, {\n    \"./matches\": 20,\n    \"./parents\": 21\n  }],\n  18: [function (require, module, exports) {\n    var closest = require('./closest');\n\n    var matches = require('./matches');\n    /**\n     * Delegates the handling of events for an element matching a selector to an\n     * ancestor of the matching element.\n     * @param {Element} ancestor The ancestor element to add the listener to.\n     * @param {string} eventType The event type to listen to.\n     * @param {string} selector A CSS selector to match against child elements.\n     * @param {Function} callback A function to run any time the event happens.\n     * @param {Object} opts A configuration options object. The available options:\n     *     - useCapture<boolean>: If true, bind to the event capture phase.\n     *     - deep<boolean>: If true, delegate into shadow trees.\n     * @return {Object} The delegate object. It contains a destroy method.\n     */\n\n\n    module.exports = function delegate(ancestor, eventType, selector, callback, opts) {\n      opts = opts || {}; // Defines the event listener.\n\n      var listener = function listener(event) {\n        // If opts.composed is true and the event originated from inside a Shadow\n        // tree, check the composed path nodes.\n        if (opts.composed && typeof event.composedPath == 'function') {\n          var composedPath = event.composedPath();\n\n          for (var i = 0, node; node = composedPath[i]; i++) {\n            if (node.nodeType == 1 && matches(node, selector)) {\n              delegateTarget = node;\n            }\n          }\n        } // Otherwise check the parents.\n        else {\n            var delegateTarget = closest(event.target, selector, true);\n          }\n\n        if (delegateTarget) {\n          callback.call(delegateTarget, event, delegateTarget);\n        }\n      };\n\n      ancestor.addEventListener(eventType, listener, opts.useCapture);\n      return {\n        destroy: function destroy() {\n          ancestor.removeEventListener(eventType, listener, opts.useCapture);\n        }\n      };\n    };\n  }, {\n    \"./closest\": 17,\n    \"./matches\": 20\n  }],\n  19: [function (require, module, exports) {\n    /**\n     * Gets all attributes of an element as a plain JavaScriot object.\n     * @param {Element} element The element whose attributes to get.\n     * @return {Object} An object whose keys are the attribute keys and whose\n     *     values are the attribute values. If no attributes exist, an empty\n     *     object is returned.\n     */\n    module.exports = function getAttributes(element) {\n      var attrs = {}; // Validate input.\n\n      if (!(element && element.nodeType == 1)) return attrs; // Return an empty object if there are no attributes.\n\n      var map = element.attributes;\n      if (map.length === 0) return {};\n\n      for (var i = 0, attr; attr = map[i]; i++) {\n        attrs[attr.name] = attr.value;\n      }\n\n      return attrs;\n    };\n  }, {}],\n  20: [function (require, module, exports) {\n    var proto = window.Element.prototype;\n    var nativeMatches = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;\n    /**\n     * Tests whether a DOM element matches a selector. This polyfills the native\n     * Element.prototype.matches method across browsers.\n     * @param {Element} element The DOM element to test.\n     * @param {string} selector The CSS selector to test element against.\n     * @return {boolean} True if the selector matches.\n     */\n\n    function matchesSelector(element, selector) {\n      if (typeof selector != 'string') return false;\n      if (nativeMatches) return nativeMatches.call(element, selector);\n      var nodes = element.parentNode.querySelectorAll(selector);\n\n      for (var i = 0, node; node = nodes[i]; i++) {\n        if (node == element) return true;\n      }\n\n      return false;\n    }\n    /**\n     * Tests if a DOM elements matches any of the test DOM elements or selectors.\n     * @param {Element} element The DOM element to test.\n     * @param {Element|string|Array<Element|String>} test A DOM element, a CSS\n     *     selector, or an array of DOM elements or CSS selectors to match against.\n     * @return {boolean} True of any part of the test matches.\n     */\n\n\n    module.exports = function matches(element, test) {\n      // Validate input.\n      if (element && element.nodeType == 1 && test) {\n        // if test is a string or DOM element test it.\n        if (typeof test == 'string' || test.nodeType == 1) {\n          return element == test || matchesSelector(element, test);\n        } // if it has a length property iterate over the items\n        // and return true if any match.\n        else if ('length' in test) {\n            for (var i = 0, item; item = test[i]; i++) {\n              if (element == item || matchesSelector(element, item)) return true;\n            }\n          }\n      } // Still here? Return false\n\n\n      return false;\n    };\n  }, {}],\n  21: [function (require, module, exports) {\n    /**\n     * Returns an array of a DOM element's parent elements.\n     * @param {Element} element The DOM element whose parents to get.\n     * @return {Array} An array of all parent elemets, or an empty array if no\n     *     parent elements are found.\n     */\n    module.exports = function parents(element) {\n      var list = [];\n\n      while (element && element.parentNode && element.parentNode.nodeType == 1) {\n        list.push(element = element.parentNode);\n      }\n\n      return list;\n    };\n  }, {}],\n  22: [function (require, module, exports) {\n    var HTTP_PORT = '80';\n    var HTTPS_PORT = '443';\n    var DEFAULT_PORT = RegExp(':(' + HTTP_PORT + '|' + HTTPS_PORT + ')$');\n    var a = document.createElement('a');\n    var cache = {};\n    /**\n     * Parses the given url and returns an object mimicing a `Location` object.\n     * @param {string} url The url to parse.\n     * @return {Object} An object with the same properties as a `Location`\n     *    plus the convience properties `path` and `query`.\n     */\n\n    module.exports = function parseUrl(url) {\n      // All falsy values (as well as \".\") should map to the current URL.\n      url = !url || url == '.' ? location.href : url;\n      if (cache[url]) return cache[url];\n      a.href = url; // When parsing file relative paths (e.g. `../index.html`), IE will correctly\n      // resolve the `href` property but will keep the `..` in the `path` property.\n      // To workaround this, we reparse with the full URL from the `href` property.\n\n      if (url.charAt(0) == '.') return parseUrl(a.href); // Sometimes IE will return no port or just a colon, especially for things\n      // like relative port URLs (e.g. \"//google.com\").\n\n      var protocol = !a.protocol || ':' == a.protocol ? location.protocol : a.protocol; // Don't include default ports.\n\n      var port = a.port == HTTP_PORT || a.port == HTTPS_PORT ? '' : a.port; // PhantomJS sets the port to \"0\" when using the file: protocol.\n\n      port = port == '0' ? '' : port; // IE will return an empty string for host and hostname with a relative URL.\n\n      var host = a.host == '' ? location.host : a.host;\n      var hostname = a.hostname == '' ? location.hostname : a.hostname; // Sometimes IE incorrectly includes a port for default ports\n      // (e.g. `:80` or `:443`) even when no port is specified in the URL.\n      // http://bit.ly/1rQNoMg\n\n      host = host.replace(DEFAULT_PORT, ''); // Not all browser support `origin` so we have to build it.\n\n      var origin = a.origin ? a.origin : protocol + '//' + host; // Sometimes IE doesn't include the leading slash for pathname.\n      // http://bit.ly/1rQNoMg\n\n      var pathname = a.pathname.charAt(0) == '/' ? a.pathname : '/' + a.pathname;\n      return cache[url] = {\n        hash: a.hash,\n        host: host,\n        hostname: hostname,\n        href: a.href,\n        origin: origin,\n        pathname: pathname,\n        port: port,\n        protocol: protocol,\n        search: a.search,\n        // Expose additional helpful properties not part of the Location object.\n        fragment: a.hash.slice(1),\n        // The hash without the starting \"#\".\n        path: pathname + a.search,\n        // The pathname and the search query (w/o hash).\n        query: a.search.slice(1) // The search without the starting \"?\".\n\n      };\n    };\n  }, {}],\n  23: [function (require, module, exports) {\n    'use strict';\n    /* eslint-disable no-unused-vars */\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n    function toObject(val) {\n      if (val === null || val === undefined) {\n        throw new TypeError('Object.assign cannot be called with null or undefined');\n      }\n\n      return Object(val);\n    }\n\n    function shouldUseNative() {\n      try {\n        if (!Object.assign) {\n          return false;\n        } // Detect buggy property enumeration order in older V8 versions.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n        var test1 = new String('abc'); // eslint-disable-line\n\n        test1[5] = 'de';\n\n        if (Object.getOwnPropertyNames(test1)[0] === '5') {\n          return false;\n        } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n        var test2 = {};\n\n        for (var i = 0; i < 10; i++) {\n          test2['_' + String.fromCharCode(i)] = i;\n        }\n\n        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n          return test2[n];\n        });\n\n        if (order2.join('') !== '0123456789') {\n          return false;\n        } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n        var test3 = {};\n        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n          test3[letter] = letter;\n        });\n\n        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n          return false;\n        }\n\n        return true;\n      } catch (e) {\n        // We don't expect any of the above to throw, but better to be safe.\n        return false;\n      }\n    }\n\n    module.exports = shouldUseNative() ? Object.assign : function (target, source) {\n      var from;\n      var to = toObject(target);\n      var symbols;\n\n      for (var s = 1; s < arguments.length; s++) {\n        from = Object(arguments[s]);\n\n        for (var key in from) {\n          if (hasOwnProperty.call(from, key)) {\n            to[key] = from[key];\n          }\n        }\n\n        if (Object.getOwnPropertySymbols) {\n          symbols = Object.getOwnPropertySymbols(from);\n\n          for (var i = 0; i < symbols.length; i++) {\n            if (propIsEnumerable.call(from, symbols[i])) {\n              to[symbols[i]] = from[symbols[i]];\n            }\n          }\n        }\n      }\n\n      return to;\n    };\n  }, {}],\n  24: [function (require, module, exports) {\n    /**\n     * Copyright 2016 Google Inc. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // Imports all sub-plugins.\n    require('./plugins/clean-url-tracker');\n\n    require('./plugins/event-tracker');\n\n    require('./plugins/impression-tracker');\n\n    require('./plugins/media-query-tracker');\n\n    require('./plugins/outbound-form-tracker');\n\n    require('./plugins/outbound-link-tracker');\n\n    require('./plugins/page-visibility-tracker');\n\n    require('./plugins/social-widget-tracker');\n\n    require('./plugins/url-change-tracker'); // Imports the deprecated autotrack plugin for backwards compatibility.\n\n\n    require('./plugins/autotrack');\n  }, {\n    \"./plugins/autotrack\": 2,\n    \"./plugins/clean-url-tracker\": 3,\n    \"./plugins/event-tracker\": 4,\n    \"./plugins/impression-tracker\": 5,\n    \"./plugins/media-query-tracker\": 6,\n    \"./plugins/outbound-form-tracker\": 7,\n    \"./plugins/outbound-link-tracker\": 8,\n    \"./plugins/page-visibility-tracker\": 9,\n    \"./plugins/social-widget-tracker\": 10,\n    \"./plugins/url-change-tracker\": 11\n  }]\n}, {}, [24]);"},2315:function(n,e,t){t(1226)(t(2316))},2316:function(n,e){n.exports='/*\n *\n * More info at [www.dropzonejs.com](http://www.dropzonejs.com)\n *\n * Copyright (c) 2012, Matias Meno\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\n(function () {\n  var Dropzone,\n      Emitter,\n      ExifRestore,\n      camelize,\n      contentLoaded,\n      detectVerticalSquash,\n      drawImageIOSFix,\n      noop,\n      without,\n      slice = [].slice,\n      extend1 = function extend1(child, parent) {\n    for (var key in parent) {\n      if (hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  },\n      hasProp = {}.hasOwnProperty;\n\n  noop = function noop() {};\n\n  Emitter = function () {\n    function Emitter() {}\n\n    Emitter.prototype.addEventListener = Emitter.prototype.on;\n\n    Emitter.prototype.on = function (event, fn) {\n      this._callbacks = this._callbacks || {};\n\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n\n      this._callbacks[event].push(fn);\n\n      return this;\n    };\n\n    Emitter.prototype.emit = function () {\n      var args, callback, callbacks, event, j, len;\n      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      this._callbacks = this._callbacks || {};\n      callbacks = this._callbacks[event];\n\n      if (callbacks) {\n        for (j = 0, len = callbacks.length; j < len; j++) {\n          callback = callbacks[j];\n          callback.apply(this, args);\n        }\n      }\n\n      return this;\n    };\n\n    Emitter.prototype.removeListener = Emitter.prototype.off;\n    Emitter.prototype.removeAllListeners = Emitter.prototype.off;\n    Emitter.prototype.removeEventListener = Emitter.prototype.off;\n\n    Emitter.prototype.off = function (event, fn) {\n      var callback, callbacks, i, j, len;\n\n      if (!this._callbacks || arguments.length === 0) {\n        this._callbacks = {};\n        return this;\n      }\n\n      callbacks = this._callbacks[event];\n\n      if (!callbacks) {\n        return this;\n      }\n\n      if (arguments.length === 1) {\n        delete this._callbacks[event];\n        return this;\n      }\n\n      for (i = j = 0, len = callbacks.length; j < len; i = ++j) {\n        callback = callbacks[i];\n\n        if (callback === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n\n      return this;\n    };\n\n    return Emitter;\n  }();\n\n  Dropzone = function (superClass) {\n    var extend, resolveOption;\n    extend1(Dropzone, superClass);\n    Dropzone.prototype.Emitter = Emitter;\n    /*\n    This is a list of all available events you can register on a dropzone object.\n    \n    You can register an event handler like this:\n    \n        dropzone.on("dragEnter", function() { });\n     */\n\n    Dropzone.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];\n    Dropzone.prototype.defaultOptions = {\n      url: null,\n      method: "post",\n      withCredentials: false,\n      timeout: 30000,\n      parallelUploads: 2,\n      uploadMultiple: false,\n      maxFilesize: 256,\n      paramName: "file",\n      createImageThumbnails: true,\n      maxThumbnailFilesize: 10,\n      thumbnailWidth: 120,\n      thumbnailHeight: 120,\n      thumbnailMethod: \'crop\',\n      resizeWidth: null,\n      resizeHeight: null,\n      resizeMimeType: null,\n      resizeQuality: 0.8,\n      resizeMethod: \'contain\',\n      filesizeBase: 1000,\n      maxFiles: null,\n      params: {},\n      headers: null,\n      clickable: true,\n      ignoreHiddenFiles: true,\n      acceptedFiles: null,\n      acceptedMimeTypes: null,\n      autoProcessQueue: true,\n      autoQueue: true,\n      addRemoveLinks: false,\n      previewsContainer: null,\n      hiddenInputContainer: "body",\n      capture: null,\n      renameFilename: null,\n      renameFile: null,\n      forceFallback: false,\n      dictDefaultMessage: "Drop files here to upload",\n      dictFallbackMessage: "Your browser does not support drag\'n\'drop file uploads.",\n      dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",\n      dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",\n      dictInvalidFileType: "You can\'t upload files of this type.",\n      dictResponseError: "Server responded with {{statusCode}} code.",\n      dictCancelUpload: "Cancel upload",\n      dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",\n      dictRemoveFile: "Remove file",\n      dictRemoveFileConfirmation: null,\n      dictMaxFilesExceeded: "You can not upload any more files.",\n      dictFileSizeUnits: {\n        tb: "TB",\n        gb: "GB",\n        mb: "MB",\n        kb: "KB",\n        b: "b"\n      },\n      init: function init() {\n        return noop;\n      },\n      accept: function accept(file, done) {\n        return done();\n      },\n      fallback: function fallback() {\n        var child, j, len, messageElement, ref, span;\n        this.element.className = this.element.className + " dz-browser-not-supported";\n        ref = this.element.getElementsByTagName("div");\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          child = ref[j];\n\n          if (/(^| )dz-message($| )/.test(child.className)) {\n            messageElement = child;\n            child.className = "dz-message";\n            continue;\n          }\n        }\n\n        if (!messageElement) {\n          messageElement = Dropzone.createElement("<div class=\\"dz-message\\"><span></span></div>");\n          this.element.appendChild(messageElement);\n        }\n\n        span = messageElement.getElementsByTagName("span")[0];\n\n        if (span) {\n          if (span.textContent != null) {\n            span.textContent = this.options.dictFallbackMessage;\n          } else if (span.innerText != null) {\n            span.innerText = this.options.dictFallbackMessage;\n          }\n        }\n\n        return this.element.appendChild(this.getFallbackForm());\n      },\n      resize: function resize(file, width, height, resizeMethod) {\n        var info, srcRatio, trgRatio;\n        info = {\n          srcX: 0,\n          srcY: 0,\n          srcWidth: file.width,\n          srcHeight: file.height\n        };\n        srcRatio = file.width / file.height;\n\n        if (width == null && height == null) {\n          width = info.srcWidth;\n          height = info.srcHeight;\n        } else if (width == null) {\n          width = height * srcRatio;\n        } else if (height == null) {\n          height = width / srcRatio;\n        }\n\n        width = Math.min(width, info.srcWidth);\n        height = Math.min(height, info.srcHeight);\n        trgRatio = width / height;\n\n        if (info.srcWidth > width || info.srcHeight > height) {\n          if (resizeMethod === \'crop\') {\n            if (srcRatio > trgRatio) {\n              info.srcHeight = file.height;\n              info.srcWidth = info.srcHeight * trgRatio;\n            } else {\n              info.srcWidth = file.width;\n              info.srcHeight = info.srcWidth / trgRatio;\n            }\n          } else if (resizeMethod === \'contain\') {\n            if (srcRatio > trgRatio) {\n              height = width / srcRatio;\n            } else {\n              width = height * srcRatio;\n            }\n          } else {\n            throw new Error("Unknown resizeMethod \'" + resizeMethod + "\'");\n          }\n        }\n\n        info.srcX = (file.width - info.srcWidth) / 2;\n        info.srcY = (file.height - info.srcHeight) / 2;\n        info.trgWidth = width;\n        info.trgHeight = height;\n        return info;\n      },\n      transformFile: function transformFile(file, done) {\n        if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {\n          return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);\n        } else {\n          return done(file);\n        }\n      },\n      previewTemplate: "<div class=\\"dz-preview dz-file-preview\\">\\n  <div class=\\"dz-image\\"><img data-dz-thumbnail /></div>\\n  <div class=\\"dz-details\\">\\n    <div class=\\"dz-size\\"><span data-dz-size></span></div>\\n    <div class=\\"dz-filename\\"><span data-dz-name></span></div>\\n  </div>\\n  <div class=\\"dz-progress\\"><span class=\\"dz-upload\\" data-dz-uploadprogress></span></div>\\n  <div class=\\"dz-error-message\\"><span data-dz-errormessage></span></div>\\n  <div class=\\"dz-success-mark\\">\\n    <svg width=\\"54px\\" height=\\"54px\\" viewBox=\\"0 0 54 54\\" version=\\"1.1\\" xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" xmlns:sketch=\\"http://www.bohemiancoding.com/sketch/ns\\">\\n      <title>Check</title>\\n      <defs></defs>\\n      <g id=\\"Page-1\\" stroke=\\"none\\" stroke-width=\\"1\\" fill=\\"none\\" fill-rule=\\"evenodd\\" sketch:type=\\"MSPage\\">\\n        <path d=\\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\" id=\\"Oval-2\\" stroke-opacity=\\"0.198794158\\" stroke=\\"#747474\\" fill-opacity=\\"0.816519475\\" fill=\\"#FFFFFF\\" sketch:type=\\"MSShapeGroup\\"></path>\\n      </g>\\n    </svg>\\n  </div>\\n  <div class=\\"dz-error-mark\\">\\n    <svg width=\\"54px\\" height=\\"54px\\" viewBox=\\"0 0 54 54\\" version=\\"1.1\\" xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" xmlns:sketch=\\"http://www.bohemiancoding.com/sketch/ns\\">\\n      <title>Error</title>\\n      <defs></defs>\\n      <g id=\\"Page-1\\" stroke=\\"none\\" stroke-width=\\"1\\" fill=\\"none\\" fill-rule=\\"evenodd\\" sketch:type=\\"MSPage\\">\\n        <g id=\\"Check-+-Oval-2\\" sketch:type=\\"MSLayerGroup\\" stroke=\\"#747474\\" stroke-opacity=\\"0.198794158\\" fill=\\"#FFFFFF\\" fill-opacity=\\"0.816519475\\">\\n          <path d=\\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\" id=\\"Oval-2\\" sketch:type=\\"MSShapeGroup\\"></path>\\n        </g>\\n      </g>\\n    </svg>\\n  </div>\\n</div>",\n\n      /*\n      Those functions register themselves to the events on init and handle all\n      the user interface specific stuff. Overwriting them won\'t break the upload\n      but can break the way it\'s displayed.\n      You can overwrite them if you don\'t like the default behavior. If you just\n      want to add an additional event handler, register it on the dropzone object\n      and don\'t overwrite those options.\n       */\n      drop: function drop(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      dragstart: noop,\n      dragend: function dragend(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      dragenter: function dragenter(e) {\n        return this.element.classList.add("dz-drag-hover");\n      },\n      dragover: function dragover(e) {\n        return this.element.classList.add("dz-drag-hover");\n      },\n      dragleave: function dragleave(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      paste: noop,\n      reset: function reset() {\n        return this.element.classList.remove("dz-started");\n      },\n      addedfile: function addedfile(file) {\n        var j, k, l, len, len1, len2, node, ref, ref1, ref2, removeFileEvent, removeLink, results;\n\n        if (this.element === this.previewsContainer) {\n          this.element.classList.add("dz-started");\n        }\n\n        if (this.previewsContainer) {\n          file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());\n          file.previewTemplate = file.previewElement;\n          this.previewsContainer.appendChild(file.previewElement);\n          ref = file.previewElement.querySelectorAll("[data-dz-name]");\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            node = ref[j];\n            node.textContent = file.name;\n          }\n\n          ref1 = file.previewElement.querySelectorAll("[data-dz-size]");\n\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            node = ref1[k];\n            node.innerHTML = this.filesize(file.size);\n          }\n\n          if (this.options.addRemoveLinks) {\n            file._removeLink = Dropzone.createElement("<a class=\\"dz-remove\\" href=\\"javascript:undefined;\\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");\n            file.previewElement.appendChild(file._removeLink);\n          }\n\n          removeFileEvent = function (_this) {\n            return function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n\n              if (file.status === Dropzone.UPLOADING) {\n                return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function () {\n                  return _this.removeFile(file);\n                });\n              } else {\n                if (_this.options.dictRemoveFileConfirmation) {\n                  return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function () {\n                    return _this.removeFile(file);\n                  });\n                } else {\n                  return _this.removeFile(file);\n                }\n              }\n            };\n          }(this);\n\n          ref2 = file.previewElement.querySelectorAll("[data-dz-remove]");\n          results = [];\n\n          for (l = 0, len2 = ref2.length; l < len2; l++) {\n            removeLink = ref2[l];\n            results.push(removeLink.addEventListener("click", removeFileEvent));\n          }\n\n          return results;\n        }\n      },\n      removedfile: function removedfile(file) {\n        var ref;\n\n        if (file.previewElement) {\n          if ((ref = file.previewElement) != null) {\n            ref.parentNode.removeChild(file.previewElement);\n          }\n        }\n\n        return this._updateMaxFilesReachedClass();\n      },\n      thumbnail: function thumbnail(file, dataUrl) {\n        var j, len, ref, thumbnailElement;\n\n        if (file.previewElement) {\n          file.previewElement.classList.remove("dz-file-preview");\n          ref = file.previewElement.querySelectorAll("[data-dz-thumbnail]");\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            thumbnailElement = ref[j];\n            thumbnailElement.alt = file.name;\n            thumbnailElement.src = dataUrl;\n          }\n\n          return setTimeout(function (_this) {\n            return function () {\n              return file.previewElement.classList.add("dz-image-preview");\n            };\n          }(this), 1);\n        }\n      },\n      error: function error(file, message) {\n        var j, len, node, ref, results;\n\n        if (file.previewElement) {\n          file.previewElement.classList.add("dz-error");\n\n          if (typeof message !== "String" && message.error) {\n            message = message.error;\n          }\n\n          ref = file.previewElement.querySelectorAll("[data-dz-errormessage]");\n          results = [];\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            node = ref[j];\n            results.push(node.textContent = message);\n          }\n\n          return results;\n        }\n      },\n      errormultiple: noop,\n      processing: function processing(file) {\n        if (file.previewElement) {\n          file.previewElement.classList.add("dz-processing");\n\n          if (file._removeLink) {\n            return file._removeLink.textContent = this.options.dictCancelUpload;\n          }\n        }\n      },\n      processingmultiple: noop,\n      uploadprogress: function uploadprogress(file, progress, bytesSent) {\n        var j, len, node, ref, results;\n\n        if (file.previewElement) {\n          ref = file.previewElement.querySelectorAll("[data-dz-uploadprogress]");\n          results = [];\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            node = ref[j];\n\n            if (node.nodeName === \'PROGRESS\') {\n              results.push(node.value = progress);\n            } else {\n              results.push(node.style.width = progress + "%");\n            }\n          }\n\n          return results;\n        }\n      },\n      totaluploadprogress: noop,\n      sending: noop,\n      sendingmultiple: noop,\n      success: function success(file) {\n        if (file.previewElement) {\n          return file.previewElement.classList.add("dz-success");\n        }\n      },\n      successmultiple: noop,\n      canceled: function canceled(file) {\n        return this.emit("error", file, "Upload canceled.");\n      },\n      canceledmultiple: noop,\n      complete: function complete(file) {\n        if (file._removeLink) {\n          file._removeLink.textContent = this.options.dictRemoveFile;\n        }\n\n        if (file.previewElement) {\n          return file.previewElement.classList.add("dz-complete");\n        }\n      },\n      completemultiple: noop,\n      maxfilesexceeded: noop,\n      maxfilesreached: noop,\n      queuecomplete: noop,\n      addedfiles: noop\n    };\n\n    extend = function extend() {\n      var j, key, len, object, objects, target, val;\n      target = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\n      for (j = 0, len = objects.length; j < len; j++) {\n        object = objects[j];\n\n        for (key in object) {\n          val = object[key];\n          target[key] = val;\n        }\n      }\n\n      return target;\n    };\n\n    function Dropzone(element1, options) {\n      var elementOptions, fallback, ref;\n      this.element = element1;\n      this.version = Dropzone.version;\n      this.defaultOptions.previewTemplate = this.defaultOptions.previewTemplate.replace(/\\n*/g, "");\n      this.clickableElements = [];\n      this.listeners = [];\n      this.files = [];\n\n      if (typeof this.element === "string") {\n        this.element = document.querySelector(this.element);\n      }\n\n      if (!(this.element && this.element.nodeType != null)) {\n        throw new Error("Invalid dropzone element.");\n      }\n\n      if (this.element.dropzone) {\n        throw new Error("Dropzone already attached.");\n      }\n\n      Dropzone.instances.push(this);\n      this.element.dropzone = this;\n      elementOptions = (ref = Dropzone.optionsForElement(this.element)) != null ? ref : {};\n      this.options = extend({}, this.defaultOptions, elementOptions, options != null ? options : {});\n\n      if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n        return this.options.fallback.call(this);\n      }\n\n      if (this.options.url == null) {\n        this.options.url = this.element.getAttribute("action");\n      }\n\n      if (!this.options.url) {\n        throw new Error("No URL provided.");\n      }\n\n      if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {\n        throw new Error("You can\'t provide both \'acceptedFiles\' and \'acceptedMimeTypes\'. \'acceptedMimeTypes\' is deprecated.");\n      }\n\n      if (this.options.acceptedMimeTypes) {\n        this.options.acceptedFiles = this.options.acceptedMimeTypes;\n        delete this.options.acceptedMimeTypes;\n      }\n\n      if (this.options.renameFilename != null) {\n        this.options.renameFile = function (_this) {\n          return function (file) {\n            return _this.options.renameFilename.call(_this, file.name, file);\n          };\n        }(this);\n      }\n\n      this.options.method = this.options.method.toUpperCase();\n\n      if ((fallback = this.getExistingFallback()) && fallback.parentNode) {\n        fallback.parentNode.removeChild(fallback);\n      }\n\n      if (this.options.previewsContainer !== false) {\n        if (this.options.previewsContainer) {\n          this.previewsContainer = Dropzone.getElement(this.options.previewsContainer, "previewsContainer");\n        } else {\n          this.previewsContainer = this.element;\n        }\n      }\n\n      if (this.options.clickable) {\n        if (this.options.clickable === true) {\n          this.clickableElements = [this.element];\n        } else {\n          this.clickableElements = Dropzone.getElements(this.options.clickable, "clickable");\n        }\n      }\n\n      this.init();\n    }\n\n    Dropzone.prototype.getAcceptedFiles = function () {\n      var file, j, len, ref, results;\n      ref = this.files;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n\n        if (file.accepted) {\n          results.push(file);\n        }\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.getRejectedFiles = function () {\n      var file, j, len, ref, results;\n      ref = this.files;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n\n        if (!file.accepted) {\n          results.push(file);\n        }\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.getFilesWithStatus = function (status) {\n      var file, j, len, ref, results;\n      ref = this.files;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n\n        if (file.status === status) {\n          results.push(file);\n        }\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.getQueuedFiles = function () {\n      return this.getFilesWithStatus(Dropzone.QUEUED);\n    };\n\n    Dropzone.prototype.getUploadingFiles = function () {\n      return this.getFilesWithStatus(Dropzone.UPLOADING);\n    };\n\n    Dropzone.prototype.getAddedFiles = function () {\n      return this.getFilesWithStatus(Dropzone.ADDED);\n    };\n\n    Dropzone.prototype.getActiveFiles = function () {\n      var file, j, len, ref, results;\n      ref = this.files;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n\n        if (file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED) {\n          results.push(file);\n        }\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.init = function () {\n      var eventName, j, len, noPropagation, ref, ref1, setupHiddenFileInput;\n\n      if (this.element.tagName === "form") {\n        this.element.setAttribute("enctype", "multipart/form-data");\n      }\n\n      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {\n        this.element.appendChild(Dropzone.createElement("<div class=\\"dz-default dz-message\\"><span>" + this.options.dictDefaultMessage + "</span></div>"));\n      }\n\n      if (this.clickableElements.length) {\n        setupHiddenFileInput = function (_this) {\n          return function () {\n            if (_this.hiddenFileInput) {\n              _this.hiddenFileInput.parentNode.removeChild(_this.hiddenFileInput);\n            }\n\n            _this.hiddenFileInput = document.createElement("input");\n\n            _this.hiddenFileInput.setAttribute("type", "file");\n\n            if (_this.options.maxFiles == null || _this.options.maxFiles > 1) {\n              _this.hiddenFileInput.setAttribute("multiple", "multiple");\n            }\n\n            _this.hiddenFileInput.className = "dz-hidden-input";\n\n            if (_this.options.acceptedFiles != null) {\n              _this.hiddenFileInput.setAttribute("accept", _this.options.acceptedFiles);\n            }\n\n            if (_this.options.capture != null) {\n              _this.hiddenFileInput.setAttribute("capture", _this.options.capture);\n            }\n\n            _this.hiddenFileInput.style.visibility = "hidden";\n            _this.hiddenFileInput.style.position = "absolute";\n            _this.hiddenFileInput.style.top = "0";\n            _this.hiddenFileInput.style.left = "0";\n            _this.hiddenFileInput.style.height = "0";\n            _this.hiddenFileInput.style.width = "0";\n            document.querySelector(_this.options.hiddenInputContainer).appendChild(_this.hiddenFileInput);\n            return _this.hiddenFileInput.addEventListener("change", function () {\n              var file, files, j, len;\n              files = _this.hiddenFileInput.files;\n\n              if (files.length) {\n                for (j = 0, len = files.length; j < len; j++) {\n                  file = files[j];\n\n                  _this.addFile(file);\n                }\n              }\n\n              _this.emit("addedfiles", files);\n\n              return setupHiddenFileInput();\n            });\n          };\n        }(this);\n\n        setupHiddenFileInput();\n      }\n\n      this.URL = (ref = window.URL) != null ? ref : window.webkitURL;\n      ref1 = this.events;\n\n      for (j = 0, len = ref1.length; j < len; j++) {\n        eventName = ref1[j];\n        this.on(eventName, this.options[eventName]);\n      }\n\n      this.on("uploadprogress", function (_this) {\n        return function () {\n          return _this.updateTotalUploadProgress();\n        };\n      }(this));\n      this.on("removedfile", function (_this) {\n        return function () {\n          return _this.updateTotalUploadProgress();\n        };\n      }(this));\n      this.on("canceled", function (_this) {\n        return function (file) {\n          return _this.emit("complete", file);\n        };\n      }(this));\n      this.on("complete", function (_this) {\n        return function (file) {\n          if (_this.getAddedFiles().length === 0 && _this.getUploadingFiles().length === 0 && _this.getQueuedFiles().length === 0) {\n            return setTimeout(function () {\n              return _this.emit("queuecomplete");\n            }, 0);\n          }\n        };\n      }(this));\n\n      noPropagation = function noPropagation(e) {\n        e.stopPropagation();\n\n        if (e.preventDefault) {\n          return e.preventDefault();\n        } else {\n          return e.returnValue = false;\n        }\n      };\n\n      this.listeners = [{\n        element: this.element,\n        events: {\n          "dragstart": function (_this) {\n            return function (e) {\n              return _this.emit("dragstart", e);\n            };\n          }(this),\n          "dragenter": function (_this) {\n            return function (e) {\n              noPropagation(e);\n              return _this.emit("dragenter", e);\n            };\n          }(this),\n          "dragover": function (_this) {\n            return function (e) {\n              var efct;\n\n              try {\n                efct = e.dataTransfer.effectAllowed;\n              } catch (undefined) {}\n\n              e.dataTransfer.dropEffect = \'move\' === efct || \'linkMove\' === efct ? \'move\' : \'copy\';\n              noPropagation(e);\n              return _this.emit("dragover", e);\n            };\n          }(this),\n          "dragleave": function (_this) {\n            return function (e) {\n              return _this.emit("dragleave", e);\n            };\n          }(this),\n          "drop": function (_this) {\n            return function (e) {\n              noPropagation(e);\n              return _this.drop(e);\n            };\n          }(this),\n          "dragend": function (_this) {\n            return function (e) {\n              return _this.emit("dragend", e);\n            };\n          }(this)\n        }\n      }];\n      this.clickableElements.forEach(function (_this) {\n        return function (clickableElement) {\n          return _this.listeners.push({\n            element: clickableElement,\n            events: {\n              "click": function click(evt) {\n                if (clickableElement !== _this.element || evt.target === _this.element || Dropzone.elementInside(evt.target, _this.element.querySelector(".dz-message"))) {\n                  _this.hiddenFileInput.click();\n                }\n\n                return true;\n              }\n            }\n          });\n        };\n      }(this));\n      this.enable();\n      return this.options.init.call(this);\n    };\n\n    Dropzone.prototype.destroy = function () {\n      var ref;\n      this.disable();\n      this.removeAllFiles(true);\n\n      if ((ref = this.hiddenFileInput) != null ? ref.parentNode : void 0) {\n        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        this.hiddenFileInput = null;\n      }\n\n      delete this.element.dropzone;\n      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n    };\n\n    Dropzone.prototype.updateTotalUploadProgress = function () {\n      var activeFiles, file, j, len, ref, totalBytes, totalBytesSent, totalUploadProgress;\n      totalBytesSent = 0;\n      totalBytes = 0;\n      activeFiles = this.getActiveFiles();\n\n      if (activeFiles.length) {\n        ref = this.getActiveFiles();\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          file = ref[j];\n          totalBytesSent += file.upload.bytesSent;\n          totalBytes += file.upload.total;\n        }\n\n        totalUploadProgress = 100 * totalBytesSent / totalBytes;\n      } else {\n        totalUploadProgress = 100;\n      }\n\n      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);\n    };\n\n    Dropzone.prototype._getParamName = function (n) {\n      if (typeof this.options.paramName === "function") {\n        return this.options.paramName(n);\n      } else {\n        return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");\n      }\n    };\n\n    Dropzone.prototype._renameFile = function (file) {\n      if (typeof this.options.renameFile !== "function") {\n        return file.name;\n      }\n\n      return this.options.renameFile(file);\n    };\n\n    Dropzone.prototype.getFallbackForm = function () {\n      var existingFallback, fields, fieldsString, form;\n\n      if (existingFallback = this.getExistingFallback()) {\n        return existingFallback;\n      }\n\n      fieldsString = "<div class=\\"dz-fallback\\">";\n\n      if (this.options.dictFallbackText) {\n        fieldsString += "<p>" + this.options.dictFallbackText + "</p>";\n      }\n\n      fieldsString += "<input type=\\"file\\" name=\\"" + this._getParamName(0) + "\\" " + (this.options.uploadMultiple ? \'multiple="multiple"\' : void 0) + " /><input type=\\"submit\\" value=\\"Upload!\\"></div>";\n      fields = Dropzone.createElement(fieldsString);\n\n      if (this.element.tagName !== "FORM") {\n        form = Dropzone.createElement("<form action=\\"" + this.options.url + "\\" enctype=\\"multipart/form-data\\" method=\\"" + this.options.method + "\\"></form>");\n        form.appendChild(fields);\n      } else {\n        this.element.setAttribute("enctype", "multipart/form-data");\n        this.element.setAttribute("method", this.options.method);\n      }\n\n      return form != null ? form : fields;\n    };\n\n    Dropzone.prototype.getExistingFallback = function () {\n      var fallback, getFallback, j, len, ref, tagName;\n\n      getFallback = function getFallback(elements) {\n        var el, j, len;\n\n        for (j = 0, len = elements.length; j < len; j++) {\n          el = elements[j];\n\n          if (/(^| )fallback($| )/.test(el.className)) {\n            return el;\n          }\n        }\n      };\n\n      ref = ["div", "form"];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        tagName = ref[j];\n\n        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\n          return fallback;\n        }\n      }\n    };\n\n    Dropzone.prototype.setupEventListeners = function () {\n      var elementListeners, event, j, len, listener, ref, results;\n      ref = this.listeners;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        elementListeners = ref[j];\n        results.push(function () {\n          var ref1, results1;\n          ref1 = elementListeners.events;\n          results1 = [];\n\n          for (event in ref1) {\n            listener = ref1[event];\n            results1.push(elementListeners.element.addEventListener(event, listener, false));\n          }\n\n          return results1;\n        }());\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.removeEventListeners = function () {\n      var elementListeners, event, j, len, listener, ref, results;\n      ref = this.listeners;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        elementListeners = ref[j];\n        results.push(function () {\n          var ref1, results1;\n          ref1 = elementListeners.events;\n          results1 = [];\n\n          for (event in ref1) {\n            listener = ref1[event];\n            results1.push(elementListeners.element.removeEventListener(event, listener, false));\n          }\n\n          return results1;\n        }());\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.disable = function () {\n      var file, j, len, ref, results;\n      this.clickableElements.forEach(function (element) {\n        return element.classList.remove("dz-clickable");\n      });\n      this.removeEventListeners();\n      ref = this.files;\n      results = [];\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n        results.push(this.cancelUpload(file));\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.enable = function () {\n      this.clickableElements.forEach(function (element) {\n        return element.classList.add("dz-clickable");\n      });\n      return this.setupEventListeners();\n    };\n\n    Dropzone.prototype.filesize = function (size) {\n      var cutoff, i, j, len, selectedSize, selectedUnit, unit, units;\n      selectedSize = 0;\n      selectedUnit = "b";\n\n      if (size > 0) {\n        units = [\'tb\', \'gb\', \'mb\', \'kb\', \'b\'];\n\n        for (i = j = 0, len = units.length; j < len; i = ++j) {\n          unit = units[i];\n          cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n\n          if (size >= cutoff) {\n            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n            selectedUnit = unit;\n            break;\n          }\n        }\n\n        selectedSize = Math.round(10 * selectedSize) / 10;\n      }\n\n      return "<strong>" + selectedSize + "</strong> " + this.options.dictFileSizeUnits[selectedUnit];\n    };\n\n    Dropzone.prototype._updateMaxFilesReachedClass = function () {\n      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        if (this.getAcceptedFiles().length === this.options.maxFiles) {\n          this.emit(\'maxfilesreached\', this.files);\n        }\n\n        return this.element.classList.add("dz-max-files-reached");\n      } else {\n        return this.element.classList.remove("dz-max-files-reached");\n      }\n    };\n\n    Dropzone.prototype.drop = function (e) {\n      var files, items;\n\n      if (!e.dataTransfer) {\n        return;\n      }\n\n      this.emit("drop", e);\n      files = e.dataTransfer.files;\n      this.emit("addedfiles", files);\n\n      if (files.length) {\n        items = e.dataTransfer.items;\n\n        if (items && items.length && items[0].webkitGetAsEntry != null) {\n          this._addFilesFromItems(items);\n        } else {\n          this.handleFiles(files);\n        }\n      }\n    };\n\n    Dropzone.prototype.paste = function (e) {\n      var items, ref;\n\n      if ((e != null ? (ref = e.clipboardData) != null ? ref.items : void 0 : void 0) == null) {\n        return;\n      }\n\n      this.emit("paste", e);\n      items = e.clipboardData.items;\n\n      if (items.length) {\n        return this._addFilesFromItems(items);\n      }\n    };\n\n    Dropzone.prototype.handleFiles = function (files) {\n      var file, j, len, results;\n      results = [];\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        results.push(this.addFile(file));\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype._addFilesFromItems = function (items) {\n      var entry, item, j, len, results;\n      results = [];\n\n      for (j = 0, len = items.length; j < len; j++) {\n        item = items[j];\n\n        if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {\n          if (entry.isFile) {\n            results.push(this.addFile(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            results.push(this._addFilesFromDirectory(entry, entry.name));\n          } else {\n            results.push(void 0);\n          }\n        } else if (item.getAsFile != null) {\n          if (item.kind == null || item.kind === "file") {\n            results.push(this.addFile(item.getAsFile()));\n          } else {\n            results.push(void 0);\n          }\n        } else {\n          results.push(void 0);\n        }\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype._addFilesFromDirectory = function (directory, path) {\n      var dirReader, errorHandler, readEntries;\n      dirReader = directory.createReader();\n\n      errorHandler = function errorHandler(error) {\n        return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log(error) : void 0 : void 0;\n      };\n\n      readEntries = function (_this) {\n        return function () {\n          return dirReader.readEntries(function (entries) {\n            var entry, j, len;\n\n            if (entries.length > 0) {\n              for (j = 0, len = entries.length; j < len; j++) {\n                entry = entries[j];\n\n                if (entry.isFile) {\n                  entry.file(function (file) {\n                    if (_this.options.ignoreHiddenFiles && file.name.substring(0, 1) === \'.\') {\n                      return;\n                    }\n\n                    file.fullPath = path + "/" + file.name;\n                    return _this.addFile(file);\n                  });\n                } else if (entry.isDirectory) {\n                  _this._addFilesFromDirectory(entry, path + "/" + entry.name);\n                }\n              }\n\n              readEntries();\n            }\n\n            return null;\n          }, errorHandler);\n        };\n      }(this);\n\n      return readEntries();\n    };\n\n    Dropzone.prototype.accept = function (file, done) {\n      if (file.size > this.options.maxFilesize * 1024 * 1024) {\n        return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));\n      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n        return done(this.options.dictInvalidFileType);\n      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));\n        return this.emit("maxfilesexceeded", file);\n      } else {\n        return this.options.accept.call(this, file, done);\n      }\n    };\n\n    Dropzone.prototype.addFile = function (file) {\n      file.upload = {\n        progress: 0,\n        total: file.size,\n        bytesSent: 0,\n        filename: this._renameFile(file)\n      };\n      this.files.push(file);\n      file.status = Dropzone.ADDED;\n      this.emit("addedfile", file);\n\n      this._enqueueThumbnail(file);\n\n      return this.accept(file, function (_this) {\n        return function (error) {\n          if (error) {\n            file.accepted = false;\n\n            _this._errorProcessing([file], error);\n          } else {\n            file.accepted = true;\n\n            if (_this.options.autoQueue) {\n              _this.enqueueFile(file);\n            }\n          }\n\n          return _this._updateMaxFilesReachedClass();\n        };\n      }(this));\n    };\n\n    Dropzone.prototype.enqueueFiles = function (files) {\n      var file, j, len;\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        this.enqueueFile(file);\n      }\n\n      return null;\n    };\n\n    Dropzone.prototype.enqueueFile = function (file) {\n      if (file.status === Dropzone.ADDED && file.accepted === true) {\n        file.status = Dropzone.QUEUED;\n\n        if (this.options.autoProcessQueue) {\n          return setTimeout(function (_this) {\n            return function () {\n              return _this.processQueue();\n            };\n          }(this), 0);\n        }\n      } else {\n        throw new Error("This file can\'t be queued because it has already been processed or was rejected.");\n      }\n    };\n\n    Dropzone.prototype._thumbnailQueue = [];\n    Dropzone.prototype._processingThumbnail = false;\n\n    Dropzone.prototype._enqueueThumbnail = function (file) {\n      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\n        this._thumbnailQueue.push(file);\n\n        return setTimeout(function (_this) {\n          return function () {\n            return _this._processThumbnailQueue();\n          };\n        }(this), 0);\n      }\n    };\n\n    Dropzone.prototype._processThumbnailQueue = function () {\n      var file;\n\n      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n        return;\n      }\n\n      this._processingThumbnail = true;\n      file = this._thumbnailQueue.shift();\n      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (_this) {\n        return function (dataUrl) {\n          _this.emit("thumbnail", file, dataUrl);\n\n          _this._processingThumbnail = false;\n          return _this._processThumbnailQueue();\n        };\n      }(this));\n    };\n\n    Dropzone.prototype.removeFile = function (file) {\n      if (file.status === Dropzone.UPLOADING) {\n        this.cancelUpload(file);\n      }\n\n      this.files = without(this.files, file);\n      this.emit("removedfile", file);\n\n      if (this.files.length === 0) {\n        return this.emit("reset");\n      }\n    };\n\n    Dropzone.prototype.removeAllFiles = function (cancelIfNecessary) {\n      var file, j, len, ref;\n\n      if (cancelIfNecessary == null) {\n        cancelIfNecessary = false;\n      }\n\n      ref = this.files.slice();\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        file = ref[j];\n\n        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n          this.removeFile(file);\n        }\n      }\n\n      return null;\n    };\n\n    Dropzone.prototype.resizeImage = function (file, width, height, resizeMethod, callback) {\n      return this.createThumbnail(file, width, height, resizeMethod, false, function (_this) {\n        return function (dataUrl, canvas) {\n          var resizeMimeType, resizedDataURL;\n\n          if (canvas === null) {\n            return callback(file);\n          } else {\n            resizeMimeType = _this.options.resizeMimeType;\n\n            if (resizeMimeType == null) {\n              resizeMimeType = file.type;\n            }\n\n            resizedDataURL = canvas.toDataURL(resizeMimeType, _this.options.resizeQuality);\n\n            if (resizeMimeType === \'image/jpeg\' || resizeMimeType === \'image/jpg\') {\n              resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\n            }\n\n            return callback(Dropzone.dataURItoBlob(resizedDataURL));\n          }\n        };\n      }(this));\n    };\n\n    Dropzone.prototype.createThumbnail = function (file, width, height, resizeMethod, fixOrientation, callback) {\n      var fileReader;\n      fileReader = new FileReader();\n\n      fileReader.onload = function (_this) {\n        return function () {\n          file.dataURL = fileReader.result;\n\n          if (file.type === "image/svg+xml") {\n            if (callback != null) {\n              callback(fileReader.result);\n            }\n\n            return;\n          }\n\n          return _this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);\n        };\n      }(this);\n\n      return fileReader.readAsDataURL(file);\n    };\n\n    Dropzone.prototype.createThumbnailFromUrl = function (file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {\n      var img;\n      img = document.createElement("img");\n\n      if (crossOrigin) {\n        img.crossOrigin = crossOrigin;\n      }\n\n      img.onload = function (_this) {\n        return function () {\n          var loadExif;\n\n          loadExif = function loadExif(callback) {\n            return callback(1);\n          };\n\n          if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) {\n            loadExif = function loadExif(callback) {\n              return EXIF.getData(img, function () {\n                return callback(EXIF.getTag(this, \'Orientation\'));\n              });\n            };\n          }\n\n          return loadExif(function (orientation) {\n            var canvas, ctx, ref, ref1, ref2, ref3, resizeInfo, thumbnail;\n            file.width = img.width;\n            file.height = img.height;\n            resizeInfo = _this.options.resize.call(_this, file, width, height, resizeMethod);\n            canvas = document.createElement("canvas");\n            ctx = canvas.getContext("2d");\n            canvas.width = resizeInfo.trgWidth;\n            canvas.height = resizeInfo.trgHeight;\n\n            if (orientation > 4) {\n              canvas.width = resizeInfo.trgHeight;\n              canvas.height = resizeInfo.trgWidth;\n            }\n\n            switch (orientation) {\n              case 2:\n                ctx.translate(canvas.width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(canvas.width, canvas.height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, canvas.height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(0.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(0, -canvas.height);\n                break;\n\n              case 7:\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(canvas.width, -canvas.height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-0.5 * Math.PI);\n                ctx.translate(-canvas.width, 0);\n            }\n\n            drawImageIOSFix(ctx, img, (ref = resizeInfo.srcX) != null ? ref : 0, (ref1 = resizeInfo.srcY) != null ? ref1 : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, (ref2 = resizeInfo.trgX) != null ? ref2 : 0, (ref3 = resizeInfo.trgY) != null ? ref3 : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\n            thumbnail = canvas.toDataURL("image/png");\n\n            if (callback != null) {\n              return callback(thumbnail, canvas);\n            }\n          });\n        };\n      }(this);\n\n      if (callback != null) {\n        img.onerror = callback;\n      }\n\n      return img.src = file.dataURL;\n    };\n\n    Dropzone.prototype.processQueue = function () {\n      var i, parallelUploads, processingLength, queuedFiles;\n      parallelUploads = this.options.parallelUploads;\n      processingLength = this.getUploadingFiles().length;\n      i = processingLength;\n\n      if (processingLength >= parallelUploads) {\n        return;\n      }\n\n      queuedFiles = this.getQueuedFiles();\n\n      if (!(queuedFiles.length > 0)) {\n        return;\n      }\n\n      if (this.options.uploadMultiple) {\n        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\n      } else {\n        while (i < parallelUploads) {\n          if (!queuedFiles.length) {\n            return;\n          }\n\n          this.processFile(queuedFiles.shift());\n          i++;\n        }\n      }\n    };\n\n    Dropzone.prototype.processFile = function (file) {\n      return this.processFiles([file]);\n    };\n\n    Dropzone.prototype.processFiles = function (files) {\n      var file, j, len;\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        file.processing = true;\n        file.status = Dropzone.UPLOADING;\n        this.emit("processing", file);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit("processingmultiple", files);\n      }\n\n      return this.uploadFiles(files);\n    };\n\n    Dropzone.prototype._getFilesWithXhr = function (xhr) {\n      var file, files;\n      return files = function () {\n        var j, len, ref, results;\n        ref = this.files;\n        results = [];\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          file = ref[j];\n\n          if (file.xhr === xhr) {\n            results.push(file);\n          }\n        }\n\n        return results;\n      }.call(this);\n    };\n\n    Dropzone.prototype.cancelUpload = function (file) {\n      var groupedFile, groupedFiles, j, k, len, len1, ref;\n\n      if (file.status === Dropzone.UPLOADING) {\n        groupedFiles = this._getFilesWithXhr(file.xhr);\n\n        for (j = 0, len = groupedFiles.length; j < len; j++) {\n          groupedFile = groupedFiles[j];\n          groupedFile.status = Dropzone.CANCELED;\n        }\n\n        file.xhr.abort();\n\n        for (k = 0, len1 = groupedFiles.length; k < len1; k++) {\n          groupedFile = groupedFiles[k];\n          this.emit("canceled", groupedFile);\n        }\n\n        if (this.options.uploadMultiple) {\n          this.emit("canceledmultiple", groupedFiles);\n        }\n      } else if ((ref = file.status) === Dropzone.ADDED || ref === Dropzone.QUEUED) {\n        file.status = Dropzone.CANCELED;\n        this.emit("canceled", file);\n\n        if (this.options.uploadMultiple) {\n          this.emit("canceledmultiple", [file]);\n        }\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    resolveOption = function resolveOption() {\n      var args, option;\n      option = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\n      if (typeof option === \'function\') {\n        return option.apply(this, args);\n      }\n\n      return option;\n    };\n\n    Dropzone.prototype.uploadFile = function (file) {\n      return this.uploadFiles([file]);\n    };\n\n    Dropzone.prototype.uploadFiles = function (files) {\n      var doneCounter, doneFunction, file, formData, handleError, headerName, headerValue, headers, i, input, inputName, inputType, j, k, key, l, len, len1, len2, len3, m, method, o, option, progressObj, ref, ref1, ref2, ref3, ref4, ref5, response, results, updateProgress, url, value, xhr;\n      xhr = new XMLHttpRequest();\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        file.xhr = xhr;\n      }\n\n      method = resolveOption(this.options.method, files);\n      url = resolveOption(this.options.url, files);\n      xhr.open(method, url, true);\n      xhr.timeout = resolveOption(this.options.timeout, files);\n      xhr.withCredentials = !!this.options.withCredentials;\n      response = null;\n\n      handleError = function (_this) {\n        return function () {\n          var k, len1, results;\n          results = [];\n\n          for (k = 0, len1 = files.length; k < len1; k++) {\n            file = files[k];\n            results.push(_this._errorProcessing(files, response || _this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr));\n          }\n\n          return results;\n        };\n      }(this);\n\n      updateProgress = function (_this) {\n        return function (e) {\n          var allFilesFinished, k, l, len1, len2, len3, m, progress, results;\n\n          if (e != null) {\n            progress = 100 * e.loaded / e.total;\n\n            for (k = 0, len1 = files.length; k < len1; k++) {\n              file = files[k];\n              file.upload.progress = progress;\n              file.upload.total = e.total;\n              file.upload.bytesSent = e.loaded;\n            }\n          } else {\n            allFilesFinished = true;\n            progress = 100;\n\n            for (l = 0, len2 = files.length; l < len2; l++) {\n              file = files[l];\n\n              if (!(file.upload.progress === 100 && file.upload.bytesSent === file.upload.total)) {\n                allFilesFinished = false;\n              }\n\n              file.upload.progress = progress;\n              file.upload.bytesSent = file.upload.total;\n            }\n\n            if (allFilesFinished) {\n              return;\n            }\n          }\n\n          results = [];\n\n          for (m = 0, len3 = files.length; m < len3; m++) {\n            file = files[m];\n            results.push(_this.emit("uploadprogress", file, progress, file.upload.bytesSent));\n          }\n\n          return results;\n        };\n      }(this);\n\n      xhr.onload = function (_this) {\n        return function (e) {\n          var error1, ref;\n\n          if (files[0].status === Dropzone.CANCELED) {\n            return;\n          }\n\n          if (xhr.readyState !== 4) {\n            return;\n          }\n\n          if (xhr.responseType !== \'arraybuffer\' && xhr.responseType !== \'blob\') {\n            response = xhr.responseText;\n\n            if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {\n              try {\n                response = JSON.parse(response);\n              } catch (error1) {\n                e = error1;\n                response = "Invalid JSON response from server.";\n              }\n            }\n          }\n\n          updateProgress();\n\n          if (!(200 <= (ref = xhr.status) && ref < 300)) {\n            return handleError();\n          } else {\n            return _this._finished(files, response, e);\n          }\n        };\n      }(this);\n\n      xhr.onerror = function (_this) {\n        return function () {\n          if (files[0].status === Dropzone.CANCELED) {\n            return;\n          }\n\n          return handleError();\n        };\n      }(this);\n\n      progressObj = (ref = xhr.upload) != null ? ref : xhr;\n      progressObj.onprogress = updateProgress;\n      headers = {\n        "Accept": "application/json",\n        "Cache-Control": "no-cache",\n        "X-Requested-With": "XMLHttpRequest"\n      };\n\n      if (this.options.headers) {\n        extend(headers, this.options.headers);\n      }\n\n      for (headerName in headers) {\n        headerValue = headers[headerName];\n\n        if (headerValue) {\n          xhr.setRequestHeader(headerName, headerValue);\n        }\n      }\n\n      formData = new FormData();\n\n      if (this.options.params) {\n        ref1 = this.options.params;\n\n        for (key in ref1) {\n          value = ref1[key];\n          formData.append(key, value);\n        }\n      }\n\n      for (k = 0, len1 = files.length; k < len1; k++) {\n        file = files[k];\n        this.emit("sending", file, xhr, formData);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit("sendingmultiple", files, xhr, formData);\n      }\n\n      if (this.element.tagName === "FORM") {\n        ref2 = this.element.querySelectorAll("input, textarea, select, button");\n\n        for (l = 0, len2 = ref2.length; l < len2; l++) {\n          input = ref2[l];\n          inputName = input.getAttribute("name");\n          inputType = input.getAttribute("type");\n\n          if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {\n            ref3 = input.options;\n\n            for (m = 0, len3 = ref3.length; m < len3; m++) {\n              option = ref3[m];\n\n              if (option.selected) {\n                formData.append(inputName, option.value);\n              }\n            }\n          } else if (!inputType || (ref4 = inputType.toLowerCase()) !== "checkbox" && ref4 !== "radio" || input.checked) {\n            formData.append(inputName, input.value);\n          }\n        }\n      }\n\n      doneCounter = 0;\n      results = [];\n\n      for (i = o = 0, ref5 = files.length - 1; 0 <= ref5 ? o <= ref5 : o >= ref5; i = 0 <= ref5 ? ++o : --o) {\n        doneFunction = function (_this) {\n          return function (file, paramName, fileName) {\n            return function (transformedFile) {\n              formData.append(paramName, transformedFile, fileName);\n\n              if (++doneCounter === files.length) {\n                return _this.submitRequest(xhr, formData, files);\n              }\n            };\n          };\n        }(this);\n\n        results.push(this.options.transformFile.call(this, files[i], doneFunction(files[i], this._getParamName(i), files[i].upload.filename)));\n      }\n\n      return results;\n    };\n\n    Dropzone.prototype.submitRequest = function (xhr, formData, files) {\n      return xhr.send(formData);\n    };\n\n    Dropzone.prototype._finished = function (files, responseText, e) {\n      var file, j, len;\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        file.status = Dropzone.SUCCESS;\n        this.emit("success", file, responseText, e);\n        this.emit("complete", file);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit("successmultiple", files, responseText, e);\n        this.emit("completemultiple", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    Dropzone.prototype._errorProcessing = function (files, message, xhr) {\n      var file, j, len;\n\n      for (j = 0, len = files.length; j < len; j++) {\n        file = files[j];\n        file.status = Dropzone.ERROR;\n        this.emit("error", file, message, xhr);\n        this.emit("complete", file);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit("errormultiple", files, message, xhr);\n        this.emit("completemultiple", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    return Dropzone;\n  }(Emitter);\n\n  Dropzone.version = "5.1.1";\n  Dropzone.options = {};\n\n  Dropzone.optionsForElement = function (element) {\n    if (element.getAttribute("id")) {\n      return Dropzone.options[camelize(element.getAttribute("id"))];\n    } else {\n      return void 0;\n    }\n  };\n\n  Dropzone.instances = [];\n\n  Dropzone.forElement = function (element) {\n    if (typeof element === "string") {\n      element = document.querySelector(element);\n    }\n\n    if ((element != null ? element.dropzone : void 0) == null) {\n      throw new Error("No Dropzone found for given element. This is probably because you\'re trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");\n    }\n\n    return element.dropzone;\n  };\n\n  Dropzone.autoDiscover = true;\n\n  Dropzone.discover = function () {\n    var checkElements, dropzone, dropzones, j, len, results;\n\n    if (document.querySelectorAll) {\n      dropzones = document.querySelectorAll(".dropzone");\n    } else {\n      dropzones = [];\n\n      checkElements = function checkElements(elements) {\n        var el, j, len, results;\n        results = [];\n\n        for (j = 0, len = elements.length; j < len; j++) {\n          el = elements[j];\n\n          if (/(^| )dropzone($| )/.test(el.className)) {\n            results.push(dropzones.push(el));\n          } else {\n            results.push(void 0);\n          }\n        }\n\n        return results;\n      };\n\n      checkElements(document.getElementsByTagName("div"));\n      checkElements(document.getElementsByTagName("form"));\n    }\n\n    results = [];\n\n    for (j = 0, len = dropzones.length; j < len; j++) {\n      dropzone = dropzones[j];\n\n      if (Dropzone.optionsForElement(dropzone) !== false) {\n        results.push(new Dropzone(dropzone));\n      } else {\n        results.push(void 0);\n      }\n    }\n\n    return results;\n  };\n\n  Dropzone.blacklistedBrowsers = [/opera.*Macintosh.*version\\/12/i];\n\n  Dropzone.isBrowserSupported = function () {\n    var capableBrowser, j, len, ref, regex;\n    capableBrowser = true;\n\n    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\n      if (!("classList" in document.createElement("a"))) {\n        capableBrowser = false;\n      } else {\n        ref = Dropzone.blacklistedBrowsers;\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          regex = ref[j];\n\n          if (regex.test(navigator.userAgent)) {\n            capableBrowser = false;\n            continue;\n          }\n        }\n      }\n    } else {\n      capableBrowser = false;\n    }\n\n    return capableBrowser;\n  };\n\n  Dropzone.dataURItoBlob = function (dataURI) {\n    var ab, byteString, i, ia, j, mimeString, ref;\n    byteString = atob(dataURI.split(\',\')[1]);\n    mimeString = dataURI.split(\',\')[0].split(\':\')[1].split(\';\')[0];\n    ab = new ArrayBuffer(byteString.length);\n    ia = new Uint8Array(ab);\n\n    for (i = j = 0, ref = byteString.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      ia[i] = byteString.charCodeAt(i);\n    }\n\n    return new Blob([ab], {\n      type: mimeString\n    });\n  };\n\n  without = function without(list, rejectedItem) {\n    var item, j, len, results;\n    results = [];\n\n    for (j = 0, len = list.length; j < len; j++) {\n      item = list[j];\n\n      if (item !== rejectedItem) {\n        results.push(item);\n      }\n    }\n\n    return results;\n  };\n\n  camelize = function camelize(str) {\n    return str.replace(/[\\-_](\\w)/g, function (match) {\n      return match.charAt(1).toUpperCase();\n    });\n  };\n\n  Dropzone.createElement = function (string) {\n    var div;\n    div = document.createElement("div");\n    div.innerHTML = string;\n    return div.childNodes[0];\n  };\n\n  Dropzone.elementInside = function (element, container) {\n    if (element === container) {\n      return true;\n    }\n\n    while (element = element.parentNode) {\n      if (element === container) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Dropzone.getElement = function (el, name) {\n    var element;\n\n    if (typeof el === "string") {\n      element = document.querySelector(el);\n    } else if (el.nodeType != null) {\n      element = el;\n    }\n\n    if (element == null) {\n      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");\n    }\n\n    return element;\n  };\n\n  Dropzone.getElements = function (els, name) {\n    var e, el, elements, error1, j, k, len, len1, ref;\n\n    if (els instanceof Array) {\n      elements = [];\n\n      try {\n        for (j = 0, len = els.length; j < len; j++) {\n          el = els[j];\n          elements.push(this.getElement(el, name));\n        }\n      } catch (error1) {\n        e = error1;\n        elements = null;\n      }\n    } else if (typeof els === "string") {\n      elements = [];\n      ref = document.querySelectorAll(els);\n\n      for (k = 0, len1 = ref.length; k < len1; k++) {\n        el = ref[k];\n        elements.push(el);\n      }\n    } else if (els.nodeType != null) {\n      elements = [els];\n    }\n\n    if (!(elements != null && elements.length)) {\n      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");\n    }\n\n    return elements;\n  };\n\n  Dropzone.confirm = function (question, accepted, rejected) {\n    if (window.confirm(question)) {\n      return accepted();\n    } else if (rejected != null) {\n      return rejected();\n    }\n  };\n\n  Dropzone.isValidFile = function (file, acceptedFiles) {\n    var baseMimeType, j, len, mimeType, validType;\n\n    if (!acceptedFiles) {\n      return true;\n    }\n\n    acceptedFiles = acceptedFiles.split(",");\n    mimeType = file.type;\n    baseMimeType = mimeType.replace(/\\/.*$/, "");\n\n    for (j = 0, len = acceptedFiles.length; j < len; j++) {\n      validType = acceptedFiles[j];\n      validType = validType.trim();\n\n      if (validType.charAt(0) === ".") {\n        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\n          return true;\n        }\n      } else if (/\\/\\*$/.test(validType)) {\n        if (baseMimeType === validType.replace(/\\/.*$/, "")) {\n          return true;\n        }\n      } else {\n        if (mimeType === validType) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  if (typeof jQuery !== "undefined" && jQuery !== null) {\n    jQuery.fn.dropzone = function (options) {\n      return this.each(function () {\n        return new Dropzone(this, options);\n      });\n    };\n  }\n\n  if (typeof module !== "undefined" && module !== null) {\n    module.exports = Dropzone;\n  } else {\n    window.Dropzone = Dropzone;\n  }\n\n  Dropzone.ADDED = "added";\n  Dropzone.QUEUED = "queued";\n  Dropzone.ACCEPTED = Dropzone.QUEUED;\n  Dropzone.UPLOADING = "uploading";\n  Dropzone.PROCESSING = Dropzone.UPLOADING;\n  Dropzone.CANCELED = "canceled";\n  Dropzone.ERROR = "error";\n  Dropzone.SUCCESS = "success";\n  /*\n  \n  Bugfix for iOS 6 and 7\n  Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n  based on the work of https://github.com/stomita/ios-imagefile-megapixel\n   */\n\n  detectVerticalSquash = function detectVerticalSquash(img) {\n    var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;\n    iw = img.naturalWidth;\n    ih = img.naturalHeight;\n    canvas = document.createElement("canvas");\n    canvas.width = 1;\n    canvas.height = ih;\n    ctx = canvas.getContext("2d");\n    ctx.drawImage(img, 0, 0);\n    data = ctx.getImageData(1, 0, 1, ih).data;\n    sy = 0;\n    ey = ih;\n    py = ih;\n\n    while (py > sy) {\n      alpha = data[(py - 1) * 4 + 3];\n\n      if (alpha === 0) {\n        ey = py;\n      } else {\n        sy = py;\n      }\n\n      py = ey + sy >> 1;\n    }\n\n    ratio = py / ih;\n\n    if (ratio === 0) {\n      return 1;\n    } else {\n      return ratio;\n    }\n  };\n\n  drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n    var vertSquashRatio;\n    vertSquashRatio = detectVerticalSquash(img);\n    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n  };\n\n  ExifRestore = function () {\n    function ExifRestore() {}\n\n    ExifRestore.KEY_STR = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\';\n\n    ExifRestore.encode64 = function (input) {\n      var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;\n      output = \'\';\n      chr1 = void 0;\n      chr2 = void 0;\n      chr3 = \'\';\n      enc1 = void 0;\n      enc2 = void 0;\n      enc3 = void 0;\n      enc4 = \'\';\n      i = 0;\n\n      while (true) {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = \'\';\n        enc1 = enc2 = enc3 = enc4 = \'\';\n\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n\n      return output;\n    };\n\n    ExifRestore.restore = function (origFileBase64, resizedFileBase64) {\n      var image, rawImage, segments;\n\n      if (!origFileBase64.match(\'data:image/jpeg;base64,\')) {\n        return resizedFileBase64;\n      }\n\n      rawImage = this.decode64(origFileBase64.replace(\'data:image/jpeg;base64,\', \'\'));\n      segments = this.slice2Segments(rawImage);\n      image = this.exifManipulation(resizedFileBase64, segments);\n      return \'data:image/jpeg;base64,\' + this.encode64(image);\n    };\n\n    ExifRestore.exifManipulation = function (resizedFileBase64, segments) {\n      var aBuffer, exifArray, newImageArray;\n      exifArray = this.getExifArray(segments);\n      newImageArray = this.insertExif(resizedFileBase64, exifArray);\n      aBuffer = new Uint8Array(newImageArray);\n      return aBuffer;\n    };\n\n    ExifRestore.getExifArray = function (segments) {\n      var seg, x;\n      seg = void 0;\n      x = 0;\n\n      while (x < segments.length) {\n        seg = segments[x];\n\n        if (seg[0] === 255 & seg[1] === 225) {\n          return seg;\n        }\n\n        x++;\n      }\n\n      return [];\n    };\n\n    ExifRestore.insertExif = function (resizedFileBase64, exifArray) {\n      var array, ato, buf, imageData, mae, separatePoint;\n      imageData = resizedFileBase64.replace(\'data:image/jpeg;base64,\', \'\');\n      buf = this.decode64(imageData);\n      separatePoint = buf.indexOf(255, 3);\n      mae = buf.slice(0, separatePoint);\n      ato = buf.slice(separatePoint);\n      array = mae;\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    };\n\n    ExifRestore.slice2Segments = function (rawImageArray) {\n      var endPoint, head, length, seg, segments;\n      head = 0;\n      segments = [];\n\n      while (true) {\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n          break;\n        }\n\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n          head += 2;\n        } else {\n          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\n          endPoint = head + length + 2;\n          seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n\n      return segments;\n    };\n\n    ExifRestore.decode64 = function (input) {\n      var base64test, buf, chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;\n      output = \'\';\n      chr1 = void 0;\n      chr2 = void 0;\n      chr3 = \'\';\n      enc1 = void 0;\n      enc2 = void 0;\n      enc3 = void 0;\n      enc4 = \'\';\n      i = 0;\n      buf = [];\n      base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n\n      if (base64test.exec(input)) {\n        console.warning(\'There were invalid base64 characters in the input text.\\n\' + \'Valid base64 characters are A-Z, a-z, 0-9, \\\'+\\\', \\\'/\\\',and \\\'=\\\'\\n\' + \'Expect errors in decoding.\');\n      }\n\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \'\');\n\n      while (true) {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        buf.push(chr1);\n\n        if (enc3 !== 64) {\n          buf.push(chr2);\n        }\n\n        if (enc4 !== 64) {\n          buf.push(chr3);\n        }\n\n        chr1 = chr2 = chr3 = \'\';\n        enc1 = enc2 = enc3 = enc4 = \'\';\n\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n\n      return buf;\n    };\n\n    return ExifRestore;\n  }();\n  /*\n   * contentloaded.js\n   *\n   * Author: Diego Perini (diego.perini at gmail.com)\n   * Summary: cross-browser wrapper for DOMContentLoaded\n   * Updated: 20101020\n   * License: MIT\n   * Version: 1.2\n   *\n   * URL:\n   * http://javascript.nwbox.com/ContentLoaded/\n   * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n   */\n\n\n  contentLoaded = function contentLoaded(win, fn) {\n    var add, doc, done, _init, _poll, pre, rem, root, top;\n\n    done = false;\n    top = true;\n    doc = win.document;\n    root = doc.documentElement;\n    add = doc.addEventListener ? "addEventListener" : "attachEvent";\n    rem = doc.addEventListener ? "removeEventListener" : "detachEvent";\n    pre = doc.addEventListener ? "" : "on";\n\n    _init = function init(e) {\n      if (e.type === "readystatechange" && doc.readyState !== "complete") {\n        return;\n      }\n\n      (e.type === "load" ? win : doc)[rem](pre + e.type, _init, false);\n\n      if (!done && (done = true)) {\n        return fn.call(win, e.type || e);\n      }\n    };\n\n    _poll = function poll() {\n      var e, error1;\n\n      try {\n        root.doScroll("left");\n      } catch (error1) {\n        e = error1;\n        setTimeout(_poll, 50);\n        return;\n      }\n\n      return _init("poll");\n    };\n\n    if (doc.readyState !== "complete") {\n      if (doc.createEventObject && root.doScroll) {\n        try {\n          top = !win.frameElement;\n        } catch (undefined) {}\n\n        if (top) {\n          _poll();\n        }\n      }\n\n      doc[add](pre + "DOMContentLoaded", _init, false);\n      doc[add](pre + "readystatechange", _init, false);\n      return win[add](pre + "load", _init, false);\n    }\n  };\n\n  Dropzone._autoDiscoverFunction = function () {\n    if (Dropzone.autoDiscover) {\n      return Dropzone.discover();\n    }\n  };\n\n  contentLoaded(window, Dropzone._autoDiscoverFunction);\n}).call(this);'},2317:function(n,e,t){t(1226)(t(2318))},2318:function(n,e){n.exports='function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function (e) {\n  "use strict";\n\n  function t(e, i, a) {\n    var o,\n        n = document.createElement("img");\n    return n.onerror = function (o) {\n      return t.onerror(n, o, e, i, a);\n    }, n.onload = function (o) {\n      return t.onload(n, o, e, i, a);\n    }, "string" == typeof e ? (t.fetchBlob(e, function (i) {\n      i ? (e = i, o = t.createObjectURL(e)) : (o = e, a && a.crossOrigin && (n.crossOrigin = a.crossOrigin)), n.src = o;\n    }, a), n) : t.isInstanceOf("Blob", e) || t.isInstanceOf("File", e) ? (o = n._objectURL = t.createObjectURL(e)) ? (n.src = o, n) : t.readFile(e, function (e) {\n      var t = e.target;\n      t && t.result ? n.src = t.result : i && i(e);\n    }) : void 0;\n  }\n\n  function i(e, i) {\n    !e._objectURL || i && i.noRevoke || (t.revokeObjectURL(e._objectURL), delete e._objectURL);\n  }\n\n  var a = e.createObjectURL && e || e.URL && URL.revokeObjectURL && URL || e.webkitURL && webkitURL;\n  t.fetchBlob = function (e, t, i) {\n    t();\n  }, t.isInstanceOf = function (e, t) {\n    return Object.prototype.toString.call(t) === "[object " + e + "]";\n  }, t.transform = function (e, t, i, a, o) {\n    i(e, o);\n  }, t.onerror = function (e, t, a, o, n) {\n    i(e, n), o && o.call(e, t);\n  }, t.onload = function (e, a, o, n, r) {\n    i(e, r), n && t.transform(e, r, n, o, {});\n  }, t.createObjectURL = function (e) {\n    return !!a && a.createObjectURL(e);\n  }, t.revokeObjectURL = function (e) {\n    return !!a && a.revokeObjectURL(e);\n  }, t.readFile = function (t, i, a) {\n    if (e.FileReader) {\n      var o = new FileReader();\n      if (o.onload = o.onerror = i, a = a || "readAsDataURL", o[a]) return o[a](t), o;\n    }\n\n    return !1;\n  }, "function" == typeof define && define.amd ? define(function () {\n    return t;\n  }) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = t : e.loadImage = t;\n}("undefined" != typeof window && window || this), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image"], e) : e("object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? require("./load-image") : window.loadImage);\n}(function (e) {\n  "use strict";\n\n  var t = e.transform;\n  e.transform = function (i, a, o, n, r) {\n    t.call(e, e.scale(i, a, r), a, o, n, r);\n  }, e.transformCoordinates = function () {}, e.getTransformedOptions = function (e, t) {\n    var i,\n        a,\n        o,\n        n,\n        r = t.aspectRatio;\n    if (!r) return t;\n    i = {};\n\n    for (a in t) {\n      t.hasOwnProperty(a) && (i[a] = t[a]);\n    }\n\n    return i.crop = !0, o = e.naturalWidth || e.width, n = e.naturalHeight || e.height, o / n > r ? (i.maxWidth = n * r, i.maxHeight = n) : (i.maxWidth = o, i.maxHeight = o / r), i;\n  }, e.renderImageToCanvas = function (e, t, i, a, o, n, r, s, l, d) {\n    return e.getContext("2d").drawImage(t, i, a, o, n, r, s, l, d), e;\n  }, e.hasCanvasOption = function (e) {\n    return e.canvas || e.crop || !!e.aspectRatio;\n  }, e.scale = function (t, i, a) {\n    function o() {\n      var e = Math.max((l || v) / v, (d || P) / P);\n      e > 1 && (v *= e, P *= e);\n    }\n\n    function n() {\n      var e = Math.min((r || v) / v, (s || P) / P);\n      e < 1 && (v *= e, P *= e);\n    }\n\n    i = i || {};\n    var r,\n        s,\n        l,\n        d,\n        c,\n        u,\n        f,\n        g,\n        h,\n        m,\n        p,\n        S = document.createElement("canvas"),\n        b = t.getContext || e.hasCanvasOption(i) && S.getContext,\n        y = t.naturalWidth || t.width,\n        x = t.naturalHeight || t.height,\n        v = y,\n        P = x;\n\n    if (b && (f = (i = e.getTransformedOptions(t, i, a)).left || 0, g = i.top || 0, i.sourceWidth ? (c = i.sourceWidth, void 0 !== i.right && void 0 === i.left && (f = y - c - i.right)) : c = y - f - (i.right || 0), i.sourceHeight ? (u = i.sourceHeight, void 0 !== i.bottom && void 0 === i.top && (g = x - u - i.bottom)) : u = x - g - (i.bottom || 0), v = c, P = u), r = i.maxWidth, s = i.maxHeight, l = i.minWidth, d = i.minHeight, b && r && s && i.crop ? (v = r, P = s, (p = c / u - r / s) < 0 ? (u = s * c / r, void 0 === i.top && void 0 === i.bottom && (g = (x - u) / 2)) : p > 0 && (c = r * u / s, void 0 === i.left && void 0 === i.right && (f = (y - c) / 2))) : ((i.contain || i.cover) && (l = r = r || l, d = s = s || d), i.cover ? (n(), o()) : (o(), n())), b) {\n      if ((h = i.pixelRatio) > 1 && (S.style.width = v + "px", S.style.height = P + "px", v *= h, P *= h, S.getContext("2d").scale(h, h)), (m = i.downsamplingRatio) > 0 && m < 1 && v < c && P < u) for (; c * m > v;) {\n        S.width = c * m, S.height = u * m, e.renderImageToCanvas(S, t, f, g, c, u, 0, 0, S.width, S.height), f = 0, g = 0, c = S.width, u = S.height, (t = document.createElement("canvas")).width = c, t.height = u, e.renderImageToCanvas(t, S, 0, 0, c, u, 0, 0, c, u);\n      }\n      return S.width = v, S.height = P, e.transformCoordinates(S, i), e.renderImageToCanvas(S, t, f, g, c, u, 0, 0, v, P);\n    }\n\n    return t.width = v, t.height = P, t;\n  };\n}), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image"], e) : e("object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? require("./load-image") : window.loadImage);\n}(function (e) {\n  "use strict";\n\n  var t = "undefined" != typeof Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n  e.blobSlice = t && function () {\n    return (this.slice || this.webkitSlice || this.mozSlice).apply(this, arguments);\n  }, e.metaDataParsers = {\n    jpeg: {\n      65505: []\n    }\n  }, e.parseMetaData = function (t, i, a, o) {\n    a = a || {}, o = o || {};\n    var n = this,\n        r = a.maxMetaDataSize || 262144;\n    !!("undefined" != typeof DataView && t && t.size >= 12 && "image/jpeg" === t.type && e.blobSlice) && e.readFile(e.blobSlice.call(t, 0, r), function (t) {\n      if (t.target.error) return console.log(t.target.error), void i(o);\n      var r,\n          s,\n          l,\n          d,\n          c = t.target.result,\n          u = new DataView(c),\n          f = 2,\n          g = u.byteLength - 4,\n          h = f;\n\n      if (65496 === u.getUint16(0)) {\n        for (; f < g && ((r = u.getUint16(f)) >= 65504 && r <= 65519 || 65534 === r);) {\n          if (s = u.getUint16(f + 2) + 2, f + s > u.byteLength) {\n            console.log("Invalid meta data: Invalid segment size.");\n            break;\n          }\n\n          if (l = e.metaDataParsers.jpeg[r]) for (d = 0; d < l.length; d += 1) {\n            l[d].call(n, u, f, s, o, a);\n          }\n          h = f += s;\n        }\n\n        !a.disableImageHead && h > 6 && (c.slice ? o.imageHead = c.slice(0, h) : o.imageHead = new Uint8Array(c).subarray(0, h));\n      } else console.log("Invalid JPEG file: Missing JPEG marker.");\n\n      i(o);\n    }, "readAsArrayBuffer") || i(o);\n  }, e.hasMetaOption = function (e) {\n    return e && e.meta;\n  };\n  var i = e.transform;\n\n  e.transform = function (t, a, o, n, r) {\n    e.hasMetaOption(a) ? e.parseMetaData(n, function (r) {\n      i.call(e, t, a, o, n, r);\n    }, a, r) : i.apply(e, arguments);\n  };\n}), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image", "./load-image-meta"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? e(require("./load-image"), require("./load-image-meta")) : e(window.loadImage);\n}(function (e) {\n  "use strict";\n\n  "undefined" != typeof fetch && "undefined" != typeof Request && (e.fetchBlob = function (t, i, a) {\n    if (e.hasMetaOption(a)) return fetch(new Request(t, a)).then(function (e) {\n      return e.blob();\n    }).then(i)["catch"](function (e) {\n      console.log(e), i();\n    });\n    i();\n  });\n}), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image", "./load-image-meta"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? e(require("./load-image"), require("./load-image-meta")) : e(window.loadImage);\n}(function (e) {\n  "use strict";\n\n  e.ExifMap = function () {\n    return this;\n  }, e.ExifMap.prototype.map = {\n    Orientation: 274\n  }, e.ExifMap.prototype.get = function (e) {\n    return this[e] || this[this.map[e]];\n  }, e.getExifThumbnail = function (e, t, i) {\n    var a, o, n;\n    {\n      if (i && !(t + i > e.byteLength)) {\n        for (a = [], o = 0; o < i; o += 1) {\n          n = e.getUint8(t + o), a.push((n < 16 ? "0" : "") + n.toString(16));\n        }\n\n        return "data:image/jpeg,%" + a.join("%");\n      }\n\n      console.log("Invalid Exif data: Invalid thumbnail data.");\n    }\n  }, e.exifTagTypes = {\n    1: {\n      getValue: function getValue(e, t) {\n        return e.getUint8(t);\n      },\n      size: 1\n    },\n    2: {\n      getValue: function getValue(e, t) {\n        return String.fromCharCode(e.getUint8(t));\n      },\n      size: 1,\n      ascii: !0\n    },\n    3: {\n      getValue: function getValue(e, t, i) {\n        return e.getUint16(t, i);\n      },\n      size: 2\n    },\n    4: {\n      getValue: function getValue(e, t, i) {\n        return e.getUint32(t, i);\n      },\n      size: 4\n    },\n    5: {\n      getValue: function getValue(e, t, i) {\n        return e.getUint32(t, i) / e.getUint32(t + 4, i);\n      },\n      size: 8\n    },\n    9: {\n      getValue: function getValue(e, t, i) {\n        return e.getInt32(t, i);\n      },\n      size: 4\n    },\n    10: {\n      getValue: function getValue(e, t, i) {\n        return e.getInt32(t, i) / e.getInt32(t + 4, i);\n      },\n      size: 8\n    }\n  }, e.exifTagTypes[7] = e.exifTagTypes[1], e.getExifValue = function (t, i, a, o, n, r) {\n    var s,\n        l,\n        d,\n        c,\n        u,\n        f,\n        g = e.exifTagTypes[o];\n\n    if (g) {\n      if (s = g.size * n, !((l = s > 4 ? i + t.getUint32(a + 8, r) : a + 8) + s > t.byteLength)) {\n        if (1 === n) return g.getValue(t, l, r);\n\n        for (d = [], c = 0; c < n; c += 1) {\n          d[c] = g.getValue(t, l + c * g.size, r);\n        }\n\n        if (g.ascii) {\n          for (u = "", c = 0; c < d.length && "\\0" !== (f = d[c]); c += 1) {\n            u += f;\n          }\n\n          return u;\n        }\n\n        return d;\n      }\n\n      console.log("Invalid Exif data: Invalid data offset.");\n    } else console.log("Invalid Exif data: Invalid tag type.");\n  }, e.parseExifTag = function (t, i, a, o, n) {\n    var r = t.getUint16(a, o);\n    n.exif[r] = e.getExifValue(t, i, a, t.getUint16(a + 2, o), t.getUint32(a + 4, o), o);\n  }, e.parseExifTags = function (e, t, i, a, o) {\n    var n, r, s;\n    if (i + 6 > e.byteLength) console.log("Invalid Exif data: Invalid directory offset.");else {\n      if (n = e.getUint16(i, a), !((r = i + 2 + 12 * n) + 4 > e.byteLength)) {\n        for (s = 0; s < n; s += 1) {\n          this.parseExifTag(e, t, i + 2 + 12 * s, a, o);\n        }\n\n        return e.getUint32(r, a);\n      }\n\n      console.log("Invalid Exif data: Invalid directory size.");\n    }\n  }, e.parseExifData = function (t, i, a, o, n) {\n    if (!n.disableExif) {\n      var r,\n          s,\n          l,\n          d = i + 10;\n      if (1165519206 === t.getUint32(i + 4)) if (d + 8 > t.byteLength) console.log("Invalid Exif data: Invalid segment size.");else if (0 === t.getUint16(i + 8)) {\n        switch (t.getUint16(d)) {\n          case 18761:\n            r = !0;\n            break;\n\n          case 19789:\n            r = !1;\n            break;\n\n          default:\n            return void console.log("Invalid Exif data: Invalid byte alignment marker.");\n        }\n\n        42 === t.getUint16(d + 2, r) ? (s = t.getUint32(d + 4, r), o.exif = new e.ExifMap(), (s = e.parseExifTags(t, d, d + s, r, o)) && !n.disableExifThumbnail && (l = {\n          exif: {}\n        }, s = e.parseExifTags(t, d, d + s, r, l), l.exif[513] && (o.exif.Thumbnail = e.getExifThumbnail(t, d + l.exif[513], l.exif[514]))), o.exif[34665] && !n.disableExifSub && e.parseExifTags(t, d, d + o.exif[34665], r, o), o.exif[34853] && !n.disableExifGps && e.parseExifTags(t, d, d + o.exif[34853], r, o)) : console.log("Invalid Exif data: Missing TIFF marker.");\n      } else console.log("Invalid Exif data: Missing byte alignment offset.");\n    }\n  }, e.metaDataParsers.jpeg[65505].push(e.parseExifData);\n}), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image", "./load-image-exif"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? e(require("./load-image"), require("./load-image-exif")) : e(window.loadImage);\n}(function (e) {\n  "use strict";\n\n  e.ExifMap.prototype.tags = {\n    256: "ImageWidth",\n    257: "ImageHeight",\n    34665: "ExifIFDPointer",\n    34853: "GPSInfoIFDPointer",\n    40965: "InteroperabilityIFDPointer",\n    258: "BitsPerSample",\n    259: "Compression",\n    262: "PhotometricInterpretation",\n    274: "Orientation",\n    277: "SamplesPerPixel",\n    284: "PlanarConfiguration",\n    530: "YCbCrSubSampling",\n    531: "YCbCrPositioning",\n    282: "XResolution",\n    283: "YResolution",\n    296: "ResolutionUnit",\n    273: "StripOffsets",\n    278: "RowsPerStrip",\n    279: "StripByteCounts",\n    513: "JPEGInterchangeFormat",\n    514: "JPEGInterchangeFormatLength",\n    301: "TransferFunction",\n    318: "WhitePoint",\n    319: "PrimaryChromaticities",\n    529: "YCbCrCoefficients",\n    532: "ReferenceBlackWhite",\n    306: "DateTime",\n    270: "ImageDescription",\n    271: "Make",\n    272: "Model",\n    305: "Software",\n    315: "Artist",\n    33432: "Copyright",\n    36864: "ExifVersion",\n    40960: "FlashpixVersion",\n    40961: "ColorSpace",\n    40962: "PixelXDimension",\n    40963: "PixelYDimension",\n    42240: "Gamma",\n    37121: "ComponentsConfiguration",\n    37122: "CompressedBitsPerPixel",\n    37500: "MakerNote",\n    37510: "UserComment",\n    40964: "RelatedSoundFile",\n    36867: "DateTimeOriginal",\n    36868: "DateTimeDigitized",\n    37520: "SubSecTime",\n    37521: "SubSecTimeOriginal",\n    37522: "SubSecTimeDigitized",\n    33434: "ExposureTime",\n    33437: "FNumber",\n    34850: "ExposureProgram",\n    34852: "SpectralSensitivity",\n    34855: "PhotographicSensitivity",\n    34856: "OECF",\n    34864: "SensitivityType",\n    34865: "StandardOutputSensitivity",\n    34866: "RecommendedExposureIndex",\n    34867: "ISOSpeed",\n    34868: "ISOSpeedLatitudeyyy",\n    34869: "ISOSpeedLatitudezzz",\n    37377: "ShutterSpeedValue",\n    37378: "ApertureValue",\n    37379: "BrightnessValue",\n    37380: "ExposureBias",\n    37381: "MaxApertureValue",\n    37382: "SubjectDistance",\n    37383: "MeteringMode",\n    37384: "LightSource",\n    37385: "Flash",\n    37396: "SubjectArea",\n    37386: "FocalLength",\n    41483: "FlashEnergy",\n    41484: "SpatialFrequencyResponse",\n    41486: "FocalPlaneXResolution",\n    41487: "FocalPlaneYResolution",\n    41488: "FocalPlaneResolutionUnit",\n    41492: "SubjectLocation",\n    41493: "ExposureIndex",\n    41495: "SensingMethod",\n    41728: "FileSource",\n    41729: "SceneType",\n    41730: "CFAPattern",\n    41985: "CustomRendered",\n    41986: "ExposureMode",\n    41987: "WhiteBalance",\n    41988: "DigitalZoomRatio",\n    41989: "FocalLengthIn35mmFilm",\n    41990: "SceneCaptureType",\n    41991: "GainControl",\n    41992: "Contrast",\n    41993: "Saturation",\n    41994: "Sharpness",\n    41995: "DeviceSettingDescription",\n    41996: "SubjectDistanceRange",\n    42016: "ImageUniqueID",\n    42032: "CameraOwnerName",\n    42033: "BodySerialNumber",\n    42034: "LensSpecification",\n    42035: "LensMake",\n    42036: "LensModel",\n    42037: "LensSerialNumber",\n    0: "GPSVersionID",\n    1: "GPSLatitudeRef",\n    2: "GPSLatitude",\n    3: "GPSLongitudeRef",\n    4: "GPSLongitude",\n    5: "GPSAltitudeRef",\n    6: "GPSAltitude",\n    7: "GPSTimeStamp",\n    8: "GPSSatellites",\n    9: "GPSStatus",\n    10: "GPSMeasureMode",\n    11: "GPSDOP",\n    12: "GPSSpeedRef",\n    13: "GPSSpeed",\n    14: "GPSTrackRef",\n    15: "GPSTrack",\n    16: "GPSImgDirectionRef",\n    17: "GPSImgDirection",\n    18: "GPSMapDatum",\n    19: "GPSDestLatitudeRef",\n    20: "GPSDestLatitude",\n    21: "GPSDestLongitudeRef",\n    22: "GPSDestLongitude",\n    23: "GPSDestBearingRef",\n    24: "GPSDestBearing",\n    25: "GPSDestDistanceRef",\n    26: "GPSDestDistance",\n    27: "GPSProcessingMethod",\n    28: "GPSAreaInformation",\n    29: "GPSDateStamp",\n    30: "GPSDifferential",\n    31: "GPSHPositioningError"\n  }, e.ExifMap.prototype.stringValues = {\n    ExposureProgram: {\n      0: "Undefined",\n      1: "Manual",\n      2: "Normal program",\n      3: "Aperture priority",\n      4: "Shutter priority",\n      5: "Creative program",\n      6: "Action program",\n      7: "Portrait mode",\n      8: "Landscape mode"\n    },\n    MeteringMode: {\n      0: "Unknown",\n      1: "Average",\n      2: "CenterWeightedAverage",\n      3: "Spot",\n      4: "MultiSpot",\n      5: "Pattern",\n      6: "Partial",\n      255: "Other"\n    },\n    LightSource: {\n      0: "Unknown",\n      1: "Daylight",\n      2: "Fluorescent",\n      3: "Tungsten (incandescent light)",\n      4: "Flash",\n      9: "Fine weather",\n      10: "Cloudy weather",\n      11: "Shade",\n      12: "Daylight fluorescent (D 5700 - 7100K)",\n      13: "Day white fluorescent (N 4600 - 5400K)",\n      14: "Cool white fluorescent (W 3900 - 4500K)",\n      15: "White fluorescent (WW 3200 - 3700K)",\n      17: "Standard light A",\n      18: "Standard light B",\n      19: "Standard light C",\n      20: "D55",\n      21: "D65",\n      22: "D75",\n      23: "D50",\n      24: "ISO studio tungsten",\n      255: "Other"\n    },\n    Flash: {\n      0: "Flash did not fire",\n      1: "Flash fired",\n      5: "Strobe return light not detected",\n      7: "Strobe return light detected",\n      9: "Flash fired, compulsory flash mode",\n      13: "Flash fired, compulsory flash mode, return light not detected",\n      15: "Flash fired, compulsory flash mode, return light detected",\n      16: "Flash did not fire, compulsory flash mode",\n      24: "Flash did not fire, auto mode",\n      25: "Flash fired, auto mode",\n      29: "Flash fired, auto mode, return light not detected",\n      31: "Flash fired, auto mode, return light detected",\n      32: "No flash function",\n      65: "Flash fired, red-eye reduction mode",\n      69: "Flash fired, red-eye reduction mode, return light not detected",\n      71: "Flash fired, red-eye reduction mode, return light detected",\n      73: "Flash fired, compulsory flash mode, red-eye reduction mode",\n      77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",\n      79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",\n      89: "Flash fired, auto mode, red-eye reduction mode",\n      93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",\n      95: "Flash fired, auto mode, return light detected, red-eye reduction mode"\n    },\n    SensingMethod: {\n      1: "Undefined",\n      2: "One-chip color area sensor",\n      3: "Two-chip color area sensor",\n      4: "Three-chip color area sensor",\n      5: "Color sequential area sensor",\n      7: "Trilinear sensor",\n      8: "Color sequential linear sensor"\n    },\n    SceneCaptureType: {\n      0: "Standard",\n      1: "Landscape",\n      2: "Portrait",\n      3: "Night scene"\n    },\n    SceneType: {\n      1: "Directly photographed"\n    },\n    CustomRendered: {\n      0: "Normal process",\n      1: "Custom process"\n    },\n    WhiteBalance: {\n      0: "Auto white balance",\n      1: "Manual white balance"\n    },\n    GainControl: {\n      0: "None",\n      1: "Low gain up",\n      2: "High gain up",\n      3: "Low gain down",\n      4: "High gain down"\n    },\n    Contrast: {\n      0: "Normal",\n      1: "Soft",\n      2: "Hard"\n    },\n    Saturation: {\n      0: "Normal",\n      1: "Low saturation",\n      2: "High saturation"\n    },\n    Sharpness: {\n      0: "Normal",\n      1: "Soft",\n      2: "Hard"\n    },\n    SubjectDistanceRange: {\n      0: "Unknown",\n      1: "Macro",\n      2: "Close view",\n      3: "Distant view"\n    },\n    FileSource: {\n      3: "DSC"\n    },\n    ComponentsConfiguration: {\n      0: "",\n      1: "Y",\n      2: "Cb",\n      3: "Cr",\n      4: "R",\n      5: "G",\n      6: "B"\n    },\n    Orientation: {\n      1: "top-left",\n      2: "top-right",\n      3: "bottom-right",\n      4: "bottom-left",\n      5: "left-top",\n      6: "right-top",\n      7: "right-bottom",\n      8: "left-bottom"\n    }\n  }, e.ExifMap.prototype.getText = function (e) {\n    var t = this.get(e);\n\n    switch (e) {\n      case "LightSource":\n      case "Flash":\n      case "MeteringMode":\n      case "ExposureProgram":\n      case "SensingMethod":\n      case "SceneCaptureType":\n      case "SceneType":\n      case "CustomRendered":\n      case "WhiteBalance":\n      case "GainControl":\n      case "Contrast":\n      case "Saturation":\n      case "Sharpness":\n      case "SubjectDistanceRange":\n      case "FileSource":\n      case "Orientation":\n        return this.stringValues[e][t];\n\n      case "ExifVersion":\n      case "FlashpixVersion":\n        if (!t) return;\n        return String.fromCharCode(t[0], t[1], t[2], t[3]);\n\n      case "ComponentsConfiguration":\n        if (!t) return;\n        return this.stringValues[e][t[0]] + this.stringValues[e][t[1]] + this.stringValues[e][t[2]] + this.stringValues[e][t[3]];\n\n      case "GPSVersionID":\n        if (!t) return;\n        return t[0] + "." + t[1] + "." + t[2] + "." + t[3];\n    }\n\n    return String(t);\n  }, function (e) {\n    var t,\n        i = e.tags,\n        a = e.map;\n\n    for (t in i) {\n      i.hasOwnProperty(t) && (a[i[t]] = t);\n    }\n  }(e.ExifMap.prototype), e.ExifMap.prototype.getAll = function () {\n    var e,\n        t,\n        i = {};\n\n    for (e in this) {\n      this.hasOwnProperty(e) && (t = this.tags[e]) && (i[t] = this.getText(t));\n    }\n\n    return i;\n  };\n}), function (e) {\n  "use strict";\n\n  "function" == typeof define && define.amd ? define(["./load-image", "./load-image-scale", "./load-image-meta"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? e(require("./load-image"), require("./load-image-scale"), require("./load-image-meta")) : e(window.loadImage);\n}(function (e) {\n  "use strict";\n\n  var t = e.hasCanvasOption,\n      i = e.hasMetaOption,\n      a = e.transformCoordinates,\n      o = e.getTransformedOptions;\n  e.hasCanvasOption = function (i) {\n    return !!i.orientation || t.call(e, i);\n  }, e.hasMetaOption = function (t) {\n    return t && !0 === t.orientation || i.call(e, t);\n  }, e.transformCoordinates = function (t, i) {\n    a.call(e, t, i);\n    var o = t.getContext("2d"),\n        n = t.width,\n        r = t.height,\n        s = t.style.width,\n        l = t.style.height,\n        d = i.orientation;\n    if (d && !(d > 8)) switch (d > 4 && (t.width = r, t.height = n, t.style.width = l, t.style.height = s), d) {\n      case 2:\n        o.translate(n, 0), o.scale(-1, 1);\n        break;\n\n      case 3:\n        o.translate(n, r), o.rotate(Math.PI);\n        break;\n\n      case 4:\n        o.translate(0, r), o.scale(1, -1);\n        break;\n\n      case 5:\n        o.rotate(.5 * Math.PI), o.scale(1, -1);\n        break;\n\n      case 6:\n        o.rotate(.5 * Math.PI), o.translate(0, -r);\n        break;\n\n      case 7:\n        o.rotate(.5 * Math.PI), o.translate(n, -r), o.scale(-1, 1);\n        break;\n\n      case 8:\n        o.rotate(-.5 * Math.PI), o.translate(-n, 0);\n    }\n  }, e.getTransformedOptions = function (t, i, a) {\n    var n,\n        r,\n        s = o.call(e, t, i),\n        l = s.orientation;\n    if (!0 === l && a && a.exif && (l = a.exif.get("Orientation")), !l || l > 8 || 1 === l) return s;\n    n = {};\n\n    for (r in s) {\n      s.hasOwnProperty(r) && (n[r] = s[r]);\n    }\n\n    switch (n.orientation = l, l) {\n      case 2:\n        n.left = s.right, n.right = s.left;\n        break;\n\n      case 3:\n        n.left = s.right, n.top = s.bottom, n.right = s.left, n.bottom = s.top;\n        break;\n\n      case 4:\n        n.top = s.bottom, n.bottom = s.top;\n        break;\n\n      case 5:\n        n.left = s.top, n.top = s.left, n.right = s.bottom, n.bottom = s.right;\n        break;\n\n      case 6:\n        n.left = s.top, n.top = s.right, n.right = s.bottom, n.bottom = s.left;\n        break;\n\n      case 7:\n        n.left = s.bottom, n.top = s.right, n.right = s.top, n.bottom = s.left;\n        break;\n\n      case 8:\n        n.left = s.bottom, n.top = s.left, n.right = s.top, n.bottom = s.right;\n    }\n\n    return n.orientation > 4 && (n.maxWidth = s.maxHeight, n.maxHeight = s.maxWidth, n.minWidth = s.minHeight, n.minHeight = s.minWidth, n.sourceWidth = s.sourceHeight, n.sourceHeight = s.sourceWidth), n;\n  };\n});'}},[[2302,0]]]);
//# sourceMappingURL=global-54744e93b633a0c6d8fd.chunk.js.map